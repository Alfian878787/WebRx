[4mRunning "gen-ver" task[24m

[4mRunning "shell:tsc_src" (shell) task[24m

[4mRunning "madge:src" (madge) task[24m
Checking build/src/App.js...[32mOK[39m

[4mRunning "webpack:webrx" (webpack) task[24m
  0% compile 10% 0/1 build modules 70% 1/1 build modules 40% 1/2 build modules 30% 1/3 build modules 25% 1/4 build modules 22% 1/5 build modules 20% 1/6 build modules 18% 1/7 build modules 17% 1/8 build modules 16% 1/9 build modules 16% 1/10 build modules 15% 1/11 build modules 15% 1/12 build modules 14% 1/13 build modules 14% 1/14 build modules 14% 1/15 build modules 13% 1/16 build modules 13% 1/17 build modules 13% 1/18 build modules 13% 1/19 build modules 13% 1/20 build modules 12% 1/21 build modules 12% 1/22 build modules 12% 1/23 build modules 12% 1/24 build modules 12% 1/25 build modules 12% 1/26 build modules 12% 1/27 build modules 12% 1/28 build modules 12% 1/29 build modules 12% 1/30 build modules 11% 1/31 build modules 11% 1/32 build modules 11% 1/33 build modules 11% 1/34 build modules 13% 2/34 build modules 15% 3/34 build modules 17% 4/34 build modules 18% 5/34 build modules 20% 6/34 build modules 22% 7/34 build modules 24% 8/34 build modules 25% 9/34 build modules 27% 10/34 build modules 29% 11/34 build modules 31% 12/34 build modules 32% 13/34 build modules 34% 14/34 build modules 36% 15/34 build modules 38% 16/34 build modules 40% 17/34 build modules 41% 18/34 build modules 43% 19/34 build modules 45% 20/34 build modules 47% 21/34 build modules 48% 22/34 build modules 50% 23/34 build modules 52% 24/34 build modules 54% 25/34 build modules 55% 26/34 build modules 57% 27/34 build modules 59% 28/34 build modules 61% 29/34 build modules 62% 30/34 build modules 64% 31/34 build modules 66% 32/34 build modules 68% 33/34 build modules 70% 34/34 build modules 68% 34/35 build modules 66% 34/36 build modules 65% 34/37 build modules 63% 34/38 build modules 62% 34/39 build modules 61% 34/40 build modules 59% 34/41 build modules 58% 34/42 build modules 57% 34/43 build modules 56% 34/44 build modules 55% 34/45 build modules 54% 34/46 build modules 55% 35/46 build modules 56% 36/46 build modules 58% 37/46 build modules 59% 38/46 build modules 60% 39/46 build modules 62% 40/46 build modules 63% 41/46 build modules 64% 42/46 build modules 66% 43/46 build modules 67% 44/46 build modules 68% 45/46 build modules 70% 46/46 build modules 68% 46/47 build modules 67% 46/48 build modules 66% 46/49 build modules 67% 47/49 build modules 68% 48/49 build modules 70% 49/49 build modules                71% seal 73% optimize  75% hashing 76% create chunk assets 78% additional chunk assets   80% optimize chunk assets       90% optimize assets            95% emit         Version: webpack [1m1.9.10[22m
        [1mAsset[22m    [1mSize[22m  [1mChunks[22m  [1m[22m           [1mChunk Names[22m
    [1m[32mweb.rx.js[39m[22m  381 kB       [1m0[22m  [1m[32m[emitted][39m[22m  main
[1m[32mweb.rx.js.map[39m[22m  452 kB       [1m0[22m  [1m[32m[emitted][39m[22m  main
   [0] [1m./build/src/App.js[22m 11.8 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
   [1] [1m./build/src/Core/Injector.js[22m 3.96 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/Injector[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 8:17-43
       cjs require [1m[36m./Injector[39m[22m [13] [1m[35m./build/src/Core/Module.js[39m[22m 2:17-38
       cjs require [1m[36m./Injector[39m[22m [15] [1m[35m./build/src/Core/DomManager.js[39m[22m 5:17-38
       cjs require [1m[36m../Core/Injector[39m[22m [19] [1m[35m./build/src/Core/Command.js[39m[22m 16:17-44
       cjs require [1m[36m../Core/Injector[39m[22m [24] [1m[35m./build/src/Bindings/ForEach.js[39m[22m 6:17-44
       cjs require [1m[36m../Core/Injector[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 28:17-44
       cjs require [1m[36m./Core/Injector[39m[22m [48] [1m[35m./build/src/RxExtensions.js[39m[22m 6:17-43
   [2] [1m./build/src/Core/Utils.js[22m 16.6 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/Utils[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 9:14-37
       cjs require [1m[36m../Core/Utils[39m[22m [1] [1m[35m./build/src/Core/Injector.js[39m[22m 2:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [11] [1m[35m./build/src/Core/Log.js[39m[22m 1:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [13] [1m[35m./build/src/Core/Module.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [14] [1m[35m./build/src/Core/ExpressionCompiler.js[39m[22m 2:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [15] [1m[35m./build/src/Core/DomManager.js[39m[22m 6:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [18] [1m[35m./build/src/Bindings/Command.js[39m[22m 3:14-38
       cjs require [1m[36m././Utils[39m[22m [19] [1m[35m./build/src/Core/Command.js[39m[22m 14:14-34
       cjs require [1m[36m../Core/Utils[39m[22m [20] [1m[35m./build/src/Bindings/Module.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [21] [1m[35m./build/src/Bindings/If.js[39m[22m 9:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [22] [1m[35m./build/src/Bindings/MultiOneWay.js[39m[22m 9:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [23] [1m[35m./build/src/Bindings/SimpleOneWay.js[39m[22m 9:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [24] [1m[35m./build/src/Bindings/ForEach.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 19:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [29] [1m[35m./build/src/Core/ScheduledSubject.js[39m[22m 1:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [30] [1m[35m./build/src/Bindings/Event.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [31] [1m[35m./build/src/Bindings/Value.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [32] [1m[35m./build/src/Bindings/HasFocus.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [33] [1m[35m./build/src/Bindings/With.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [34] [1m[35m./build/src/Bindings/Checked.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [35] [1m[35m./build/src/Bindings/KeyPress.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [36] [1m[35m./build/src/Bindings/TextInput.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [37] [1m[35m./build/src/Bindings/SelectedValue.js[39m[22m 3:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [38] [1m[35m./build/src/Bindings/Component.js[39m[22m 3:14-38
       cjs require [1m[36m../../Core/Utils[39m[22m [39] [1m[35m./build/src/Routing/Bindings/StateActive.js[39m[22m 3:14-41
       cjs require [1m[36m../../Core/Utils[39m[22m [40] [1m[35m./build/src/Routing/Bindings/View.js[39m[22m 3:14-41
       cjs require [1m[36m../../Core/Utils[39m[22m [41] [1m[35m./build/src/Routing/Bindings/StateRef.js[39m[22m 3:14-41
       cjs require [1m[36m../Core/Utils[39m[22m [42] [1m[35m./build/src/Components/Select.js[39m[22m 2:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [43] [1m[35m./build/src/Components/RadioGroup.js[39m[22m 2:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [44] [1m[35m./build/src/Routing/Router.js[39m[22m 2:14-38
       cjs require [1m[36m../Core/Utils[39m[22m [45] [1m[35m./build/src/Routing/RouteMatcher.js[39m[22m 2:14-38
       cjs require [1m[36m./Core/Utils[39m[22m [48] [1m[35m./build/src/RxExtensions.js[39m[22m 2:14-37
   [3] [1m./build/src/Core/Reflect.js[22m 27.4 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Reflect[39m[22m [2] [1m[35m./build/src/Core/Utils.js[39m[22m 2:16-36
       cjs require [1m[36m./Reflect[39m[22m [12] [1m[35m./build/src/Core/Property.js[39m[22m 2:16-36
       cjs require [1m[36m././Reflect[39m[22m [19] [1m[35m./build/src/Core/Command.js[39m[22m 15:16-38
       cjs require [1m[36m./../Core/Reflect[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 27:16-44
       cjs require [1m[36m./Core/Reflect[39m[22m [48] [1m[35m./build/src/RxExtensions.js[39m[22m 5:16-41
   [4] [1m./build/src/Collections/WeakMap.js[22m 1.96 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m../Collections/WeakMap[39m[22m [3] [1m[35m./build/src/Core/Reflect.js[39m[22m 2:16-49
       cjs require [1m[36m../Collections/WeakMap[39m[22m [15] [1m[35m./build/src/Core/DomManager.js[39m[22m 2:16-49
       cjs require [1m[36m../Collections/WeakMap[39m[22m [16] [1m[35m./build/src/Core/Environment.js[39m[22m 1:16-49
   [5] [1m./build/src/Core/Oid.js[22m 671 bytes {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m../Core/Oid[39m[22m [4] [1m[35m./build/src/Collections/WeakMap.js[39m[22m 3:12-34
       cjs require [1m[36m../Core/Oid[39m[22m [6] [1m[35m./build/src/Collections/Set.js[39m[22m 3:12-34
       cjs require [1m[36m../Core/Oid[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 20:12-34
   [6] [1m./build/src/Collections/Set.js[22m 2.81 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m../Collections/Set[39m[22m [3] [1m[35m./build/src/Core/Reflect.js[39m[22m 3:12-41
       cjs require [1m[36m../Collections/Set[39m[22m [15] [1m[35m./build/src/Core/DomManager.js[39m[22m 3:12-41
   [7] [1m./build/src/Collections/Map.js[22m 3.41 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m../Collections/Map[39m[22m [3] [1m[35m./build/src/Core/Reflect.js[39m[22m 4:12-41
   [8] [1m./build/src/Core/Events.js[22m 653 bytes {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Events[39m[22m [2] [1m[35m./build/src/Core/Utils.js[39m[22m 3:15-34
       cjs require [1m[36m../Core/Events[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 24:15-40
   [9] [1m./build/src/IID.js[22m 476 bytes {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m../IID[39m[22m [2] [1m[35m./build/src/Core/Utils.js[39m[22m 4:12-29
       cjs require [1m[36m../IID[39m[22m [12] [1m[35m./build/src/Core/Property.js[39m[22m 3:12-29
       cjs require [1m[36m../IID[39m[22m [15] [1m[35m./build/src/Core/DomManager.js[39m[22m 4:12-29
       cjs require [1m[36m./../IID[39m[22m [19] [1m[35m./build/src/Core/Command.js[39m[22m 13:12-31
       cjs require [1m[36m./../IID[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 21:12-31
       cjs require [1m[36m./IID[39m[22m [48] [1m[35m./build/src/RxExtensions.js[39m[22m 3:12-28
  [10] [1m./build/src/Core/Resources.js[22m 403 bytes {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/Resources[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 10:10-37
       cjs require [1m[36m./Resources[39m[22m [1] [1m[35m./build/src/Core/Injector.js[39m[22m 3:10-32
       cjs require [1m[36m./Resources[39m[22m [13] [1m[35m./build/src/Core/Module.js[39m[22m 4:10-32
       cjs require [1m[36m./Resources[39m[22m [15] [1m[35m./build/src/Core/DomManager.js[39m[22m 7:10-32
       cjs require [1m[36m../Core/Resources[39m[22m [19] [1m[35m./build/src/Core/Command.js[39m[22m 17:10-38
       cjs require [1m[36m../Core/Resources[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 29:10-38
       cjs require [1m[36m../Core/Resources[39m[22m [31] [1m[35m./build/src/Bindings/Value.js[39m[22m 4:10-38
       cjs require [1m[36m./Core/Resources[39m[22m [48] [1m[35m./build/src/RxExtensions.js[39m[22m 7:10-37
  [11] [1m./build/src/Core/Log.js[22m 1.44 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/Log[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 11:10-31
       cjs require [1m[36m./../Core/Log[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 26:10-34
  [12] [1m./build/src/Core/Property.js[22m 1.72 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/Property[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 12:17-43
       cjs require [1m[36m./../Core/Property[39m[22m [44] [1m[35m./build/src/Routing/Router.js[39m[22m 3:17-46
  [13] [1m./build/src/Core/Module.js[22m 12.7 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/Module[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 13:15-39
       cjs require [1m[36m../Core/Module[39m[22m [20] [1m[35m./build/src/Bindings/Module.js[39m[22m 4:15-40
  [14] [1m./build/src/Core/ExpressionCompiler.js[22m 43.4 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/ExpressionCompiler[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 14:25-61
  [15] [1m./build/src/Core/DomManager.js[22m 20.4 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/DomManager[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 15:19-47
  [16] [1m./build/src/Core/Environment.js[22m 3.6 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Environment[39m[22m [15] [1m[35m./build/src/Core/DomManager.js[39m[22m 8:10-34
       cjs require [1m[36m../Core/Environment[39m[22m [36] [1m[35m./build/src/Bindings/TextInput.js[39m[22m 4:10-40
  [17] [1m./build/src/Core/HtmlTemplateEngine.js[22m 4.65 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/HtmlTemplateEngine[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 16:27-63
  [18] [1m./build/src/Bindings/Command.js[22m 4.22 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/Command[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 17:16-45
  [19] [1m./build/src/Core/Command.js[22m 9.66 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m../Core/Command[39m[22m [18] [1m[35m./build/src/Bindings/Command.js[39m[22m 4:16-42
       cjs require [1m[36m../Core/Command[39m[22m [30] [1m[35m./build/src/Bindings/Event.js[39m[22m 4:16-42
       cjs require [1m[36m../Core/Command[39m[22m [35] [1m[35m./build/src/Bindings/KeyPress.js[39m[22m 4:16-42
  [20] [1m./build/src/Bindings/Module.js[22m 4.54 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/Module[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 18:15-43
  [21] [1m./build/src/Bindings/If.js[22m 5.84 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/If[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 19:11-35
  [22] [1m./build/src/Bindings/MultiOneWay.js[22m 6.38 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/MultiOneWay[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 20:20-53
  [23] [1m./build/src/Bindings/SimpleOneWay.js[22m 5.54 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/SimpleOneWay[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 21:21-55
  [24] [1m./build/src/Bindings/ForEach.js[22m 17 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/ForEach[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 22:16-45
  [25] [1m./build/src/Core/VirtualChildNodes.js[22m 3.36 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./../Core/VirtualChildNodes[39m[22m [24] [1m[35m./build/src/Bindings/ForEach.js[39m[22m 4:26-64
  [26] [1m./build/src/Core/RefCountDisposeWrapper.js[22m 853 bytes {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./../Core/RefCountDisposeWrapper[39m[22m [24] [1m[35m./build/src/Bindings/ForEach.js[39m[22m 5:31-74
       cjs require [1m[36m./../Core/RefCountDisposeWrapper[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 25:31-74
  [27] [1m./build/src/Collections/List.js[22m 51.1 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m../Collections/List[39m[22m [24] [1m[35m./build/src/Bindings/ForEach.js[39m[22m 7:13-43
       cjs require [1m[36m../Collections/List[39m[22m [37] [1m[35m./build/src/Bindings/SelectedValue.js[39m[22m 5:13-43
  [28] [1m./build/src/Core/Lazy.js[22m 598 bytes {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./../Core/Lazy[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 22:13-38
  [29] [1m./build/src/Core/ScheduledSubject.js[22m 2.11 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./../Core/ScheduledSubject[39m[22m [27] [1m[35m./build/src/Collections/List.js[39m[22m 23:25-62
       cjs require [1m[36m./../Core/ScheduledSubject[39m[22m [46] [1m[35m./build/src/Core/MessageBus.js[39m[22m 2:25-62
       cjs require [1m[36m./Core/ScheduledSubject[39m[22m [48] [1m[35m./build/src/RxExtensions.js[39m[22m 4:25-59
  [30] [1m./build/src/Bindings/Event.js[22m 3.62 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/Event[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 23:14-41
  [31] [1m./build/src/Bindings/Value.js[22m 5.84 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/Value[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 24:14-41
       cjs require [1m[36m./Value[39m[22m [37] [1m[35m./build/src/Bindings/SelectedValue.js[39m[22m 4:14-32
  [32] [1m./build/src/Bindings/HasFocus.js[22m 5.47 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/HasFocus[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 25:17-47
  [33] [1m./build/src/Bindings/With.js[22m 2.12 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/With[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 26:13-39
  [34] [1m./build/src/Bindings/Checked.js[22m 3.79 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/Checked[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 27:16-45
  [35] [1m./build/src/Bindings/KeyPress.js[22m 6.22 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/KeyPress[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 28:17-47
  [36] [1m./build/src/Bindings/TextInput.js[22m 7.34 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/TextInput[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 29:18-49
  [37] [1m./build/src/Bindings/SelectedValue.js[22m 6.73 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/SelectedValue[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 30:22-57
  [38] [1m./build/src/Bindings/Component.js[22m 5.58 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Bindings/Component[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 31:18-49
  [39] [1m./build/src/Routing/Bindings/StateActive.js[22m 3.84 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Routing/Bindings/StateActive[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 32:20-61
  [40] [1m./build/src/Routing/Bindings/View.js[22m 6.67 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Routing/Bindings/View[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 33:13-47
  [41] [1m./build/src/Routing/Bindings/StateRef.js[22m 3.67 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Routing/Bindings/StateRef[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 34:17-55
  [42] [1m./build/src/Components/Select.js[22m 4.38 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Components/Select[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 35:15-45
  [43] [1m./build/src/Components/RadioGroup.js[22m 4.01 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Components/RadioGroup[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 36:19-53
  [44] [1m./build/src/Routing/Router.js[22m 16.1 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Routing/Router[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 37:15-42
  [45] [1m./build/src/Routing/RouteMatcher.js[22m 6.7 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./RouteMatcher[39m[22m [44] [1m[35m./build/src/Routing/Router.js[39m[22m 4:21-46
  [46] [1m./build/src/Core/MessageBus.js[22m 1.78 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Core/MessageBus[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 38:19-47
  [47] [1m./build/src/Version.js[22m 64 bytes {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./Version[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 39:16-36
  [48] [1m./build/src/RxExtensions.js[22m 3.84 kB {[1m[33m0[39m[22m}[1m[32m [built][39m[22m
       cjs require [1m[36m./RxExtensions[39m[22m [0] [1m[35m./build/src/App.js[39m[22m 41:21-46

[4mRunning "shell:tsc_specs" (shell) task[24m

[4mRunning "jasmine:default" (jasmine) task[24m
Testing jasmine specs via PhantomJS

[31m>> [39mError: Mismatched anonymous define() module: function () {[31m
>> [39mreturn /******/ (function(modules) { // webpackBootstrap[31m
>> [39m/******/ 	// The module cache[31m
>> [39m/******/ 	var installedModules = {};[31m
>> [39m/******/[31m
>> [39m/******/ 	// The require function[31m
>> [39m/******/ 	function [4m_webpack_require__(moduleId) {[31m
>> [39m/******/[31m
>> [39m/******/ 		// Check if module is in cache[31m
>> [39m/******/ 		if(installedModules[moduleId])[31m
>> [39m/******/ 			return installedModules[moduleId].exports;[31m
>> [39m/******/[31m
>> [39m/******/ 		// Create a new module (and put it into the cache)[31m
>> [39m/******/ 		var module = installedModules[moduleId] = {[31m
>> [39m/******/ 			exports: {},[31m
>> [39m/******/ 			id: moduleId,[31m
>> [39m/******/ 			loaded: false[31m
>> [39m/******/ 		};[31m
>> [39m/******/[31m
>> [39m/******/ 		// Execute the module function[31m
>> [39m/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);[31m
>> [39m/******/[31m
>> [39m/******/ 		// Flag the module as loaded[31m
>> [39m/******/ 		module.loaded = true;[31m
>> [39m/******/[31m
>> [39m/******/ 		// Return the exports of the module[31m
>> [39m/******/ 		return module.exports;[31m
>> [39m/******/ 	}[31m
>> [39m/******/[31m
>> [39m/******/[31m
>> [39m/******/ 	// expose the modules object (__webpack_modules__)[31m
>> [39m/******/ 	__webpack_require_[24m.m = modules;[31m
>> [39m/******/[31m
>> [39m/******/ 	// expose the module cache[31m
>> [39m/******/ 	[4m_webpack_require_[24m.c = installedModules;[31m
>> [39m/******/[31m
>> [39m/******/ 	// [4m_webpack_public_path__[31m
>> [39m/******/ 	__webpack_require_[24m.p = "";[31m
>> [39m/******/[31m
>> [39m/******/ 	// Load entry module and return exports[31m
>> [39m/******/ 	return [4m_webpack_require__(0);[31m
>> [39m/******/ })[31m
>> [39m/************************************************************************/[31m
>> [39m/******/ ([[31m
>> [39m/* 0 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="./Interfaces.ts" />[31m
>> [39m	var __extends = (this && this.__extends) || function (d, b) {[31m
>> [39m	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];[31m
>> [39m	    function __() { this.constructor = d; }[31m
>> [39m	    _[24m.prototype = b.prototype;[31m
>> [39m	    d.prototype = new [4m_();[31m
>> [39m	};[31m
>> [39m	var Injector_1 = __webpack_require__(1);[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var res = __webpack_require__(10);[31m
>> [39m	var log = __webpack_require__(11);[31m
>> [39m	var Property_1 = __webpack_require__(12);[31m
>> [39m	var Module_1 = __webpack_require__(13);[31m
>> [39m	var ExpressionCompiler = __webpack_require__(14);[31m
>> [39m	var DomManager_1 = __webpack_require__(15);[31m
>> [39m	var HtmlTemplateEngine_1 = __webpack_require__(17);[31m
>> [39m	var Command_1 = __webpack_require__(18);[31m
>> [39m	var Module_2 = __webpack_require__(20);[31m
>> [39m	var If_1 = __webpack_require__(21);[31m
>> [39m	var MultiOneWay_1 = __webpack_require__(22);[31m
>> [39m	var SimpleOneWay_1 = __webpack_require__(23);[31m
>> [39m	var ForEach_1 = __webpack_require__(24);[31m
>> [39m	var Event_1 = __webpack_require__(30);[31m
>> [39m	var Value_1 = __webpack_require__(31);[31m
>> [39m	var HasFocus_1 = __webpack_require__(32);[31m
>> [39m	var With_1 = __webpack_require__(33);[31m
>> [39m	var Checked_1 = __webpack_require__(34);[31m
>> [39m	var KeyPress_1 = __webpack_require__(35);[31m
>> [39m	var TextInput_1 = __webpack_require__(36);[31m
>> [39m	var SelectedValue_1 = __webpack_require__(37);[31m
>> [39m	var Component_1 = __webpack_require__(38);[31m
>> [39m	var StateActive_1 = __webpack_require__(39);[31m
>> [39m	var View_1 = __webpack_require__(40);[31m
>> [39m	var StateRef_1 = __webpack_require__(41);[31m
>> [39m	var Select_1 = __webpack_require__(42);[31m
>> [39m	var RadioGroup_1 = __webpack_require__(43);[31m
>> [39m	var Router_1 = __webpack_require__(44);[31m
>> [39m	var MessageBus_1 = __webpack_require__(46);[31m
>> [39m	var Version_1 = __webpack_require__(47);[31m
>> [39m	// make sure RxExtensions get installed[31m
>> [39m	var RxExtensions_1 = __webpack_require__(48);[31m
>> [39m	RxExtensions_1.install();[31m
>> [39m	"use strict";[31m
>> [39m	var App = (function (_super) {[31m
>> [39m	    __extends(App, _super);[31m
>> [39m	    function App() {[31m
>> [39m	        _super.call(this, "app");[31m
>> [39m	        /// <summary>[31m
>> [39m	        /// This Observer is signalled whenever an object that has a[31m
>> [39m	        /// ThrownExceptions property doesn't Subscribe to that Observable. Use[31m
>> [39m	        /// Observer.Create to set up what will happen - the default is to crash[31m
>> [39m	        /// the application with an error message.[31m
>> [39m	        /// </summary>[31m
>> [39m	        this.defaultExceptionHandler = Rx.Observer.create(function (ex) {[31m
>> [39m	            if (!Utils_1.isInUnitTest()) {[31m
>> [39m	                log.error("An onError occurred on an object (usually a computedProperty) that would break a binding or command. To prevent this, subscribe to the thrownExceptions property of your objects: {0}", ex);[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	        this.title = Property_1.property(document.title);[31m
>> [39m	        this.version = Version_1.version;[31m
>> [39m	        if (!Utils_1.isInUnitTest()) {[31m
>> [39m	            this.history = this.createHistory();[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            this.history = createMockHistory();[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    Object.defineProperty(App.prototype, "mainThreadScheduler", {[31m
>> [39m	        /// <summary>[31m
>> [39m	        /// MainThreadScheduler is the scheduler used to schedule work items that[31m
>> [39m	        /// should be run "on the UI thread". In normal mode, this will be[31m
>> [39m	        /// DispatcherScheduler, and in Unit Test mode this will be Immediate,[31m
>> [39m	        /// to simplify writing common unit tests.[31m
>> [39m	        /// </summary>[31m
>> [39m	        get: function () {[31m
>> [39m	            return this._unitTestMainThreadScheduler || this._mainThreadScheduler[31m
>> [39m	                || Rx.Scheduler.currentThread; // OW: return a default if schedulers haven't been setup by in[31m
>> [39m	        },[31m
>> [39m	        set: function (value) {[31m
>> [39m	            if (Utils_1.isInUnitTest()) {[31m
>> [39m	                this._unitTestMainThreadScheduler = value;[31m
>> [39m	                this._mainThreadScheduler = this._mainThreadScheduler || value;[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                this._mainThreadScheduler = value;[31m
>> [39m	            }[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(App.prototype, "templateEngine", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._templateEngine) {[31m
>> [39m	                this._templateEngine = Injector_1.injector.get(res.templateEngine);[31m
>> [39m	            }[31m
>> [39m	            return this._templateEngine;[31m
>> [39m	        },[31m
>> [39m	        set: function (newVal) {[31m
>> [39m	            this._templateEngine = newVal;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(App.prototype, "router", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._router) {[31m
>> [39m	                this._router = Injector_1.injector.get(res.router);[31m
>> [39m	            }[31m
>> [39m	            return this._router;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    App.prototype.createHistory = function () {[31m
>> [39m	        // inherit default implementation[31m
>> [39m	        var result = {[31m
>> [39m	            back: window.history.back.bind(window.history),[31m
>> [39m	            forward: window.history.forward.bind(window.history),[31m
>> [39m	            //go: window.history.go,[31m
>> [39m	            pushState: window.history.pushState.bind(window.history),[31m
>> [39m	            replaceState: window.history.replaceState.bind(window.history),[31m
>> [39m	            getSearchParameters: function (query) {[31m
>> [39m	                query = query || result.location.search.substr(1);[31m
>> [39m	                if (query) {[31m
>> [39m	                    var result_1 = {};[31m
>> [39m	                    var params = query.split("&");[31m
>> [39m	                    for (var i = 0; i < params.length; i++) {[31m
>> [39m	                        var tmp = params[i].split("=");[31m
>> [39m	                        result_1[tmp[0]] = decodeURIComponent(tmp[1]);[31m
>> [39m	                    }[31m
>> [39m	                    return result_1;[31m
>> [39m	                }[31m
>> [39m	                return {};[31m
>> [39m	            }[31m
>> [39m	        };[31m
>> [39m	        Object.defineProperty(result, "length", {[31m
>> [39m	            get: function () {[31m
>> [39m	                return window.history.length;[31m
>> [39m	            },[31m
>> [39m	            enumerable: true,[31m
>> [39m	            configurable: true[31m
>> [39m	        });[31m
>> [39m	        Object.defineProperty(result, "state", {[31m
>> [39m	            get: function () {[31m
>> [39m	                return window.history.state;[31m
>> [39m	            },[31m
>> [39m	            enumerable: true,[31m
>> [39m	            configurable: true[31m
>> [39m	        });[31m
>> [39m	        Object.defineProperty(result, "location", {[31m
>> [39m	            get: function () {[31m
>> [39m	                return window.location;[31m
>> [39m	            },[31m
>> [39m	            enumerable: true,[31m
>> [39m	            configurable: true[31m
>> [39m	        });[31m
>> [39m	        // enrich with observable[31m
>> [39m	        result.onPopState = Rx.Observable.fromEventPattern(function (h) { return window.addEventListener("popstate", h); }, function (h) { return window.removeEventListener("popstate", h); })[31m
>> [39m	            .publish()[31m
>> [39m	            .refCount();[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    App.prototype.register = function () {[31m
>> [39m	        Injector_1.injector.register(res.app, this) // register with injector[31m
>> [39m	            .register(res.expressionCompiler, ExpressionCompiler)[31m
>> [39m	            .register(res.templateEngine, [HtmlTemplateEngine_1.default], true)[31m
>> [39m	            .register(res.domManager, [res.expressionCompiler, DomManager_1.DomManager], true)[31m
>> [39m	            .register(res.router, [res.domManager, res.app, Router_1.Router], true)[31m
>> [39m	            .register(res.messageBus, [MessageBus_1.default], true);[31m
>> [39m	        Injector_1.injector.register("bindings.module", [res.domManager, Module_2.default], true)[31m
>> [39m	            .register("bindings.command", [res.domManager, Command_1.default], true)[31m
>> [39m	            .register("bindings.if", [res.domManager, If_1.IfBinding], true)[31m
>> [39m	            .register("bindings.with", [res.domManager, With_1.default], true)[31m
>> [39m	            .register("bindings.notif", [res.domManager, If_1.NotIfBinding], true)[31m
>> [39m	            .register("bindings.css", [res.domManager, MultiOneWay_1.CssBinding], true)[31m
>> [39m	            .register("bindings.attr", [res.domManager, MultiOneWay_1.AttrBinding], true)[31m
>> [39m	            .register("bindings.style", [res.domManager, MultiOneWay_1.StyleBinding], true)[31m
>> [39m	            .register("bindings.text", [res.domManager, SimpleOneWay_1.TextBinding], true)[31m
>> [39m	            .register("bindings.html", [res.domManager, SimpleOneWay_1.HtmlBinding], true)[31m
>> [39m	            .register("bindings.visible", [res.domManager, SimpleOneWay_1.VisibleBinding], true)[31m
>> [39m	            .register("bindings.hidden", [res.domManager, SimpleOneWay_1.HiddenBinding], true)[31m
>> [39m	            .register("bindings.enabled", [res.domManager, SimpleOneWay_1.EnableBinding], true)[31m
>> [39m	            .register("bindings.disabled", [res.domManager, SimpleOneWay_1.DisableBinding], true)[31m
>> [39m	            .register("bindings.foreach", [res.domManager, ForEach_1.default], true)[31m
>> [39m	            .register("bindings.event", [res.domManager, Event_1.default], true)[31m
>> [39m	            .register("bindings.keyPress", [res.domManager, KeyPress_1.default], true)[31m
>> [39m	            .register("bindings.textInput", [res.domManager, TextInput_1.default], true)[31m
>> [39m	            .register("bindings.checked", [res.domManager, Checked_1.default], true)[31m
>> [39m	            .register("bindings.selectedValue", [res.domManager, SelectedValue_1.default], true)[31m
>> [39m	            .register("bindings.component", [res.domManager, Component_1.default], true)[31m
>> [39m	            .register("bindings.value", [res.domManager, Value_1.default], true)[31m
>> [39m	            .register("bindings.hasFocus", [res.domManager, HasFocus_1.default], true)[31m
>> [39m	            .register("bindings.view", [res.domManager, res.router, View_1.default], true)[31m
>> [39m	            .register("bindings.sref", [res.domManager, res.router, StateRef_1.default], true)[31m
>> [39m	            .register("bindings.sactive", [res.domManager, res.router, StateActive_1.default], true);[31m
>> [39m	        Injector_1.injector.register("components.radiogroup", [res.templateEngine, RadioGroup_1.default])[31m
>> [39m	            .register("components.select", [res.templateEngine, Select_1.default]);[31m
>> [39m	        // initialize module[31m
>> [39m	        this.binding("module", "bindings.module")[31m
>> [39m	            .binding("css", "bindings.css")[31m
>> [39m	            .binding("attr", "bindings.attr")[31m
>> [39m	            .binding("style", "bindings.style")[31m
>> [39m	            .binding("command", "bindings.command")[31m
>> [39m	            .binding("if", "bindings.if")[31m
>> [39m	            .binding("with", "bindings.with")[31m
>> [39m	            .binding("ifnot", "bindings.notif")[31m
>> [39m	            .binding("text", "bindings.text")[31m
>> [39m	            .binding("html", "bindings.html")[31m
>> [39m	            .binding("visible", "bindings.visible")[31m
>> [39m	            .binding("hidden", "bindings.hidden")[31m
>> [39m	            .binding("disabled", "bindings.disabled")[31m
>> [39m	            .binding("enabled", "bindings.enabled")[31m
>> [39m	            .binding("foreach", "bindings.foreach")[31m
>> [39m	            .binding("event", "bindings.event")[31m
>> [39m	            .binding(["keyPress", "keypress"], "bindings.keyPress")[31m
>> [39m	            .binding(["textInput", "textinput"], "bindings.textInput")[31m
>> [39m	            .binding("checked", "bindings.checked")[31m
>> [39m	            .binding("selectedValue", "bindings.selectedValue")[31m
>> [39m	            .binding("component", "bindings.component")[31m
>> [39m	            .binding("value", "bindings.value")[31m
>> [39m	            .binding(["hasFocus", "hasfocus"], "bindings.hasFocus")[31m
>> [39m	            .binding("view", "bindings.view")[31m
>> [39m	            .binding(["sref", "stateRef", "stateref"], "bindings.sref")[31m
>> [39m	            .binding(["sactive", "stateActive", "stateactive"], "bindings.sactive");[31m
>> [39m	        this.component("wx-radiogroup", { resolve: "components.radiogroup" })[31m
>> [39m	            .component("wx-select", { resolve: "components.select" });[31m
>> [39m	        // register with module-registry[31m
>> [39m	        Module_1.modules["app"] = { instance: this };[31m
>> [39m	    };[31m
>> [39m	    return App;[31m
>> [39m	})(Module_1.Module);[31m
>> [39m	var _app = new App();[31m
>> [39m	exports.app = _app;[31m
>> [39m	_app.register();[31m
>> [39m	//# sourceMappingURL=App.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 1 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var res = __webpack_require__(10);[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* Simple IoC & Service Locator[31m
>> [39m	[1m/[31m
>> [39m	var Injector = (function () {[31m
>> [39m	    function Injector() {[31m
>> [39m	        //////////////////////////////////[31m
>> [39m	        // Implementation[31m
>> [39m	        this.registrations = {};[31m
>> [39m	    }[31m
>> [39m	    Injector.prototype.register = function () {[31m
>> [39m	        var key = arguments[0];[31m
>> [39m	        var val = arguments[1];[31m
>> [39m	        var isSingleton = arguments[2];[31m
>> [39m	        var factory;[31m
>> [39m	        if (this.registrations.hasOwnProperty(key))[31m
>> [39m	            Utils_1.throwError("'{0}' is already registered", key);[31m
>> [39m	        if (Utils_1.isFunction(val)) {[31m
>> [39m	            // second overload[31m
>> [39m	            // it's a factory function[31m
>> [39m	            factory = function (args, deps) { return val.apply(null, args); };[31m
>> [39m	        }[31m
>> [39m	        else if (Array.isArray(val)) {[31m
>> [39m	            // first overload[31m
>> [39m	            // array assumed to be inline array notation with constructor[31m
>> [39m	            var self_1 = this;[31m
>> [39m	            var ctor = val.pop();[31m
>> [39m	            var dependencies = val;[31m
>> [39m	            factory = function (args, deps) {[31m
>> [39m	                // resolve dependencies[31m
>> [39m	                var resolved = dependencies.map(function (x) {[31m
>> [39m	                    try {[31m
>> [39m	                        return self_1.get(x, undefined, deps);[31m
>> [39m	                    }[31m
>> [39m	                    catch (e) {[31m
>> [39m	                        Utils_1.throwError("Error resolving dependency '{0}' for '{1}': {2}", x, key, e);[31m
>> [39m	                    }[31m
>> [39m	                });[31m
>> [39m	                // invoke constructor[31m
>> [39m	                var _args = [null].concat(resolved).concat(args);[31m
>> [39m	                var ctorFunc = ctor.bind.apply(ctor, _args);[31m
>> [39m	                return new ctorFunc();[31m
>> [39m	            };[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // third overload[31m
>> [39m	            // singleton[31m
>> [39m	            factory = function (args, deps) { return val; };[31m
>> [39m	        }[31m
>> [39m	        this.registrations[key] = { factory: factory, isSingleton: isSingleton };[31m
>> [39m	        return this;[31m
>> [39m	    };[31m
>> [39m	    Injector.prototype.get = function (key, args, deps) {[31m
>> [39m	        deps = deps || {};[31m
>> [39m	        if (deps.hasOwnProperty(key))[31m
>> [39m	            Utils_1.throwError("Detected circular dependency a from '{0}' to '{1}'", Object.keys(deps).join(", "), key);[31m
>> [39m	        // registered?[31m
>> [39m	        var registration = this.registrations[key];[31m
>> [39m	        if (registration === undefined)[31m
>> [39m	            Utils_1.throwError("'{0}' is not registered", key);[31m
>> [39m	        // already instantiated?[31m
>> [39m	        if (registration.isSingleton && registration.value)[31m
>> [39m	            return registration.value;[31m
>> [39m	        // append current key[31m
>> [39m	        var newDeps = {};[31m
>> [39m	        newDeps[key] = true;[31m
>> [39m	        Utils_1.extend(deps, newDeps);[31m
>> [39m	        // create it[31m
>> [39m	        var result = registration.factory(args, newDeps);[31m
>> [39m	        // cache if singleton[31m
>> [39m	        if (registration.isSingleton)[31m
>> [39m	            registration.value = result;[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    Injector.prototype.resolve = function (iaa, args) {[31m
>> [39m	        var ctor = iaa.pop();[31m
>> [39m	        if (!Utils_1.isFunction(ctor))[31m
>> [39m	            Utils_1.throwError("Error resolving inline-annotated-array. Constructor must be of type 'function' but is '{0}", typeof ctor);[31m
>> [39m	        var self = this;[31m
>> [39m	        // resolve dependencies[31m
>> [39m	        var resolved = iaa.map(function (x) {[31m
>> [39m	            try {[31m
>> [39m	                return self.get(x, undefined, iaa);[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                Utils_1.throwError("Error resolving dependency '{0}' for '{1}': {2}", x, Object.getPrototypeOf(ctor), e);[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	        // invoke constructor[31m
>> [39m	        var _args = [null].concat(resolved).concat(args);[31m
>> [39m	        var ctorFunc = ctor.bind.apply(ctor, _args);[31m
>> [39m	        return new ctorFunc();[31m
>> [39m	    };[31m
>> [39m	    return Injector;[31m
>> [39m	})();[31m
>> [39m	exports.injector = new Injector();[31m
>> [39m	exports.injector.register(res.injector, function () { return new Injector(); });[31m
>> [39m	//# sourceMappingURL=Injector.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 2 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Reflect_1 = __webpack_require__(3);[31m
>> [39m	var Events_1 = __webpack_require__(8);[31m
>> [39m	var IID_1 = __webpack_require__(9);[31m
>> [39m	/[22m[31m
>> [39m	* Global helpers[31m
>> [39m	[1m/[31m
>> [39m	"use strict";[31m
>> [39m	var regexCssClassName = /\S+/g;[31m
>> [39m	var RxObsConstructor = Rx.Observable; // the cast is neccessary because the rx.js.d.ts declares Observable as an interface[31m
>> [39m	exports.noop = function () { };[31m
>> [39m	/*[22m[31m
>> [39m	* Returns true if a ECMAScript5 strict-mode is active[31m
>> [39m	[1m/[31m
>> [39m	function isStrictMode() {[31m
>> [39m	    return typeof this === "undefined";[31m
>> [39m	}[31m
>> [39m	exports.isStrictMode = isStrictMode;[31m
>> [39m	/*[22m[31m
>> [39m	* Returns true if target is a javascript primitive[31m
>> [39m	[1m/[31m
>> [39m	function isPrimitive(target) {[31m
>> [39m	    var t = typeof target;[31m
>> [39m	    return t === "boolean" || t === "number" || t === "string";[31m
>> [39m	}[31m
>> [39m	exports.isPrimitive = isPrimitive;[31m
>> [39m	/*[22m[31m
>> [39m	* Tests if the target supports the interface[31m
>> [39m	* @param {any} target[31m
>> [39m	* @param {string} iid[31m
>> [39m	[1m/[31m
>> [39m	function queryInterface(target, iid) {[31m
>> [39m	    if (target == null || isPrimitive(target))[31m
>> [39m	        return false;[31m
>> [39m	    if (typeof target === "object")[31m
>> [39m	        target = target.constructor;[31m
>> [39m	    var interfaces = Reflect_1.getMetadata(Reflect_1.implementsMetaDataKey, target);[31m
>> [39m	    return interfaces != null && interfaces[iid];[31m
>> [39m	}[31m
>> [39m	exports.queryInterface = queryInterface;[31m
>> [39m	/*[22m[31m
>> [39m	* Returns all own properties of target implementing interface iid[31m
>> [39m	* @param {any} target[31m
>> [39m	* @param {string} iid[31m
>> [39m	[1m/[31m
>> [39m	function getOwnPropertiesImplementingInterface(target, iid) {[31m
>> [39m	    return Object.keys(target).filter(function (propertyName) {[31m
>> [39m	        // lookup object for name[31m
>> [39m	        var o = target[propertyName];[31m
>> [39m	        // is it an ObservableProperty?[31m
>> [39m	        return queryInterface(o, iid);[31m
>> [39m	    }).map(function (x) { return new PropertyInfo(x, target[x]); });[31m
>> [39m	}[31m
>> [39m	exports.getOwnPropertiesImplementingInterface = getOwnPropertiesImplementingInterface;[31m
>> [39m	/*[22m[31m
>> [39m	* Determines if target is an instance of a IObservableProperty[31m
>> [39m	* @param {any} target[31m
>> [39m	[1m/[31m
>> [39m	function isProperty(target) {[31m
>> [39m	    if (target == null)[31m
>> [39m	        return false;[31m
>> [39m	    return queryInterface(target, IID_1.default.IObservableProperty);[31m
>> [39m	}[31m
>> [39m	exports.isProperty = isProperty;[31m
>> [39m	/*[22m[31m
>> [39m	* Determines if target is an instance of a Rx.Scheduler[31m
>> [39m	* @param {any} target[31m
>> [39m	[1m/[31m
>> [39m	function isRxScheduler(target) {[31m
>> [39m	    if (target == null)[31m
>> [39m	        return false;[31m
>> [39m	    return Rx.Scheduler.isScheduler(target);[31m
>> [39m	}[31m
>> [39m	exports.isRxScheduler = isRxScheduler;[31m
>> [39m	/*[22m[31m
>> [39m	* Determines if target is an instance of a Rx.Observable[31m
>> [39m	* @param {any} target[31m
>> [39m	[1m/[31m
>> [39m	function isRxObservable(target) {[31m
>> [39m	    if (target == null)[31m
>> [39m	        return false;[31m
>> [39m	    return target instanceof RxObsConstructor;[31m
>> [39m	}[31m
>> [39m	exports.isRxObservable = isRxObservable;[31m
>> [39m	/*[22m[31m
>> [39m	* If the prop is an observable property return its value[31m
>> [39m	* @param {any} prop[31m
>> [39m	[1m/[31m
>> [39m	function unwrapProperty(prop) {[31m
>> [39m	    if (isProperty(prop))[31m
>> [39m	        return prop();[31m
>> [39m	    return prop;[31m
>> [39m	}[31m
>> [39m	exports.unwrapProperty = unwrapProperty;[31m
>> [39m	/*[22m[31m
>> [39m	* Returns true if a Unit-Testing environment is detected[31m
>> [39m	[1m/[31m
>> [39m	function isInUnitTest() {[31m
>> [39m	    // detect jasmine 1.x[31m
>> [39m	    if (window && window["jasmine"] && window["jasmine"].version[24m !== undefined) {[31m
>> [39m	        return true;[31m
>> [39m	    }[31m
>> [39m	    // detect jasmine 2.x[31m
>> [39m	    if (window && window["getJasmineRequireObj"] && typeof window["getJasmineRequireObj"] === "function") {[31m
>> [39m	        return true;[31m
>> [39m	    }[31m
>> [39m	    return false;[31m
>> [39m	}[31m
>> [39m	exports.isInUnitTest = isInUnitTest;[31m
>> [39m	/*[22m[31m
>> [39m	* Transforms the current method's arguments into an array[31m
>> [39m	[1m/[31m
>> [39m	function args2Array(args) {[31m
>> [39m	    var result = [];[31m
>> [39m	    for (var i = 0, len = args.length; i < len; i++) {[31m
>> [39m	        result.push(args[i]);[31m
>> [39m	    }[31m
>> [39m	    return result;[31m
>> [39m	}[31m
>> [39m	exports.args2Array = args2Array;[31m
>> [39m	/*[22m[31m
>> [39m	* Formats a string using .net style format string[31m
>> [39m	* @param {string} fmt The format string[31m
>> [39m	* @param {any[]} ...args Format arguments[31m
>> [39m	[1m/[31m
>> [39m	function formatString(fmt) {[31m
>> [39m	    var args = [];[31m
>> [39m	    for (var [4mi = 1; _i < arguments.length; _i++) {[31m
>> [39m	        args[_i - 1] = arguments[_i];[31m
>> [39m	    }[31m
>> [39m	    var pattern = /\{\d+\}/g;[31m
>> [39m	    return fmt.replace(pattern, function (capture) {[31m
>> [39m	        return args[capture.match(/\d+/)];[31m
>> [39m	    });[31m
>> [39m	}[31m
>> [39m	exports.formatString = formatString;[31m
>> [39m	/*[22m[31m
>> [39m	* Copies own properties from src to dst[31m
>> [39m	[1m/[31m
>> [39m	function extend(src, dst, inherited) {[31m
>> [39m	    var prop;[31m
>> [39m	    if (!inherited) {[31m
>> [39m	        var ownProps = Object.getOwnPropertyNames(src);[31m
>> [39m	        for (var i = 0; i < ownProps.length; i++) {[31m
>> [39m	            prop = ownProps[i];[31m
>> [39m	            dst[prop] = src[prop];[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    else {[31m
>> [39m	        for (prop in src) {[31m
>> [39m	            dst[prop] = src[prop];[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    return dst;[31m
>> [39m	}[31m
>> [39m	exports.extend = extend;[31m
>> [39m	var PropertyInfo = (function () {[31m
>> [39m	    function PropertyInfo(propertyName, property) {[31m
>> [39m	        this.property = property;[31m
>> [39m	        this.propertyName = propertyName;[31m
>> [39m	    }[31m
>> [39m	    return PropertyInfo;[31m
>> [39m	})();[31m
>> [39m	exports.PropertyInfo = PropertyInfo;[31m
>> [39m	/*[22m[31m
>> [39m	* Toggles one ore more css classes on the specified DOM element[31m
>> [39m	* @param {Node} node The target element[31m
>> [39m	* @param {boolean} shouldHaveClass True if the classes should be added to the element, false if they should be removed[31m
>> [39m	* @param {string[} classNames The list of classes to process[31m
>> [39m	[1m/[31m
>> [39m	function toggleCssClass(node, shouldHaveClass) {[31m
>> [39m	    var classNames = [];[31m
>> [39m	    for (var _i = 2; _i < arguments.length; _i++) {[31m
>> [39m	        classNames[_i - 2] = arguments[_i];[31m
>> [39m	    }[31m
>> [39m	    if (classNames) {[31m
>> [39m	        var currentClassNames = node.className.match(regexCssClassName) || [];[31m
>> [39m	        var index;[31m
>> [39m	        var className;[31m
>> [39m	        if (shouldHaveClass) {[31m
>> [39m	            for (var i = 0; i < classNames.length; i++) {[31m
>> [39m	                className = classNames[i];[31m
>> [39m	                index = currentClassNames.indexOf(className);[31m
>> [39m	                if (index === -1)[31m
>> [39m	                    currentClassNames.push(className);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            for (var i = 0; i < classNames.length; i++) {[31m
>> [39m	                className = classNames[i];[31m
>> [39m	                index = currentClassNames.indexOf(className);[31m
>> [39m	                if (index !== -1)[31m
>> [39m	                    currentClassNames.splice(index, 1);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        node.className = currentClassNames.join(" ");[31m
>> [39m	    }[31m
>> [39m	}[31m
>> [39m	exports.toggleCssClass = toggleCssClass;[31m
>> [39m	/*[22m[31m
>> [39m	 * Trigger a reflow on the target element[31m
>> [39m	 * @param {HTMLElement} el[31m
>> [39m	 [1m/[31m
>> [39m	function triggerReflow(el) {[31m
>> [39m	    el.getBoundingClientRect();[31m
>> [39m	}[31m
>> [39m	exports.triggerReflow = triggerReflow;[31m
>> [39m	/*[22m[31m
>> [39m	 * Returns true if the specified element may be disabled[31m
>> [39m	 * @param {HTMLElement} el[31m
>> [39m	 [1m/[31m
>> [39m	function elementCanBeDisabled(el) {[31m
>> [39m	    return el instanceof HTMLButtonElement ||[31m
>> [39m	        el instanceof HTMLAnchorElement ||[31m
>> [39m	        el instanceof HTMLInputElement ||[31m
>> [39m	        el instanceof HTMLFieldSetElement ||[31m
>> [39m	        el instanceof HTMLLinkElement ||[31m
>> [39m	        el instanceof HTMLOptGroupElement ||[31m
>> [39m	        el instanceof HTMLOptionElement ||[31m
>> [39m	        el instanceof HTMLSelectElement ||[31m
>> [39m	        el instanceof HTMLTextAreaElement;[31m
>> [39m	}[31m
>> [39m	exports.elementCanBeDisabled = elementCanBeDisabled;[31m
>> [39m	/*[22m[31m
>> [39m	 * Returns true if object is a Function.[31m
>> [39m	 * @param obj[31m
>> [39m	 [1m/[31m
>> [39m	function isFunction(obj) {[31m
>> [39m	    return typeof obj == 'function' || false;[31m
>> [39m	}[31m
>> [39m	exports.isFunction = isFunction;[31m
>> [39m	/*[22m[31m
>> [39m	 * Returns true if object is a Disposable[31m
>> [39m	 * @param obj[31m
>> [39m	 [1m/[31m
>> [39m	function isDisposable(obj) {[31m
>> [39m	    return queryInterface(obj, IID_1.default.IDisposable) || isFunction(obj["dispose"]);[31m
>> [39m	}[31m
>> [39m	exports.isDisposable = isDisposable;[31m
>> [39m	/*[22m[31m
>> [39m	 * Performs an optimized deep comparison between the two objects, to determine if they should be considered equal.[31m
>> [39m	 * @param a Object to compare[31m
>> [39m	 * @param b Object to compare to[31m
>> [39m	 [1m/[31m
>> [39m	function isEqual(a, b, aStack, bStack) {[31m
>> [39m	    var toString = ({}).toString;[31m
>> [39m	    // Identical objects are equal. `0 === -0`, but they aren't identical.[31m
>> [39m	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).[31m
>> [39m	    if (a === b)[31m
>> [39m	        return a !== 0 || 1 / a === 1 / b;[31m
>> [39m	    // A strict comparison is necessary because `null == undefined`.[31m
>> [39m	    if (a == null || b == null)[31m
>> [39m	        return a === b;[31m
>> [39m	    // Unwrap any wrapped objects.[31m
>> [39m	    //if (a instanceof _) a = a._wrapped;[31m
>> [39m	    //if (b instanceof _) b = b._wrapped;[31m
>> [39m	    // Compare `[[Class]]` names.[31m
>> [39m	    var className = toString.call(a);[31m
>> [39m	    if (className !== toString.call(b))[31m
>> [39m	        return false;[31m
>> [39m	    switch (className) {[31m
>> [39m	        // Strings, numbers, regular expressions, dates, and booleans are compared by value.[31m
>> [39m	        case '[object RegExp]':[31m
>> [39m	        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')[31m
>> [39m	        case '[object String]':[31m
>> [39m	            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is[31m
>> [39m	            // equivalent to `new String("5")`.[31m
>> [39m	            return '' + a === '' + b;[31m
>> [39m	        case '[object Number]':[31m
>> [39m	            // `NaN`s are equivalent, but non-reflexive.[31m
>> [39m	            // Object(NaN) is equivalent to NaN[31m
>> [39m	            if (+a !== +a)[31m
>> [39m	                return +b !== +b;[31m
>> [39m	            // An `egal` comparison is performed for other numeric values.[31m
>> [39m	            return +a === 0 ? 1 / +a === 1 / b : +a === +b;[31m
>> [39m	        case '[object Date]':[31m
>> [39m	        case '[object Boolean]':[31m
>> [39m	            // Coerce dates and booleans to numeric primitive values. Dates are compared by their[31m
>> [39m	            // millisecond representations. Note that invalid dates with millisecond representations[31m
>> [39m	            // of `NaN` are not equivalent.[31m
>> [39m	            return +a === +b;[31m
>> [39m	    }[31m
>> [39m	    var areArrays = className === '[object Array]';[31m
>> [39m	    if (!areArrays) {[31m
>> [39m	        if (typeof a != 'object' || typeof b != 'object')[31m
>> [39m	            return false;[31m
>> [39m	        // Objects with different constructors are not equivalent, but `Object`s or `Array`s[31m
>> [39m	        // from different frames are.[31m
>> [39m	        var aCtor = a.constructor, bCtor = b.constructor;[31m
>> [39m	        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&[31m
>> [39m	            isFunction(bCtor) && bCtor instanceof bCtor)[31m
>> [39m	            && ('constructor' in a && 'constructor' in b)) {[31m
>> [39m	            return false;[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    // Assume equality for cyclic structures. The algorithm for detecting cyclic[31m
>> [39m	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.[31m
>> [39m	    // Initializing stack of traversed objects.[31m
>> [39m	    // It's done here since we only need them for objects and arrays comparison.[31m
>> [39m	    aStack = aStack || [];[31m
>> [39m	    bStack = bStack || [];[31m
>> [39m	    var length = aStack.length;[31m
>> [39m	    while (length--) {[31m
>> [39m	        // Linear search. Performance is inversely proportional to the number of[31m
>> [39m	        // unique nested structures.[31m
>> [39m	        if (aStack[length] === a)[31m
>> [39m	            return bStack[length] === b;[31m
>> [39m	    }[31m
>> [39m	    // Add the first object to the stack of traversed objects.[31m
>> [39m	    aStack.push(a);[31m
>> [39m	    bStack.push(b);[31m
>> [39m	    // Recursively compare objects and arrays.[31m
>> [39m	    if (areArrays) {[31m
>> [39m	        // Compare array lengths to determine if a deep comparison is necessary.[31m
>> [39m	        length = a.length;[31m
>> [39m	        if (length !== b.length)[31m
>> [39m	            return false;[31m
>> [39m	        // Deep compare the contents, ignoring non-numeric properties.[31m
>> [39m	        while (length--) {[31m
>> [39m	            if (!isEqual(a[length], b[length], aStack, bStack))[31m
>> [39m	                return false;[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    else {[31m
>> [39m	        // Deep compare objects.[31m
>> [39m	        var keys = Object.keys(a), key;[31m
>> [39m	        length = keys.length;[31m
>> [39m	        // Ensure that both objects contain the same number of properties before comparing deep equality.[31m
>> [39m	        if (Object.keys(b).length !== length)[31m
>> [39m	            return false;[31m
>> [39m	        while (length--) {[31m
>> [39m	            // Deep compare each member[31m
>> [39m	            key = keys[length];[31m
>> [39m	            if (!(b.hasOwnProperty(key) && isEqual(a[key], b[key], aStack, bStack)))[31m
>> [39m	                return false;[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    // Remove the first object from the stack of traversed objects.[31m
>> [39m	    aStack.pop();[31m
>> [39m	    bStack.pop();[31m
>> [39m	    return true;[31m
>> [39m	}[31m
>> [39m	exports.isEqual = isEqual;[31m
>> [39m	/*[22m[31m
>> [39m	* Returns an array of clones of the nodes in the source array[31m
>> [39m	[1m/[31m
>> [39m	function cloneNodeArray(nodes) {[31m
>> [39m	    var length = nodes.length;[31m
>> [39m	    var result = new Array(length);[31m
>> [39m	    for (var i = 0; i < length; i++) {[31m
>> [39m	        result[i] = nodes[i].cloneNode(true);[31m
>> [39m	    }[31m
>> [39m	    return result;[31m
>> [39m	}[31m
>> [39m	exports.cloneNodeArray = cloneNodeArray;[31m
>> [39m	/*[22m[31m
>> [39m	 * Converts a NodeList into a javascript array[31m
>> [39m	 * @param {NodeList} nodes[31m
>> [39m	 [1m/[31m
>> [39m	function nodeListToArray(nodes) {[31m
>> [39m	    return Array.prototype.slice.call(nodes);[31m
>> [39m	}[31m
>> [39m	exports.nodeListToArray = nodeListToArray;[31m
>> [39m	/*[22m[31m
>> [39m	 * Converts the node's children into a javascript array[31m
>> [39m	 * @param {Node} node[31m
>> [39m	 [1m/[31m
>> [39m	function nodeChildrenToArray(node) {[31m
>> [39m	    return nodeListToArray(node.childNodes);[31m
>> [39m	}[31m
>> [39m	exports.nodeChildrenToArray = nodeChildrenToArray;[31m
>> [39m	/*[22m[31m
>> [39m	* Wraps an action in try/finally block and disposes the resource after the action has completed even if it throws an exception[31m
>> [39m	* (mimics C# using statement)[31m
>> [39m	* @param {Rx.IDisposable} disp The resource to dispose after action completes[31m
>> [39m	* @param {() => void} action The action to wrap[31m
>> [39m	[1m/[31m
>> [39m	function using(disp, action) {[31m
>> [39m	    if (!disp)[31m
>> [39m	        throw new Error("disp");[31m
>> [39m	    if (!action)[31m
>> [39m	        throw new Error("action");[31m
>> [39m	    try {[31m
>> [39m	        action(disp);[31m
>> [39m	    }[31m
>> [39m	    finally {[31m
>> [39m	        disp.dispose();[31m
>> [39m	    }[31m
>> [39m	}[31m
>> [39m	exports.using = using;[31m
>> [39m	/*[22m[31m
>> [39m	* Turns an AMD-Style require call into an observable[31m
>> [39m	* @param {string} Module The module to load[31m
>> [39m	* @return {Rx.Observable<any>} An observable that yields a value and completes as soon as the module has been loaded[31m
>> [39m	[1m/[31m
>> [39m	function observableRequire(module) {[31m
>> [39m	    var requireFunc = window["require"];[31m
>> [39m	    if (!isFunction(requireFunc))[31m
>> [39m	        throwError("there's no AMD-module loader available (Hint: did you forget to include RequireJS in your project?)");[31m
>> [39m	    return Rx.Observable.create(function (observer) {[31m
>> [39m	        try {[31m
>> [39m	            requireFunc([module], function (m) {[31m
>> [39m	                observer.onNext(m);[31m
>> [39m	                observer.onCompleted();[31m
>> [39m	            }, function (err) {[31m
>> [39m	                observer.onError(err);[31m
>> [39m	            });[31m
>> [39m	        }[31m
>> [39m	        catch (e) {[31m
>> [39m	            observer.onError(e);[31m
>> [39m	        }[31m
>> [39m	        return Rx.Disposable.empty;[31m
>> [39m	    });[31m
>> [39m	}[31m
>> [39m	exports.observableRequire = observableRequire;[31m
>> [39m	/*[22m[31m
>> [39m	* Returns an observable that notifes of any observable property changes on the target[31m
>> [39m	* @param {any} target The object to observe[31m
>> [39m	* @return {Rx.Observable<T>} An observable[31m
>> [39m	[1m/[31m
>> [39m	function observeObject(target, defaultExceptionHandler, onChanging) {[31m
>> [39m	    if (onChanging === void 0) { onChanging = false; }[31m
>> [39m	    var thrownExceptionsSubject = queryInterface(target, IID_1.default.IHandleObservableErrors) ?[31m
>> [39m	        target.thrownExceptions : defaultExceptionHandler;[31m
>> [39m	    return Rx.Observable.create(function (observer) {[31m
>> [39m	        var result = new Rx.CompositeDisposable();[31m
>> [39m	        var observableProperties = getOwnPropertiesImplementingInterface(target, IID_1.default.IObservableProperty);[31m
>> [39m	        observableProperties.forEach(function (x) {[31m
>> [39m	            var prop = x.property;[31m
>> [39m	            var obs = onChanging ? prop.changing : prop.changed;[31m
>> [39m	            result.add(obs.subscribe(function (_) {[31m
>> [39m	                var e = new Events_1.PropertyChangedEventArgs(self, x.propertyName);[31m
>> [39m	                try {[31m
>> [39m	                    observer.onNext(e);[31m
>> [39m	                }[31m
>> [39m	                catch (ex) {[31m
>> [39m	                    thrownExceptionsSubject.onNext(ex);[31m
>> [39m	                }[31m
>> [39m	            }));[31m
>> [39m	        });[31m
>> [39m	        return result;[31m
>> [39m	    })[31m
>> [39m	        .publish()[31m
>> [39m	        .refCount();[31m
>> [39m	}[31m
>> [39m	exports.observeObject = observeObject;[31m
>> [39m	/*[22m[31m
>> [39m	 * whenAny allows you to observe whenever the value of one or more properties[31m
>> [39m	 * on an object have changed, providing an initial value when the Observable is set up.[31m
>> [39m	 [1m/[31m
>> [39m	function whenAny() {[31m
>> [39m	    // no need to invoke combineLatest for the simplest case[31m
>> [39m	    if (arguments.length === 2) {[31m
>> [39m	        return arguments[0].changed.startWith(arguments[0]()).select(arguments[1]);[31m
>> [39m	    }[31m
>> [39m	    var args = args2Array(arguments);[31m
>> [39m	    // extract selector[31m
>> [39m	    var selector = args.pop();[31m
>> [39m	    // prepend sequence with current values to satisfy combineLatest[31m
>> [39m	    args = args.map(function (x) { return x.changed.startWith(x()); });[31m
>> [39m	    // finally append the selector[31m
>> [39m	    args.push(selector);[31m
>> [39m	    return Rx.Observable.combineLatest.apply(this, args);[31m
>> [39m	}[31m
>> [39m	exports.whenAny = whenAny;[31m
>> [39m	/*[22m[31m
>> [39m	* FOR INTERNAL USE ONLY[31m
>> [39m	* Throw an error containing the specified description[31m
>> [39m	[1m/[31m
>> [39m	function throwError(fmt) {[31m
>> [39m	    var args = [];[31m
>> [39m	    for (var _i = 1; _i < arguments.length; _i++) {[31m
>> [39m	        args[_i - 1] = arguments[_i];[31m
>> [39m	    }[31m
>> [39m	    var msg = "WebRx: " + formatString(fmt, args);[31m
>> [39m	    throw new Error(msg);[31m
>> [39m	}[31m
>> [39m	exports.throwError = throwError;[31m
>> [39m	//# sourceMappingURL=Utils.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 3 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var WeakMap_1 = __webpack_require__(4);[31m
>> [39m	var Set_1 = __webpack_require__(6);[31m
>> [39m	var Map_1 = __webpack_require__(7);[31m
>> [39m	/[22m! [1m***************************************************************************[22m[31m
>> [39m	Copyright (C) Microsoft. All rights reserved.[31m
>> [39m	Licensed under the Apache License, Version 2.0 (the "License"); you may not use[31m
>> [39m	this file except in compliance with the License. You may obtain a copy of the[31m
>> [39m	License at http://www.apache.org/licenses/LICENSE-2.0[31m
>> [39m	[31m
>> [39m	Unless required by applicable law or agreed to in writing, software[31m
>> [39m	distributed under the License is distributed on an "AS IS" BASIS,[31m
>> [39m	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[31m
>> [39m	[31m
>> [39m	See the License for the specific language governing permissions and[31m
>> [39m	limitations under the License.[31m
>> [39m	[1m***************************************************************************[22m [1m/[31m
>> [39m	"use strict";[31m
>> [39m	// Load global or shim versions of Map, Set, and WeakMap[31m
>> [39m	var functionPrototype = Object.getPrototypeOf(Function);[31m
>> [39m	// [[Metadata]] internal slot[31m
>> [39m	var __Metadata_[24m = WeakMap_1.createWeakMap();[31m
>> [39m	/*[22m[31m
>> [39m	  * Applies a set of decorators to a property of a target object.[31m
>> [39m	  * @param decorators An array of decorators.[31m
>> [39m	  * @param target The target object.[31m
>> [39m	  * @param targetKey (Optional) The property key to decorate.[31m
>> [39m	  * @param targetDescriptor (Optional) The property descriptor for the target key[31m
>> [39m	  * @remarks Decorators are applied in reverse order.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     class C {[31m
>> [39m	  *         // property declarations are not part of ES6, though they are valid in TypeScript:[31m
>> [39m	  *         // static staticProperty;[31m
>> [39m	  *         // property;[31m
>> [39m	  *[31m
>> [39m	  *         constructor(p) { }[31m
>> [39m	  *         static staticMethod(p) { }[31m
>> [39m	  *         method(p) { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     C = Reflect.decorate(decoratorsArray, C);[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor)[31m
>> [39m	  *     Reflect.decorate(decoratorsArray, C, "staticProperty");[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype)[31m
>> [39m	  *     Reflect.decorate(decoratorsArray, C.prototype, "property");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     Object.defineProperty(C, "staticMethod",[31m
>> [39m	  *         Reflect.decorate(decoratorsArray, C, "staticMethod",[31m
>> [39m	  *             Object.getOwnPropertyDescriptor(C, "staticMethod")));[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     Object.defineProperty(C.prototype, "method",[31m
>> [39m	  *         Reflect.decorate(decoratorsArray, C.prototype, "method",[31m
>> [39m	  *             Object.getOwnPropertyDescriptor(C.prototype, "method")));[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function decorate(decorators, target, targetKey, targetDescriptor) {[31m
>> [39m	    if (!IsUndefined(targetDescriptor)) {[31m
>> [39m	        if (!IsArray(decorators)) {[31m
>> [39m	            throw new TypeError();[31m
>> [39m	        }[31m
>> [39m	        else if (!IsObject(target)) {[31m
>> [39m	            throw new TypeError();[31m
>> [39m	        }[31m
>> [39m	        else if (IsUndefined(targetKey)) {[31m
>> [39m	            throw new TypeError();[31m
>> [39m	        }[31m
>> [39m	        else if (!IsObject(targetDescriptor)) {[31m
>> [39m	            throw new TypeError();[31m
>> [39m	        }[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	        return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);[31m
>> [39m	    }[31m
>> [39m	    else if (!IsUndefined(targetKey)) {[31m
>> [39m	        if (!IsArray(decorators)) {[31m
>> [39m	            throw new TypeError();[31m
>> [39m	        }[31m
>> [39m	        else if (!IsObject(target)) {[31m
>> [39m	            throw new TypeError();[31m
>> [39m	        }[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	        return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);[31m
>> [39m	    }[31m
>> [39m	    else {[31m
>> [39m	        if (!IsArray(decorators)) {[31m
>> [39m	            throw new TypeError();[31m
>> [39m	        }[31m
>> [39m	        else if (!IsConstructor(target)) {[31m
>> [39m	            throw new TypeError();[31m
>> [39m	        }[31m
>> [39m	        return DecorateConstructor(decorators, target);[31m
>> [39m	    }[31m
>> [39m	}[31m
>> [39m	exports.decorate = decorate;[31m
>> [39m	/*[22m[31m
>> [39m	  * A default metadata decorator factory that can be used on a class, class member, or parameter.[31m
>> [39m	  * @param metadataKey The key for the metadata entry.[31m
>> [39m	  * @param metadataValue The value for the metadata entry.[31m
>> [39m	  * @returns A decorator function.[31m
>> [39m	  * @remarks[31m
>> [39m	  * If `metadataKey` is already defined for the target and target key, the[31m
>> [39m	  * metadataValue for that key will be overwritten.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     @Reflect.metadata(key, value)[31m
>> [39m	  *     class C {[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor, TypeScript only)[31m
>> [39m	  *     class C {[31m
>> [39m	  *         @Reflect.metadata(key, value)[31m
>> [39m	  *         static staticProperty;[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype, TypeScript only)[31m
>> [39m	  *     class C {[31m
>> [39m	  *         @Reflect.metadata(key, value)[31m
>> [39m	  *         property;[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     class C {[31m
>> [39m	  *         @Reflect.metadata(key, value)[31m
>> [39m	  *         static staticMethod() { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     class C {[31m
>> [39m	  *         @Reflect.metadata(key, value)[31m
>> [39m	  *         method() { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function metadata(metadataKey, metadataValue) {[31m
>> [39m	    function decorator(target, targetKey) {[31m
>> [39m	        if (!IsUndefined(targetKey)) {[31m
>> [39m	            if (!IsObject(target)) {[31m
>> [39m	                throw new TypeError();[31m
>> [39m	            }[31m
>> [39m	            targetKey = ToPropertyKey(targetKey);[31m
>> [39m	            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            if (!IsConstructor(target)) {[31m
>> [39m	                throw new TypeError();[31m
>> [39m	            }[31m
>> [39m	            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, undefined);[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    return decorator;[31m
>> [39m	}[31m
>> [39m	exports.metadata = metadata;[31m
>> [39m	/*[22m[31m
>> [39m	  * Define a unique metadata entry on the target.[31m
>> [39m	  * @param metadataKey A key used to store and retrieve metadata.[31m
>> [39m	  * @param metadataValue A value that contains attached metadata.[31m
>> [39m	  * @param target The target object on which to define metadata.[31m
>> [39m	  * @param targetKey (Optional) The property key for the target.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     class C {[31m
>> [39m	  *         // property declarations are not part of ES6, though they are valid in TypeScript:[31m
>> [39m	  *         // static staticProperty;[31m
>> [39m	  *         // property;[31m
>> [39m	  *[31m
>> [39m	  *         constructor(p) { }[31m
>> [39m	  *         static staticMethod(p) { }[31m
>> [39m	  *         method(p) { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     Reflect.defineMetadata("custom:annotation", options, C);[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor)[31m
>> [39m	  *     Reflect.defineMetadata("custom:annotation", options, C, "staticProperty");[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype)[31m
>> [39m	  *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "property");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     Reflect.defineMetadata("custom:annotation", options, C, "staticMethod");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "method");[31m
>> [39m	  *[31m
>> [39m	  *     // decorator factory as metadata-producing annotation.[31m
>> [39m	  *     function MyAnnotation(options): Decorator {[31m
>> [39m	  *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function defineMetadata(metadataKey, metadataValue, target, targetKey) {[31m
>> [39m	    if (!IsObject(target)) {[31m
>> [39m	        throw new TypeError();[31m
>> [39m	    }[31m
>> [39m	    else if (!IsUndefined(targetKey)) {[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	    }[31m
>> [39m	    return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);[31m
>> [39m	}[31m
>> [39m	exports.defineMetadata = defineMetadata;[31m
>> [39m	/*[22m[31m
>> [39m	  * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.[31m
>> [39m	  * @param metadataKey A key used to store and retrieve metadata.[31m
>> [39m	  * @param target The target object on which the metadata is defined.[31m
>> [39m	  * @param targetKey (Optional) The property key for the target.[31m
>> [39m	  * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     class C {[31m
>> [39m	  *         // property declarations are not part of ES6, though they are valid in TypeScript:[31m
>> [39m	  *         // static staticProperty;[31m
>> [39m	  *         // property;[31m
>> [39m	  *[31m
>> [39m	  *         constructor(p) { }[31m
>> [39m	  *         static staticMethod(p) { }[31m
>> [39m	  *         method(p) { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     result = Reflect.hasMetadata("custom:annotation", C);[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor)[31m
>> [39m	  *     result = Reflect.hasMetadata("custom:annotation", C, "staticProperty");[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype)[31m
>> [39m	  *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "property");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     result = Reflect.hasMetadata("custom:annotation", C, "staticMethod");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "method");[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function hasMetadata(metadataKey, target, targetKey) {[31m
>> [39m	    if (!IsObject(target)) {[31m
>> [39m	        throw new TypeError();[31m
>> [39m	    }[31m
>> [39m	    else if (!IsUndefined(targetKey)) {[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	    }[31m
>> [39m	    return OrdinaryHasMetadata(metadataKey, target, targetKey);[31m
>> [39m	}[31m
>> [39m	exports.hasMetadata = hasMetadata;[31m
>> [39m	/*[22m[31m
>> [39m	  * Gets a value indicating whether the target object has the provided metadata key defined.[31m
>> [39m	  * @param metadataKey A key used to store and retrieve metadata.[31m
>> [39m	  * @param target The target object on which the metadata is defined.[31m
>> [39m	  * @param targetKey (Optional) The property key for the target.[31m
>> [39m	  * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     class C {[31m
>> [39m	  *         // property declarations are not part of ES6, though they are valid in TypeScript:[31m
>> [39m	  *         // static staticProperty;[31m
>> [39m	  *         // property;[31m
>> [39m	  *[31m
>> [39m	  *         constructor(p) { }[31m
>> [39m	  *         static staticMethod(p) { }[31m
>> [39m	  *         method(p) { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     result = Reflect.hasOwnMetadata("custom:annotation", C);[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor)[31m
>> [39m	  *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticProperty");[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype)[31m
>> [39m	  *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "property");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticMethod");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "method");[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function hasOwnMetadata(metadataKey, target, targetKey) {[31m
>> [39m	    if (!IsObject(target)) {[31m
>> [39m	        throw new TypeError();[31m
>> [39m	    }[31m
>> [39m	    else if (!IsUndefined(targetKey)) {[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	    }[31m
>> [39m	    return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);[31m
>> [39m	}[31m
>> [39m	exports.hasOwnMetadata = hasOwnMetadata;[31m
>> [39m	/*[22m[31m
>> [39m	  * Gets the metadata value for the provided metadata key on the target object or its prototype chain.[31m
>> [39m	  * @param metadataKey A key used to store and retrieve metadata.[31m
>> [39m	  * @param target The target object on which the metadata is defined.[31m
>> [39m	  * @param targetKey (Optional) The property key for the target.[31m
>> [39m	  * @returns The metadata value for the metadata key if found; otherwise, `undefined`.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     class C {[31m
>> [39m	  *         // property declarations are not part of ES6, though they are valid in TypeScript:[31m
>> [39m	  *         // static staticProperty;[31m
>> [39m	  *         // property;[31m
>> [39m	  *[31m
>> [39m	  *         constructor(p) { }[31m
>> [39m	  *         static staticMethod(p) { }[31m
>> [39m	  *         method(p) { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     result = Reflect.getMetadata("custom:annotation", C);[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor)[31m
>> [39m	  *     result = Reflect.getMetadata("custom:annotation", C, "staticProperty");[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype)[31m
>> [39m	  *     result = Reflect.getMetadata("custom:annotation", C.prototype, "property");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     result = Reflect.getMetadata("custom:annotation", C, "staticMethod");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     result = Reflect.getMetadata("custom:annotation", C.prototype, "method");[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function getMetadata(metadataKey, target, targetKey) {[31m
>> [39m	    if (!IsObject(target)) {[31m
>> [39m	        throw new TypeError();[31m
>> [39m	    }[31m
>> [39m	    else if (!IsUndefined(targetKey)) {[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	    }[31m
>> [39m	    return OrdinaryGetMetadata(metadataKey, target, targetKey);[31m
>> [39m	}[31m
>> [39m	exports.getMetadata = getMetadata;[31m
>> [39m	/*[22m[31m
>> [39m	  * Gets the metadata value for the provided metadata key on the target object.[31m
>> [39m	  * @param metadataKey A key used to store and retrieve metadata.[31m
>> [39m	  * @param target The target object on which the metadata is defined.[31m
>> [39m	  * @param targetKey (Optional) The property key for the target.[31m
>> [39m	  * @returns The metadata value for the metadata key if found; otherwise, `undefined`.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     class C {[31m
>> [39m	  *         // property declarations are not part of ES6, though they are valid in TypeScript:[31m
>> [39m	  *         // static staticProperty;[31m
>> [39m	  *         // property;[31m
>> [39m	  *[31m
>> [39m	  *         constructor(p) { }[31m
>> [39m	  *         static staticMethod(p) { }[31m
>> [39m	  *         method(p) { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     result = Reflect.getOwnMetadata("custom:annotation", C);[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor)[31m
>> [39m	  *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticProperty");[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype)[31m
>> [39m	  *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "property");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticMethod");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "method");[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function getOwnMetadata(metadataKey, target, targetKey) {[31m
>> [39m	    if (!IsObject(target)) {[31m
>> [39m	        throw new TypeError();[31m
>> [39m	    }[31m
>> [39m	    else if (!IsUndefined(targetKey)) {[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	    }[31m
>> [39m	    return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);[31m
>> [39m	}[31m
>> [39m	exports.getOwnMetadata = getOwnMetadata;[31m
>> [39m	/*[22m[31m
>> [39m	  * Gets the metadata keys defined on the target object or its prototype chain.[31m
>> [39m	  * @param target The target object on which the metadata is defined.[31m
>> [39m	  * @param targetKey (Optional) The property key for the target.[31m
>> [39m	  * @returns An array of unique metadata keys.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     class C {[31m
>> [39m	  *         // property declarations are not part of ES6, though they are valid in TypeScript:[31m
>> [39m	  *         // static staticProperty;[31m
>> [39m	  *         // property;[31m
>> [39m	  *[31m
>> [39m	  *         constructor(p) { }[31m
>> [39m	  *         static staticMethod(p) { }[31m
>> [39m	  *         method(p) { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     result = Reflect.getMetadataKeys(C);[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor)[31m
>> [39m	  *     result = Reflect.getMetadataKeys(C, "staticProperty");[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype)[31m
>> [39m	  *     result = Reflect.getMetadataKeys(C.prototype, "property");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     result = Reflect.getMetadataKeys(C, "staticMethod");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     result = Reflect.getMetadataKeys(C.prototype, "method");[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function getMetadataKeys(target, targetKey) {[31m
>> [39m	    if (!IsObject(target)) {[31m
>> [39m	        throw new TypeError();[31m
>> [39m	    }[31m
>> [39m	    else if (!IsUndefined(targetKey)) {[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	    }[31m
>> [39m	    return OrdinaryMetadataKeys(target, targetKey);[31m
>> [39m	}[31m
>> [39m	exports.getMetadataKeys = getMetadataKeys;[31m
>> [39m	/*[22m[31m
>> [39m	  * Gets the unique metadata keys defined on the target object.[31m
>> [39m	  * @param target The target object on which the metadata is defined.[31m
>> [39m	  * @param targetKey (Optional) The property key for the target.[31m
>> [39m	  * @returns An array of unique metadata keys.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     class C {[31m
>> [39m	  *         // property declarations are not part of ES6, though they are valid in TypeScript:[31m
>> [39m	  *         // static staticProperty;[31m
>> [39m	  *         // property;[31m
>> [39m	  *[31m
>> [39m	  *         constructor(p) { }[31m
>> [39m	  *         static staticMethod(p) { }[31m
>> [39m	  *         method(p) { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     result = Reflect.getOwnMetadataKeys(C);[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor)[31m
>> [39m	  *     result = Reflect.getOwnMetadataKeys(C, "staticProperty");[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype)[31m
>> [39m	  *     result = Reflect.getOwnMetadataKeys(C.prototype, "property");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     result = Reflect.getOwnMetadataKeys(C, "staticMethod");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     result = Reflect.getOwnMetadataKeys(C.prototype, "method");[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function getOwnMetadataKeys(target, targetKey) {[31m
>> [39m	    if (!IsObject(target)) {[31m
>> [39m	        throw new TypeError();[31m
>> [39m	    }[31m
>> [39m	    else if (!IsUndefined(targetKey)) {[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	    }[31m
>> [39m	    return OrdinaryOwnMetadataKeys(target, targetKey);[31m
>> [39m	}[31m
>> [39m	exports.getOwnMetadataKeys = getOwnMetadataKeys;[31m
>> [39m	/*[22m[31m
>> [39m	  * Deletes the metadata entry from the target object with the provided key.[31m
>> [39m	  * @param metadataKey A key used to store and retrieve metadata.[31m
>> [39m	  * @param target The target object on which the metadata is defined.[31m
>> [39m	  * @param targetKey (Optional) The property key for the target.[31m
>> [39m	  * @returns `true` if the metadata entry was found and deleted; otherwise, false.[31m
>> [39m	  * @example[31m
>> [39m	  *[31m
>> [39m	  *     class C {[31m
>> [39m	  *         // property declarations are not part of ES6, though they are valid in TypeScript:[31m
>> [39m	  *         // static staticProperty;[31m
>> [39m	  *         // property;[31m
>> [39m	  *[31m
>> [39m	  *         constructor(p) { }[31m
>> [39m	  *         static staticMethod(p) { }[31m
>> [39m	  *         method(p) { }[31m
>> [39m	  *     }[31m
>> [39m	  *[31m
>> [39m	  *     // constructor[31m
>> [39m	  *     result = Reflect.deleteMetadata("custom:annotation", C);[31m
>> [39m	  *[31m
>> [39m	  *     // property (on constructor)[31m
>> [39m	  *     result = Reflect.deleteMetadata("custom:annotation", C, "staticProperty");[31m
>> [39m	  *[31m
>> [39m	  *     // property (on prototype)[31m
>> [39m	  *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "property");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on constructor)[31m
>> [39m	  *     result = Reflect.deleteMetadata("custom:annotation", C, "staticMethod");[31m
>> [39m	  *[31m
>> [39m	  *     // method (on prototype)[31m
>> [39m	  *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "method");[31m
>> [39m	  *[31m
>> [39m	  [1m/[31m
>> [39m	function deleteMetadata(metadataKey, target, targetKey) {[31m
>> [39m	    if (!IsObject(target)) {[31m
>> [39m	        throw new TypeError();[31m
>> [39m	    }[31m
>> [39m	    else if (!IsUndefined(targetKey)) {[31m
>> [39m	        targetKey = ToPropertyKey(targetKey);[31m
>> [39m	    }[31m
>> [39m	    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#deletemetadata-metadatakey-p-[31m
>> [39m	    var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);[31m
>> [39m	    if (IsUndefined(metadataMap)) {[31m
>> [39m	        return false;[31m
>> [39m	    }[31m
>> [39m	    if (!metadataMap.delete(metadataKey)) {[31m
>> [39m	        return false;[31m
>> [39m	    }[31m
>> [39m	    if (metadataMap.size > 0) {[31m
>> [39m	        return true;[31m
>> [39m	    }[31m
>> [39m	    var targetMetadata = [4m_Metadata_[24m.get(target);[31m
>> [39m	    targetMetadata.delete(targetKey);[31m
>> [39m	    if (targetMetadata.size > 0) {[31m
>> [39m	        return true;[31m
>> [39m	    }[31m
>> [39m	    [4m_Metadata_[24m.delete(target);[31m
>> [39m	    return true;[31m
>> [39m	}[31m
>> [39m	exports.deleteMetadata = deleteMetadata;[31m
>> [39m	function DecorateConstructor(decorators, target) {[31m
>> [39m	    for (var i = decorators.length - 1; i >= 0; --i) {[31m
>> [39m	        var decorator = decorators[i];[31m
>> [39m	        var decorated = decorator(target);[31m
>> [39m	        if (!IsUndefined(decorated)) {[31m
>> [39m	            if (!IsConstructor(decorated)) {[31m
>> [39m	                throw new TypeError();[31m
>> [39m	            }[31m
>> [39m	            target = decorated;[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    return target;[31m
>> [39m	}[31m
>> [39m	function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {[31m
>> [39m	    for (var i = decorators.length - 1; i >= 0; --i) {[31m
>> [39m	        var decorator = decorators[i];[31m
>> [39m	        var decorated = decorator(target, propertyKey, descriptor);[31m
>> [39m	        if (!IsUndefined(decorated)) {[31m
>> [39m	            if (!IsObject(decorated)) {[31m
>> [39m	                throw new TypeError();[31m
>> [39m	            }[31m
>> [39m	            descriptor = decorated;[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    return descriptor;[31m
>> [39m	}[31m
>> [39m	function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {[31m
>> [39m	    for (var i = decorators.length - 1; i >= 0; --i) {[31m
>> [39m	        var decorator = decorators[i];[31m
>> [39m	        decorator(target, propertyKey);[31m
>> [39m	    }[31m
>> [39m	}[31m
>> [39m	// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#getorcreatemetadatamap--o-p-create-[31m
>> [39m	function GetOrCreateMetadataMap(target, targetKey, create) {[31m
>> [39m	    var targetMetadata = [4m_Metadata_[24m.get(target);[31m
>> [39m	    if (!targetMetadata) {[31m
>> [39m	        if (!create) {[31m
>> [39m	            return undefined;[31m
>> [39m	        }[31m
>> [39m	        targetMetadata = Map_1.createMap();[31m
>> [39m	        [4m_Metadata_[24m.set(target, targetMetadata);[31m
>> [39m	    }[31m
>> [39m	    var keyMetadata = targetMetadata.get(targetKey);[31m
>> [39m	    if (!keyMetadata) {[31m
>> [39m	        if (!create) {[31m
>> [39m	            return undefined;[31m
>> [39m	        }[31m
>> [39m	        keyMetadata = Map_1.createMap();[31m
>> [39m	        targetMetadata.set(targetKey, keyMetadata);[31m
>> [39m	    }[31m
>> [39m	    return keyMetadata;[31m
>> [39m	}[31m
>> [39m	// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasmetadata--metadatakey-o-p-[31m
>> [39m	function OrdinaryHasMetadata(MetadataKey, O, P) {[31m
>> [39m	    var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);[31m
>> [39m	    if (hasOwn) {[31m
>> [39m	        return true;[31m
>> [39m	    }[31m
>> [39m	    var parent = GetPrototypeOf(O);[31m
>> [39m	    if (parent !== null) {[31m
>> [39m	        return OrdinaryHasMetadata(MetadataKey, parent, P);[31m
>> [39m	    }[31m
>> [39m	    return false;[31m
>> [39m	}[31m
>> [39m	// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-[31m
>> [39m	function OrdinaryHasOwnMetadata(MetadataKey, O, P) {[31m
>> [39m	    var metadataMap = GetOrCreateMetadataMap(O, P, false);[31m
>> [39m	    if (metadataMap === undefined) {[31m
>> [39m	        return false;[31m
>> [39m	    }[31m
>> [39m	    return Boolean(metadataMap.has(MetadataKey));[31m
>> [39m	}[31m
>> [39m	// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetmetadata--metadatakey-o-p-[31m
>> [39m	function OrdinaryGetMetadata(MetadataKey, O, P) {[31m
>> [39m	    var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);[31m
>> [39m	    if (hasOwn) {[31m
>> [39m	        return OrdinaryGetOwnMetadata(MetadataKey, O, P);[31m
>> [39m	    }[31m
>> [39m	    var parent = GetPrototypeOf(O);[31m
>> [39m	    if (parent !== null) {[31m
>> [39m	        return OrdinaryGetMetadata(MetadataKey, parent, P);[31m
>> [39m	    }[31m
>> [39m	    return undefined;[31m
>> [39m	}[31m
>> [39m	// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetownmetadata--metadatakey-o-p-[31m
>> [39m	function OrdinaryGetOwnMetadata(MetadataKey, O, P) {[31m
>> [39m	    var metadataMap = GetOrCreateMetadataMap(O, P, false);[31m
>> [39m	    if (metadataMap === undefined) {[31m
>> [39m	        return undefined;[31m
>> [39m	    }[31m
>> [39m	    return metadataMap.get(MetadataKey);[31m
>> [39m	}[31m
>> [39m	// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-[31m
>> [39m	function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {[31m
>> [39m	    var metadataMap = GetOrCreateMetadataMap(O, P, true);[31m
>> [39m	    metadataMap.set(MetadataKey, MetadataValue);[31m
>> [39m	}[31m
>> [39m	// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarymetadatakeys--o-p-[31m
>> [39m	function OrdinaryMetadataKeys(O, P) {[31m
>> [39m	    var ownKeys = OrdinaryOwnMetadataKeys(O, P);[31m
>> [39m	    var parent = GetPrototypeOf(O);[31m
>> [39m	    if (parent === null) {[31m
>> [39m	        return ownKeys;[31m
>> [39m	    }[31m
>> [39m	    var parentKeys = OrdinaryMetadataKeys(parent, P);[31m
>> [39m	    if (parentKeys.length <= 0) {[31m
>> [39m	        return ownKeys;[31m
>> [39m	    }[31m
>> [39m	    if (ownKeys.length <= 0) {[31m
>> [39m	        return parentKeys;[31m
>> [39m	    }[31m
>> [39m	    var set = Set_1.createSet();[31m
>> [39m	    var keys = [];[31m
>> [39m	    for (var [4mi = 0; _i < ownKeys.length; _i++) {[31m
>> [39m	        var key = ownKeys[_i];[31m
>> [39m	        var hasKey = set.has(key);[31m
>> [39m	        if (!hasKey) {[31m
>> [39m	            set.add(key);[31m
>> [39m	            keys.push(key);[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    for (var _a = 0; _a < parentKeys.length; _a++) {[31m
>> [39m	        var key = parentKeys[_a];[31m
>> [39m	        var hasKey = set.has(key);[31m
>> [39m	        if (!hasKey) {[31m
>> [39m	            set.add(key);[31m
>> [39m	            keys.push(key);[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    return keys;[31m
>> [39m	}[31m
>> [39m	// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryownmetadatakeys--o-p-[31m
>> [39m	function OrdinaryOwnMetadataKeys(target, targetKey) {[31m
>> [39m	    var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);[31m
>> [39m	    var keys = [];[31m
>> [39m	    if (metadataMap) {[31m
>> [39m	        metadataMap.forEach(function ([24m, key) { return keys.push(key); });[31m
>> [39m	    }[31m
>> [39m	    return keys;[31m
>> [39m	}[31m
>> [39m	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-undefined-type[31m
>> [39m	function IsUndefined(x) {[31m
>> [39m	    return x === undefined;[31m
>> [39m	}[31m
>> [39m	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray[31m
>> [39m	function IsArray(x) {[31m
>> [39m	    return Array.isArray(x);[31m
>> [39m	}[31m
>> [39m	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-type[31m
>> [39m	function IsObject(x) {[31m
>> [39m	    return typeof x === "object" ? x !== null : typeof x === "function";[31m
>> [39m	}[31m
>> [39m	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor[31m
>> [39m	function IsConstructor(x) {[31m
>> [39m	    return typeof x === "function";[31m
>> [39m	}[31m
>> [39m	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-symbol-type[31m
>> [39m	function IsSymbol(x) {[31m
>> [39m	    return typeof x === "symbol";[31m
>> [39m	}[31m
>> [39m	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey[31m
>> [39m	function ToPropertyKey(value) {[31m
>> [39m	    if (IsSymbol(value)) {[31m
>> [39m	        return value;[31m
>> [39m	    }[31m
>> [39m	    return String(value);[31m
>> [39m	}[31m
>> [39m	function GetPrototypeOf(O) {[31m
>> [39m	    var proto = Object.getPrototypeOf(O);[31m
>> [39m	    if (typeof O !== "function" || O === functionPrototype) {[31m
>> [39m	        return proto;[31m
>> [39m	    }[31m
>> [39m	    // TypeScript doesn't set [4m_proto_[24m in ES5, as it's non-standard. [31m
>> [39m	    // Try to determine the superclass constructor. Compatible implementations[31m
>> [39m	    // must either set [4m_proto_[24m on a subclass constructor to the superclass constructor,[31m
>> [39m	    // or ensure each class has a valid `constructor` property on its prototype that[31m
>> [39m	    // points back to the constructor.[31m
>> [39m	    // If this is not the same as Function.[[Prototype]], then this is definately inherited.[31m
>> [39m	    // This is the case when in ES6 or when using [4m_proto_[24m in a compatible browser.[31m
>> [39m	    if (proto !== functionPrototype) {[31m
>> [39m	        return proto;[31m
>> [39m	    }[31m
>> [39m	    // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.[31m
>> [39m	    var prototype = O.prototype;[31m
>> [39m	    var prototypeProto = Object.getPrototypeOf(prototype);[31m
>> [39m	    if (prototypeProto == null || prototypeProto === Object.prototype) {[31m
>> [39m	        return proto;[31m
>> [39m	    }[31m
>> [39m	    // if the constructor was not a function, then we cannot determine the heritage.[31m
>> [39m	    var constructor = prototypeProto.constructor;[31m
>> [39m	    if (typeof constructor !== "function") {[31m
>> [39m	        return proto;[31m
>> [39m	    }[31m
>> [39m	    // if we have some kind of self-reference, then we cannot determine the heritage.[31m
>> [39m	    if (constructor === O) {[31m
>> [39m	        return proto;[31m
>> [39m	    }[31m
>> [39m	    // we have a pretty good guess at the heritage.[31m
>> [39m	    return constructor;[31m
>> [39m	}[31m
>> [39m	exports.implementsMetaDataKey = "wx:interfaceImpl";[31m
>> [39m	/*[22m[31m
>> [39m	* Interface decorator[31m
>> [39m	* @param {string} interfaceName Name of an interface[31m
>> [39m	[1m/[31m
>> [39m	function Implements(value) {[31m
>> [39m	    return function (target) {[31m
>> [39m	        var interfaces = getMetadata(exports.implementsMetaDataKey, target) || {};[31m
>> [39m	        if (typeof (value) === "string")[31m
>> [39m	            value = value.split(/\s+/).map(function (x) { return x.trim(); }).filter(function (x) { return x; });[31m
>> [39m	        for (var i = 0; i < value.length; i++)[31m
>> [39m	            interfaces[value[i]] = true;[31m
>> [39m	        defineMetadata(exports.implementsMetaDataKey, interfaces, target);[31m
>> [39m	    };[31m
>> [39m	}[31m
>> [39m	exports.Implements = Implements;[31m
>> [39m	//# sourceMappingURL=Reflect.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 4 [1m/[31m
>> [39m/***/ function(module, exports, [4m_webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/typescript/bin/lib.es6.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Oid_1 = __webpack_require__(5);[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* This class emulates the semantics of a WeakMap.[31m
>> [39m	* Even though this implementation is indeed "weak", it has the drawback of[31m
>> [39m	* requiring manual housekeeping of entries otherwise they are kept forever.[31m
>> [39m	* @class[31m
>> [39m	[1m/[31m
>> [39m	var WeakMapEmulated = (function () {[31m
>> [39m	    function WeakMapEmulated() {[31m
>> [39m	        ////////////////////[31m
>> [39m	        /// Implementation[31m
>> [39m	        this.inner = {};[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    /// IWeakMap[31m
>> [39m	    WeakMapEmulated.prototype.set = function (key, value) {[31m
>> [39m	        var oid = Oid_1.getOid(key);[31m
>> [39m	        this.inner[oid] = value;[31m
>> [39m	    };[31m
>> [39m	    WeakMapEmulated.prototype.get = function (key) {[31m
>> [39m	        var oid = Oid_1.getOid(key);[31m
>> [39m	        return this.inner[oid];[31m
>> [39m	    };[31m
>> [39m	    WeakMapEmulated.prototype.has = function (key) {[31m
>> [39m	        var oid = Oid_1.getOid(key);[31m
>> [39m	        return this.inner.hasOwnProperty(oid);[31m
>> [39m	    };[31m
>> [39m	    WeakMapEmulated.prototype.delete = function (key) {[31m
>> [39m	        var oid = Oid_1.getOid(key);[31m
>> [39m	        return delete this.inner[oid];[31m
>> [39m	    };[31m
>> [39m	    Object.defineProperty(WeakMapEmulated.prototype, "isEmulated", {[31m
>> [39m	        get: function () {[31m
>> [39m	            return true;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    return WeakMapEmulated;[31m
>> [39m	})();[31m
>> [39m	var hasNativeSupport = typeof WeakMap === "function";[31m
>> [39m	/*[22m[31m
>> [39m	* Creates a new WeakMap instance[31m
>> [39m	* @param {boolean} disableNativeSupport Force creation of an emulated implementation, regardless of browser native support.[31m
>> [39m	* @return {IWeakMap<TKey, T>} A new instance of a suitable IWeakMap implementation[31m
>> [39m	[1m/[31m
>> [39m	function createWeakMap(disableNativeSupport) {[31m
>> [39m	    if (disableNativeSupport || !hasNativeSupport) {[31m
>> [39m	        return new WeakMapEmulated();[31m
>> [39m	    }[31m
>> [39m	    return new WeakMap();[31m
>> [39m	}[31m
>> [39m	exports.createWeakMap = createWeakMap;[31m
>> [39m	//# sourceMappingURL=WeakMap.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 5 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	"use strict";[31m
>> [39m	var oid = 1;[31m
>> [39m	var oidPropertyName = "__wx_oid__" + (new Date).getTime();[31m
>> [39m	function isPrimitive(target) {[31m
>> [39m	    var t = typeof target;[31m
>> [39m	    return t === "boolean" || t === "number" || t === "string";[31m
>> [39m	}[31m
>> [39m	/*[22m[31m
>> [39m	* Returns the objects unique id or assigns it if unassigned[31m
>> [39m	* @param {any} o[31m
>> [39m	[1m/[31m
>> [39m	function getOid(o) {[31m
>> [39m	    if (o == null)[31m
>> [39m	        return undefined;[31m
>> [39m	    if (isPrimitive(o))[31m
>> [39m	        return (typeof o + ":" + o);[31m
>> [39m	    var result = o[oidPropertyName];[31m
>> [39m	    if (result === undefined) {[31m
>> [39m	        result = (++oid).toString();[31m
>> [39m	        o[oidPropertyName] = result;[31m
>> [39m	    }[31m
>> [39m	    return result;[31m
>> [39m	}[31m
>> [39m	exports.getOid = getOid;[31m
>> [39m	//# sourceMappingURL=Oid.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 6 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/typescript/bin/lib.es6.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Oid_1 = __webpack_require__(5);[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* ES6 Set Shim[31m
>> [39m	* @class[31m
>> [39m	[1m/[31m
>> [39m	var SetEmulated = (function () {[31m
>> [39m	    function SetEmulated() {[31m
>> [39m	        ////////////////////[31m
>> [39m	        /// Implementation[31m
>> [39m	        this.values = [];[31m
>> [39m	        this.keys = {};[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    /// ISet[31m
>> [39m	    SetEmulated.prototype.add = function (value) {[31m
>> [39m	        var key = Oid_1.getOid(value);[31m
>> [39m	        if (!this.keys[key]) {[31m
>> [39m	            this.values.push(value);[31m
>> [39m	            this.keys[key] = true;[31m
>> [39m	        }[31m
>> [39m	        return this;[31m
>> [39m	    };[31m
>> [39m	    SetEmulated.prototype.delete = function (value) {[31m
>> [39m	        var key = Oid_1.getOid(value);[31m
>> [39m	        if (this.keys[key]) {[31m
>> [39m	            var index = this.values.indexOf(value);[31m
>> [39m	            this.values.splice(index, 1);[31m
>> [39m	            delete this.keys[key];[31m
>> [39m	            return true;[31m
>> [39m	        }[31m
>> [39m	        return false;[31m
>> [39m	    };[31m
>> [39m	    SetEmulated.prototype.has = function (value) {[31m
>> [39m	        var key = Oid_1.getOid(value);[31m
>> [39m	        return this.keys.hasOwnProperty(key);[31m
>> [39m	    };[31m
>> [39m	    SetEmulated.prototype.clear = function () {[31m
>> [39m	        this.keys = {};[31m
>> [39m	        this.values.length = 0;[31m
>> [39m	    };[31m
>> [39m	    SetEmulated.prototype.forEach = function (callback, thisArg) {[31m
>> [39m	        this.values.forEach(callback, thisArg);[31m
>> [39m	    };[31m
>> [39m	    Object.defineProperty(SetEmulated.prototype, "size", {[31m
>> [39m	        get: function () {[31m
>> [39m	            return this.values.length;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(SetEmulated.prototype, "isEmulated", {[31m
>> [39m	        get: function () {[31m
>> [39m	            return true;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    return SetEmulated;[31m
>> [39m	})();[31m
>> [39m	var hasNativeSupport = typeof Set === "function" && Set.prototype.hasOwnProperty("forEach")[31m
>> [39m	    && Set.prototype.hasOwnProperty("add") && Set.prototype.hasOwnProperty("clear")[31m
>> [39m	    && Set.prototype.hasOwnProperty("delete") && Set.prototype.hasOwnProperty("has");[31m
>> [39m	/*[22m[31m
>> [39m	* Creates a new Set instance[31m
>> [39m	* @param {boolean} disableNativeSupport Force creation of an emulated implementation, regardless of browser native support.[31m
>> [39m	* @return {ISet<T>} A new instance of a suitable ISet implementation[31m
>> [39m	[1m/[31m
>> [39m	function createSet(disableNativeSupport) {[31m
>> [39m	    if (disableNativeSupport || !hasNativeSupport) {[31m
>> [39m	        return new SetEmulated();[31m
>> [39m	    }[31m
>> [39m	    return new Set();[31m
>> [39m	}[31m
>> [39m	exports.createSet = createSet;[31m
>> [39m	/*[22m[31m
>> [39m	* Extracts the values of a Set by invoking its forEach method and capturing the output[31m
>> [39m	[1m/[31m
>> [39m	function setToArray(src) {[31m
>> [39m	    var result = new Array();[31m
>> [39m	    src.forEach(function (x) { return result.push(x); });[31m
>> [39m	    return result;[31m
>> [39m	}[31m
>> [39m	exports.setToArray = setToArray;[31m
>> [39m	//# sourceMappingURL=Set.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 7 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/typescript/bin/lib.es6.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* ES6 Map Shim[31m
>> [39m	* @class[31m
>> [39m	[1m/[31m
>> [39m	var MapEmulated = (function () {[31m
>> [39m	    function MapEmulated() {[31m
>> [39m	        ////////////////////[31m
>> [39m	        /// Implementation[31m
>> [39m	        this.cacheSentinel = {};[31m
>> [39m	        this.keys = [];[31m
>> [39m	        this.values = [];[31m
>> [39m	        this.cache = this.cacheSentinel;[31m
>> [39m	    }[31m
>> [39m	    Object.defineProperty(MapEmulated.prototype, "size", {[31m
>> [39m	        ////////////////////[31m
>> [39m	        /// IMap[31m
>> [39m	        get: function () {[31m
>> [39m	            return this.keys.length;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    MapEmulated.prototype.has = function (key) {[31m
>> [39m	        if (key === this.cache) {[31m
>> [39m	            return true;[31m
>> [39m	        }[31m
>> [39m	        if (this.find(key) >= 0) {[31m
>> [39m	            this.cache = key;[31m
>> [39m	            return true;[31m
>> [39m	        }[31m
>> [39m	        return false;[31m
>> [39m	    };[31m
>> [39m	    MapEmulated.prototype.get = function (key) {[31m
>> [39m	        var index = this.find(key);[31m
>> [39m	        if (index >= 0) {[31m
>> [39m	            this.cache = key;[31m
>> [39m	            return this.values[index];[31m
>> [39m	        }[31m
>> [39m	        return undefined;[31m
>> [39m	    };[31m
>> [39m	    MapEmulated.prototype.set = function (key, value) {[31m
>> [39m	        this.delete(key);[31m
>> [39m	        this.keys.push(key);[31m
>> [39m	        this.values.push(value);[31m
>> [39m	        this.cache = key;[31m
>> [39m	        return this;[31m
>> [39m	    };[31m
>> [39m	    MapEmulated.prototype.delete = function (key) {[31m
>> [39m	        var index = this.find(key);[31m
>> [39m	        if (index >= 0) {[31m
>> [39m	            this.keys.splice(index, 1);[31m
>> [39m	            this.values.splice(index, 1);[31m
>> [39m	            this.cache = this.cacheSentinel;[31m
>> [39m	            return true;[31m
>> [39m	        }[31m
>> [39m	        return false;[31m
>> [39m	    };[31m
>> [39m	    MapEmulated.prototype.clear = function () {[31m
>> [39m	        this.keys.length = 0;[31m
>> [39m	        this.values.length = 0;[31m
>> [39m	        this.cache = this.cacheSentinel;[31m
>> [39m	    };[31m
>> [39m	    MapEmulated.prototype.forEach = function (callback, thisArg) {[31m
>> [39m	        var size = this.size;[31m
>> [39m	        for (var i = 0; i < size; ++i) {[31m
>> [39m	            var key = this.keys[i];[31m
>> [39m	            var value = this.values[i];[31m
>> [39m	            this.cache = key;[31m
>> [39m	            callback.call(this, value, key, this);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Object.defineProperty(MapEmulated.prototype, "isEmulated", {[31m
>> [39m	        get: function () {[31m
>> [39m	            return true;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    MapEmulated.prototype.find = function (key) {[31m
>> [39m	        var keys = this.keys;[31m
>> [39m	        var size = keys.length;[31m
>> [39m	        for (var i = 0; i < size; ++i) {[31m
>> [39m	            if (keys[i] === key) {[31m
>> [39m	                return i;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return -1;[31m
>> [39m	    };[31m
>> [39m	    return MapEmulated;[31m
>> [39m	})();[31m
>> [39m	var hasNativeSupport = typeof Map === "function" && Map.prototype.hasOwnProperty("forEach")[31m
>> [39m	    && Map.prototype.hasOwnProperty("add") && Map.prototype.hasOwnProperty("clear")[31m
>> [39m	    && Map.prototype.hasOwnProperty("devare") && Map.prototype.hasOwnProperty("has");[31m
>> [39m	/*[22m[31m
>> [39m	* Creates a new WeakMap instance[31m
>> [39m	* @param {boolean} disableNativeSupport Force creation of an emulated implementation, regardless of browser native support.[31m
>> [39m	* @return {IWeakMap<TKey, T>} A new instance of a suitable IWeakMap implementation[31m
>> [39m	[1m/[31m
>> [39m	function createMap(disableNativeSupport) {[31m
>> [39m	    if (disableNativeSupport || !hasNativeSupport) {[31m
>> [39m	        return new MapEmulated();[31m
>> [39m	    }[31m
>> [39m	    return new Map();[31m
>> [39m	}[31m
>> [39m	exports.createMap = createMap;[31m
>> [39m	//# sourceMappingURL=Map.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 8 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	"use strict";[31m
>> [39m	var PropertyChangedEventArgs = (function () {[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// Initializes a new instance of the <see cref="ObservablePropertyChangedEventArgs{TSender}"/> class.[31m
>> [39m	    /// </summary>[31m
>> [39m	    /// <param name="sender">The sender.</param>[31m
>> [39m	    /// <param name="propertyName">Name of the property.</param>[31m
>> [39m	    function PropertyChangedEventArgs(sender, propertyName) {[31m
>> [39m	        this.propertyName = propertyName;[31m
>> [39m	        this.sender = sender;[31m
>> [39m	    }[31m
>> [39m	    return PropertyChangedEventArgs;[31m
>> [39m	})();[31m
>> [39m	exports.PropertyChangedEventArgs = PropertyChangedEventArgs;[31m
>> [39m	//# sourceMappingURL=Events.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 9 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	"use strict";[31m
>> [39m	/// <summary>[31m
>> [39m	/// Interface registry to be used with IUnknown.queryInterface[31m
>> [39m	/// </summary>[31m
>> [39m	var IID = (function () {[31m
>> [39m	    function IID() {[31m
>> [39m	    }[31m
>> [39m	    IID.IDisposable = "IDisposable";[31m
>> [39m	    IID.IObservableProperty = "IObservableProperty";[31m
>> [39m	    IID.IObservableList = "IObservableList";[31m
>> [39m	    IID.ICommand = "ICommand";[31m
>> [39m	    IID.IHandleObservableErrors = "IHandleObservableErrors";[31m
>> [39m	    return IID;[31m
>> [39m	})();[31m
>> [39m	exports.default = IID;[31m
>> [39m	//# sourceMappingURL=IID.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 10 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	"use strict";[31m
>> [39m	exports.app = "app";[31m
>> [39m	exports.injector = "injector";[31m
>> [39m	exports.domManager = "domservice";[31m
>> [39m	exports.router = "router";[31m
>> [39m	exports.messageBus = "messageBus";[31m
>> [39m	exports.expressionCompiler = "expressioncompiler";[31m
>> [39m	exports.templateEngine = "templateEngine";[31m
>> [39m	exports.hasValueBindingValue = "has.bindings.value";[31m
>> [39m	exports.valueBindingValue = "bindings.value";[31m
>> [39m	//# sourceMappingURL=Resources.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 11 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	function log() {[31m
>> [39m	    var args = [];[31m
>> [39m	    for (var _i = 0; _i < arguments.length; _i++) {[31m
>> [39m	        args[_i - 0] = arguments[_i];[31m
>> [39m	    }[31m
>> [39m	    try {[31m
>> [39m	        console.log.apply(console, arguments);[31m
>> [39m	    }[31m
>> [39m	    catch (e) {[31m
>> [39m	        try {[31m
>> [39m	            window['opera'].postError.apply(window['opera'], arguments);[31m
>> [39m	        }[31m
>> [39m	        catch (e) {[31m
>> [39m	            alert(Array.prototype.join.call(arguments, " "));[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	}[31m
>> [39m	function critical(fmt) {[31m
>> [39m	    var args = [];[31m
>> [39m	    for (var _i = 1; _i < arguments.length; _i++) {[31m
>> [39m	        args[_i - 1] = arguments[_i];[31m
>> [39m	    }[31m
>> [39m	    if (args.length) {[31m
>> [39m	        fmt = Utils_1.formatString.apply(null, [fmt].concat(args));[31m
>> [39m	    }[31m
>> [39m	    log("***[22m WebRx Critical: " + fmt);[31m
>> [39m	}[31m
>> [39m	exports.critical = critical;[31m
>> [39m	function error(fmt) {[31m
>> [39m	    var args = [];[31m
>> [39m	    for (var _i = 1; _i < arguments.length; _i++) {[31m
>> [39m	        args[_i - 1] = arguments[_i];[31m
>> [39m	    }[31m
>> [39m	    if (args.length) {[31m
>> [39m	        fmt = Utils_1.formatString.apply(null, [fmt].concat(args));[31m
>> [39m	    }[31m
>> [39m	    log("*** WebRx Error: " + fmt);[31m
>> [39m	}[31m
>> [39m	exports.error = error;[31m
>> [39m	function info(fmt) {[31m
>> [39m	    var args = [];[31m
>> [39m	    for (var _i = 1; _i < arguments.length; _i++) {[31m
>> [39m	        args[_i - 1] = arguments[_i];[31m
>> [39m	    }[31m
>> [39m	    if (args.length) {[31m
>> [39m	        fmt = Utils_1.formatString.apply(null, [fmt].concat(args));[31m
>> [39m	    }[31m
>> [39m	    log("* WebRx Info: " + fmt);[31m
>> [39m	}[31m
>> [39m	exports.info = info;[31m
>> [39m	//# sourceMappingURL=Log.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/* 12 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Reflect_1 = __webpack_require__(3);[31m
>> [39m	var IID_1 = __webpack_require__(9);[31m
>> [39m	// NOTE: The factory method approach is necessary because it is  [31m
>> [39m	// currently impossible to implement a Typescript interface [31m
>> [39m	// with a function signature in a Typescript class.[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* Creates an observable property with an optional default value[31m
>> [39m	* @param {T} initialValue?[31m
>> [39m	[1m/[31m
>> [39m	function property(initialValue) {[31m
>> [39m	    // initialize accessor function[31m
>> [39m	    var accessor = function (newVal) {[31m
>> [39m	        if (arguments.length > 0) {[31m
>> [39m	            // set[31m
>> [39m	            if (newVal !== accessor.value) {[31m
>> [39m	                accessor.changingSubject.onNext(newVal);[31m
>> [39m	                accessor.value = newVal;[31m
>> [39m	                accessor.changedSubject.onNext(newVal);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // get[31m
>> [39m	            return accessor.value;[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Reflect_1.Implements(IID_1.default.IObservableProperty)(accessor);[31m
>> [39m	    Reflect_1.Implements(IID_1.default.IDisposable)(accessor);[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // IDisposable implementation[31m
>> [39m	    accessor.dispose = function () {[31m
>> [39m	    };[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // IObservableProperty<T> implementation[31m
>> [39m	    if (initialValue !== undefined)[31m
>> [39m	        accessor.value = initialValue;[31m
>> [39m	    // setup observables[31m
>> [39m	    accessor.changedSubject = new Rx.Subject();[31m
>> [39m	    accessor.changed = accessor.changedSubject[31m
>> [39m	        .publish()[31m
>> [39m	        .refCount();[31m
>> [39m	    accessor.changingSubject = new Rx.Subject();[31m
>> [39m	    accessor.changing = accessor.changingSubject[31m
>> [39m	        .publish()[31m
>> [39m	        .refCount();[31m
>> [39m	    return accessor;[31m
>> [39m	}[31m
>> [39m	exports.property = property;[31m
>> [39m	//# sourceMappingURL=Property.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 13 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Injector_1 = __webpack_require__(1);[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var res = __webpack_require__(10);[31m
>> [39m	"use strict";[31m
>> [39m	var Module = (function () {[31m
>> [39m	    function Module(name) {[31m
>> [39m	        //////////////////////////////////[31m
>> [39m	        // Implementation[31m
>> [39m	        this.bindings = {};[31m
>> [39m	        this.components = {};[31m
>> [39m	        this.expressionFilters = {};[31m
>> [39m	        this.animations = {};[31m
>> [39m	        this.name = name;[31m
>> [39m	    }[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // wx.IModule[31m
>> [39m	    Module.prototype.merge = function (other) {[31m
>> [39m	        var _other = other;[31m
>> [39m	        Utils_1.extend(_other.components, this.components);[31m
>> [39m	        Utils_1.extend(_other.bindings, this.bindings);[31m
>> [39m	        Utils_1.extend(_other.expressionFilters, this.expressionFilters);[31m
>> [39m	        Utils_1.extend(_other.animations, this.animations);[31m
>> [39m	        return this;[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.component = function (name, component) {[31m
>> [39m	        this.components[name] = component;[31m
>> [39m	        return this;[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.hasComponent = function (name) {[31m
>> [39m	        return this.components[name] != null;[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.loadComponent = function (name, params) {[31m
>> [39m	        return this.initializeComponent(this.instantiateComponent(name), params);[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.binding = function () {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var args = Utils_1.args2Array(arguments);[31m
>> [39m	        var name = args.shift();[31m
>> [39m	        var handler;[31m
>> [39m	        // lookup?[31m
>> [39m	        if (args.length === 0) {[31m
>> [39m	            // if the handler has been registered as resource, resolve it now and update registry[31m
>> [39m	            handler = this.bindings[name];[31m
>> [39m	            if (typeof handler === "string") {[31m
>> [39m	                handler = Injector_1.injector.get(handler);[31m
>> [39m	                this.bindings[name] = handler;[31m
>> [39m	            }[31m
>> [39m	            return handler;[31m
>> [39m	        }[31m
>> [39m	        // registration[31m
>> [39m	        handler = args.shift();[31m
>> [39m	        if (Array.isArray(name)) {[31m
>> [39m	            name.forEach(function (x) { return _this.bindings[x] = handler; });[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            this.bindings[name] = handler;[31m
>> [39m	        }[31m
>> [39m	        return this;[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.filter = function () {[31m
>> [39m	        var args = Utils_1.args2Array(arguments);[31m
>> [39m	        var name = args.shift();[31m
>> [39m	        var filter;[31m
>> [39m	        // lookup?[31m
>> [39m	        if (args.length === 0) {[31m
>> [39m	            // if the filter has been registered as resource, resolve it now and update registry[31m
>> [39m	            filter = this.expressionFilters[name];[31m
>> [39m	            if (typeof filter === "string") {[31m
>> [39m	                filter = Injector_1.injector.get(filter);[31m
>> [39m	                this.bindings[name] = filter;[31m
>> [39m	            }[31m
>> [39m	            return filter;[31m
>> [39m	        }[31m
>> [39m	        // registration[31m
>> [39m	        filter = args.shift();[31m
>> [39m	        this.expressionFilters[name] = filter;[31m
>> [39m	        return this;[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.filters = function () {[31m
>> [39m	        return this.expressionFilters;[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.animation = function () {[31m
>> [39m	        var args = Utils_1.args2Array(arguments);[31m
>> [39m	        var name = args.shift();[31m
>> [39m	        var animation;[31m
>> [39m	        // lookup?[31m
>> [39m	        if (args.length === 0) {[31m
>> [39m	            // if the animation has been registered as resource, resolve it now and update registry[31m
>> [39m	            animation = this.animations[name];[31m
>> [39m	            if (typeof animation === "string") {[31m
>> [39m	                animation = Injector_1.injector.get(animation);[31m
>> [39m	                this.bindings[name] = animation;[31m
>> [39m	            }[31m
>> [39m	            return animation;[31m
>> [39m	        }[31m
>> [39m	        // registration[31m
>> [39m	        animation = args.shift();[31m
>> [39m	        this.animations[name] = animation;[31m
>> [39m	        return this;[31m
>> [39m	    };[31m
>> [39m	    Object.defineProperty(Module.prototype, "app", {[31m
>> [39m	        get: function () {[31m
>> [39m	            return Injector_1.injector.get(res.app);[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Module.prototype.instantiateComponent = function (name) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var cd = this.components[name];[31m
>> [39m	        var result = undefined;[31m
>> [39m	        if (cd != null) {[31m
>> [39m	            // if the component has been registered as resource, resolve it now and update registry[31m
>> [39m	            if (cd.instance) {[31m
>> [39m	                result = Rx.Observable.return(cd.instance);[31m
>> [39m	            }[31m
>> [39m	            else if (cd.template) {[31m
>> [39m	                result = Rx.Observable.return(cd);[31m
>> [39m	            }[31m
>> [39m	            else if (cd.resolve) {[31m
>> [39m	                var resolved = Injector_1.injector.get(cd.resolve);[31m
>> [39m	                result = Rx.Observable.return(resolved);[31m
>> [39m	            }[31m
>> [39m	            else if (cd.require) {[31m
>> [39m	                result = Utils_1.observableRequire(cd.require);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            result = Rx.Observable.return(undefined);[31m
>> [39m	        }[31m
>> [39m	        return result.do(function (x) { return _this.components[name].instance = x; }); // cache instantiated component[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.initializeComponent = function (obs, params) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        return obs.take(1).selectMany(function (component) {[31m
>> [39m	            if (component == null) {[31m
>> [39m	                return Rx.Observable.return(undefined);[31m
>> [39m	            }[31m
>> [39m	            if (component.viewModel) {[31m
>> [39m	                // component with view-model & template[31m
>> [39m	                return Rx.Observable.combineLatest(_this.loadComponentTemplate(component.template, params), _this.loadComponentViewModel(component.viewModel, params), function (t, vm) {[31m
>> [39m	                    // if view-model factory yields a function, use it as constructor[31m
>> [39m	                    if (Utils_1.isFunction(vm)) {[31m
>> [39m	                        vm = new vm(params);[31m
>> [39m	                    }[31m
>> [39m	                    return {[31m
>> [39m	                        template: t,[31m
>> [39m	                        viewModel: vm,[31m
>> [39m	                        preBindingInit: component.preBindingInit,[31m
>> [39m	                        postBindingInit: component.postBindingInit[31m
>> [39m	                    };[31m
>> [39m	                });[31m
>> [39m	            }[31m
>> [39m	            // template-only component[31m
>> [39m	            return _this.loadComponentTemplate(component.template, params)[31m
>> [39m	                .select(function (template) { return {[31m
>> [39m	                template: template,[31m
>> [39m	                preBindingInit: component.preBindingInit,[31m
>> [39m	                postBindingInit: component.postBindingInit[31m
>> [39m	            }; });[31m
>> [39m	        })[31m
>> [39m	            .take(1);[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.loadComponentTemplate = function (template, params) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var syncResult;[31m
>> [39m	        var el;[31m
>> [39m	        if (Utils_1.isFunction(template)) {[31m
>> [39m	            syncResult = template(params);[31m
>> [39m	            if (typeof syncResult === "string") {[31m
>> [39m	                syncResult = this.app.templateEngine.parse(template(params));[31m
>> [39m	            }[31m
>> [39m	            return Rx.Observable.return(syncResult);[31m
>> [39m	        }[31m
>> [39m	        else if (typeof template === "string") {[31m
>> [39m	            syncResult = this.app.templateEngine.parse(template);[31m
>> [39m	            return Rx.Observable.return(syncResult);[31m
>> [39m	        }[31m
>> [39m	        else if (Array.isArray(template)) {[31m
>> [39m	            return Rx.Observable.return(template);[31m
>> [39m	        }[31m
>> [39m	        else if (typeof template === "object") {[31m
>> [39m	            var options = template;[31m
>> [39m	            if (options.resolve) {[31m
>> [39m	                syncResult = Injector_1.injector.get(options.resolve);[31m
>> [39m	                return Rx.Observable.return(syncResult);[31m
>> [39m	            }[31m
>> [39m	            else if (options.promise) {[31m
>> [39m	                var promise = options.promise;[31m
>> [39m	                return Rx.Observable.fromPromise(promise);[31m
>> [39m	            }[31m
>> [39m	            else if (options.require) {[31m
>> [39m	                return Utils_1.observableRequire(options.require).select(function (x) { return _this.app.templateEngine.parse(x); });[31m
>> [39m	            }[31m
>> [39m	            else if (options.element) {[31m
>> [39m	                if (typeof options.element === "string") {[31m
>> [39m	                    // try both getElementById & querySelector[31m
>> [39m	                    el = document.getElementById(options.element) ||[31m
>> [39m	                        document.querySelector(options.element);[31m
>> [39m	                    if (el != null) {[31m
>> [39m	                        // only the nodes inside the specified element will be cloned for use as the component’s template[31m
>> [39m	                        syncResult = this.app.templateEngine.parse(el.innerHTML);[31m
>> [39m	                    }[31m
>> [39m	                    else {[31m
>> [39m	                        syncResult = [];[31m
>> [39m	                    }[31m
>> [39m	                    return Rx.Observable.return(syncResult);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    el = options.element;[31m
>> [39m	                    // unwrap text/html script nodes[31m
>> [39m	                    if (el != null) {[31m
>> [39m	                        // only the nodes inside the specified element will be cloned for use as the component’s template[31m
>> [39m	                        syncResult = this.app.templateEngine.parse(el.innerHTML);[31m
>> [39m	                    }[31m
>> [39m	                    else {[31m
>> [39m	                        syncResult = [];[31m
>> [39m	                    }[31m
>> [39m	                    return Rx.Observable.return(syncResult);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        Utils_1.throwError("invalid template descriptor");[31m
>> [39m	    };[31m
>> [39m	    Module.prototype.loadComponentViewModel = function (vm, componentParams) {[31m
>> [39m	        var syncResult;[31m
>> [39m	        if (Utils_1.isFunction(vm)) {[31m
>> [39m	            return Rx.Observable.return(vm);[31m
>> [39m	        }[31m
>> [39m	        else if (Array.isArray(vm)) {[31m
>> [39m	            // assumed to be inline-annotated-array[31m
>> [39m	            syncResult = Injector_1.injector.resolve(vm, componentParams);[31m
>> [39m	            return Rx.Observable.return(syncResult);[31m
>> [39m	        }[31m
>> [39m	        else if (typeof vm === "object") {[31m
>> [39m	            var options = vm;[31m
>> [39m	            if (options.resolve) {[31m
>> [39m	                syncResult = Injector_1.injector.get(options.resolve, componentParams);[31m
>> [39m	                return Rx.Observable.return(syncResult);[31m
>> [39m	            }[31m
>> [39m	            else if (options.promise) {[31m
>> [39m	                var promise = options.promise;[31m
>> [39m	                return Rx.Observable.fromPromise(promise);[31m
>> [39m	            }[31m
>> [39m	            else if (options.require) {[31m
>> [39m	                return Utils_1.observableRequire(options.require);[31m
>> [39m	            }[31m
>> [39m	            else if (options.instance) {[31m
>> [39m	                return Rx.Observable.return(options.instance);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        Utils_1.throwError("invalid view-model descriptor");[31m
>> [39m	    };[31m
>> [39m	    return Module;[31m
>> [39m	})();[31m
>> [39m	exports.Module = Module;[31m
>> [39m	exports.modules = {};[31m
>> [39m	/*[22m[31m
>> [39m	* Defines a module.[31m
>> [39m	* @param {string} name The module name[31m
>> [39m	* @return {wx.IModule} The module handle[31m
>> [39m	[1m/[31m
>> [39m	function module(name, descriptor) {[31m
>> [39m	    exports.modules[name] = descriptor;[31m
>> [39m	    return this;[31m
>> [39m	}[31m
>> [39m	exports.module = module;[31m
>> [39m	/*[22m[31m
>> [39m	* Instantiate a new module instance and configure it using the user supplied configuration[31m
>> [39m	* @param {string} name The module name[31m
>> [39m	* @return {wx.IModule} The module handle[31m
>> [39m	[1m/[31m
>> [39m	function loadModule(name) {[31m
>> [39m	    var md = exports.modules[name];[31m
>> [39m	    var result = undefined;[31m
>> [39m	    var module;[31m
>> [39m	    if (md != null) {[31m
>> [39m	        if (Array.isArray(md)) {[31m
>> [39m	            // assumed to be inline-annotated-array[31m
>> [39m	            // resolve the configuration function via DI and invoke it with the module instance as argument[31m
>> [39m	            module = new Module(name);[31m
>> [39m	            Injector_1.injector.resolve(md, module);[31m
>> [39m	            result = Rx.Observable.return(module);[31m
>> [39m	        }[31m
>> [39m	        else if (Utils_1.isFunction(md)) {[31m
>> [39m	            // configuration function[31m
>> [39m	            module = new Module(name);[31m
>> [39m	            md(module);[31m
>> [39m	            result = Rx.Observable.return(module);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            var mdd = md;[31m
>> [39m	            if (mdd.instance) {[31m
>> [39m	                result = Rx.Observable.return(mdd.instance);[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                module = new Module(name);[31m
>> [39m	                if (mdd.resolve) {[31m
>> [39m	                    // resolve the configuration function via DI and invoke it with the module instance as argument[31m
>> [39m	                    Injector_1.injector.get(mdd.resolve, module);[31m
>> [39m	                    result = Rx.Observable.return(module);[31m
>> [39m	                }[31m
>> [39m	                else if (mdd.require) {[31m
>> [39m	                    // load the configuration function from external module and invoke it with the module instance as argument[31m
>> [39m	                    result = Utils_1.observableRequire(mdd.require)[31m
>> [39m	                        .do(function (x) { return x(module); }) // configure the module[31m
>> [39m	                        .select(function (x) { return module; });[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    else {[31m
>> [39m	        result = Rx.Observable.return(undefined);[31m
>> [39m	    }[31m
>> [39m	    return result.take(1).do(function (x) { return exports.modules[name] = { instance: x }; }); // cache instantiated module[31m
>> [39m	}[31m
>> [39m	exports.loadModule = loadModule;[31m
>> [39m	//# sourceMappingURL=Module.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 14 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* Knockout's object-literal parser ported to Typescript[31m
>> [39m	[1m/[31m
>> [39m	// The following regular expressions will be used to split an object-literal string into tokens[31m
>> [39m	// These two match strings, either with double quotes or single quotes[31m
>> [39m	var stringDouble = '"(?:[^"\\\\]|\\\\.)*"';[31m
>> [39m	var stringSingle = "'(?:[^'\\\\]|\\\\.)*'";[31m
>> [39m	// Matches a regular expression (text enclosed by slashes), but will also match sets of divisions[31m
>> [39m	// as a regular expression (this is handled by the parsing loop below).[31m
>> [39m	var stringRegexp = '/(?:[^/\\\\]|\\\\.)*/\w*';[31m
>> [39m	// These characters have special meaning to the parser and must not appear in the middle of a[31m
>> [39m	// token, except as part of a string.[31m
>> [39m	var specials = ',"\'{}()/:[\\]';[31m
>> [39m	// Match text (at least two characters) that does not contain any of the above special characters,[31m
>> [39m	// although some of the special characters are allowed to start it (all but the colon and comma).[31m
>> [39m	// The text can contain spaces, but leading or trailing spaces are skipped.[31m
>> [39m	var everyThingElse = '[^\\s:,/][^' + specials + ']*[^\\s' + specials + ']';[31m
>> [39m	// Match any non-space character not matched already. This will match colons and commas, since they're[31m
>> [39m	// not matched by "everyThingElse", but will also match any other single character that wasn't already[31m
>> [39m	// matched (for example: in "a: 1, b: 2", each of the non-space characters will be matched by oneNotSpace).[31m
>> [39m	var oneNotSpace = '[^\\s]';[31m
>> [39m	// Create the actual regular expression by or-ing the above strings. The order is important.[31m
>> [39m	var bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g');[31m
>> [39m	// Match end of previous token to determine whether a slash is a division or regex.[31m
>> [39m	var divisionLookBehind = /[\])"'A-Za-z0-9_$]+$/;[31m
>> [39m	var keywordRegexLookBehind = { 'in': 1, 'return': 1, 'typeof': 1 };[31m
>> [39m	/*[22m[31m
>> [39m	* Split an object-literal string into tokens (borrowed from the KnockoutJS project)[31m
>> [39m	* @param {string} objectLiteralString A javascript-style object literal without leading and trailing curly brances[31m
>> [39m	* @return {Command<any>} A Command whose ExecuteAsync just returns the CommandParameter immediately. Which you should ignore![31m
>> [39m	[1m/[31m
>> [39m	function parseObjectLiteral(objectLiteralString) {[31m
>> [39m	    // Trim leading and trailing spaces from the string[31m
>> [39m	    var str = objectLiteralString.trim();[31m
>> [39m	    // Trim braces '{' surrounding the whole object literal[31m
>> [39m	    if (str.charCodeAt(0) === 123)[31m
>> [39m	        str = str.slice(1, -1);[31m
>> [39m	    // Split into tokens[31m
>> [39m	    var result = new Array(), toks = str.match(bindingToken), key, values, depth = 0;[31m
>> [39m	    if (toks) {[31m
>> [39m	        // Append a comma so that we don't need a separate code block to deal with the last item[31m
>> [39m	        toks.push(',');[31m
>> [39m	        for (var i = 0, tok = void 0; tok = toks[i]; ++i) {[31m
>> [39m	            var c = tok.charCodeAt(0);[31m
>> [39m	            // A comma signals the end of a key/value pair if depth is zero[31m
>> [39m	            if (c === 44) {[31m
>> [39m	                if (depth <= 0) {[31m
>> [39m	                    if (key)[31m
>> [39m	                        result.push(values ? { key: key, value: values.join('') } : { 'unknown': key, value: undefined });[31m
>> [39m	                    key = values = depth = 0;[31m
>> [39m	                    continue;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            else if (c === 58) {[31m
>> [39m	                if (!values)[31m
>> [39m	                    continue;[31m
>> [39m	            }[31m
>> [39m	            else if (c === 47 && i && tok.length > 1) {[31m
>> [39m	                // Look at the end of the previous token to determine if the slash is actually division[31m
>> [39m	                var match = toks[i - 1].match(divisionLookBehind);[31m
>> [39m	                if (match && !keywordRegexLookBehind[match[0]]) {[31m
>> [39m	                    // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)[31m
>> [39m	                    str = str.substr(str.indexOf(tok) + 1);[31m
>> [39m	                    toks = str.match(bindingToken);[31m
>> [39m	                    toks.push(',');[31m
>> [39m	                    i = -1;[31m
>> [39m	                    // Continue with just the slash[31m
>> [39m	                    tok = '/';[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            else if (c === 40 || c === 123 || c === 91) {[31m
>> [39m	                ++depth;[31m
>> [39m	            }[31m
>> [39m	            else if (c === 41 || c === 125 || c === 93) {[31m
>> [39m	                --depth;[31m
>> [39m	            }[31m
>> [39m	            else if (!key && !values) {[31m
>> [39m	                key = (c === 34 || c === 39) /[22m '"', "'" [1m/ ? tok.slice(1, -1) : tok;[31m
>> [39m	                continue;[31m
>> [39m	            }[31m
>> [39m	            if (values)[31m
>> [39m	                values.push(tok);[31m
>> [39m	            else[31m
>> [39m	                values = [tok];[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    return result;[31m
>> [39m	}[31m
>> [39m	exports.parseObjectLiteral = parseObjectLiteral;[31m
>> [39m	/*[22m[31m
>> [39m	* Angular's expression compiler ported to Typescript[31m
>> [39m	[1m/[31m
>> [39m	var hookField = "___runtimeHooks";[31m
>> [39m	function isDefined(value) { return typeof value !== "undefined"; }[31m
>> [39m	//function valueFn(value) { return () => value; }[31m
>> [39m	function $parseMinErr(module, message, arg1, arg2, arg3, arg4, arg5) {[31m
>> [39m	    var args = arguments;[31m
>> [39m	    message = message.replace(/{(\d)}/g, function (match) {[31m
>> [39m	        return args[2 + parseInt(match[1])];[31m
>> [39m	    });[31m
>> [39m	    throw new SyntaxError(message);[31m
>> [39m	}[31m
>> [39m	function lowercase(string) { return typeof string === "string" ? string.toLowerCase() : string; }[31m
>> [39m	// Sandboxing Angular Expressions[31m
>> [39m	// ------------------------------[31m
>> [39m	// Angular expressions are generally considered safe because these expressions only have direct[31m
>> [39m	// access to $scope and locals. However, one can obtain the ability to execute arbitrary JS code by[31m
>> [39m	// obtaining a reference to native JS functions such as the Function constructor.[31m
>> [39m	//[31m
>> [39m	// As an example, consider the following Angular expression:[31m
>> [39m	//[31m
>> [39m	//   {}.toString.constructor(alert("evil JS code"))[31m
>> [39m	//[31m
>> [39m	// We want to prevent this type of access. For the sake of performance, during the lexing phase we[31m
>> [39m	// disallow any "dotted" access to any member named "constructor".[31m
>> [39m	//[31m
>> [39m	// For reflective calls (a[b]) we check that the value of the lookup is not the Function constructor[31m
>> [39m	// while evaluating the expression, which is a stronger but more expensive test. Since reflective[31m
>> [39m	// calls are expensive anyway, this is not such a big deal compared to static dereferencing.[31m
>> [39m	//[31m
>> [39m	// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits[31m
>> [39m	// against the expression language, but not to prevent exploits that were enabled by exposing[31m
>> [39m	// sensitive JavaScript or browser apis on Scope. Exposing such objects on a Scope is never a good[31m
>> [39m	// practice and therefore we are not even trying to protect against interaction with an object[31m
>> [39m	// explicitly exposed in this way.[31m
>> [39m	//[31m
>> [39m	// A developer could foil the name check by aliasing the Function constructor under a different[31m
>> [39m	// name on the scope.[31m
>> [39m	//[31m
>> [39m	// In general, it is not possible to access a Window object from an angular expression unless a[31m
>> [39m	// window or some DOM object that has a reference to window is published onto a Scope.[31m
>> [39m	function ensureSafeMemberName(name, fullExpression) {[31m
>> [39m	    if (name === "constructor") {[31m
>> [39m	        throw $parseMinErr("isecfld", "Referencing \"constructor\" field in WebRx expressions is disallowed! Expression: {0}", fullExpression);[31m
>> [39m	    }[31m
>> [39m	    return name;[31m
>> [39m	}[31m
>> [39m	function ensureSafeObject(obj, fullExpression) {[31m
>> [39m	    // nifty check if obj is Function that is fast and works across iframes and other contexts[31m
>> [39m	    if (obj) {[31m
>> [39m	        if (obj.constructor === obj) {[31m
>> [39m	            throw $parseMinErr("isecfn", "Referencing Function in WebRx expressions is disallowed! Expression: {0}", fullExpression);[31m
>> [39m	        }[31m
>> [39m	        else if (obj.document && obj.location && obj.alert && obj.setInterval) {[31m
>> [39m	            throw $parseMinErr("isecwindow", "Referencing the Window in WebRx expressions is disallowed! Expression: {0}", fullExpression);[31m
>> [39m	        }[31m
>> [39m	        else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {[31m
>> [39m	            throw $parseMinErr("isecdom", "Referencing DOM nodes in WebRx expressions is disallowed! Expression: {0}", fullExpression);[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    return obj;[31m
>> [39m	}[31m
>> [39m	var OPERATORS = {[31m
>> [39m	    /[22m jshint bitwise : false [1m/[31m
>> [39m	    'null': function () { return null; },[31m
>> [39m	    'true': function () { return true; },[31m
>> [39m	    'false': function () { return false; },[31m
>> [39m	    undefined: Utils_1.noop,[31m
>> [39m	    '+': function (self, locals, a, b) {[31m
>> [39m	        a = a(self, locals);[31m
>> [39m	        b = b(self, locals);[31m
>> [39m	        if (isDefined(a)) {[31m
>> [39m	            if (isDefined(b)) {[31m
>> [39m	                return a + b;[31m
>> [39m	            }[31m
>> [39m	            return a;[31m
>> [39m	        }[31m
>> [39m	        return isDefined(b) ? b : undefined;[31m
>> [39m	    },[31m
>> [39m	    '-': function (self, locals, a, b) {[31m
>> [39m	        a = a(self, locals);[31m
>> [39m	        b = b(self, locals);[31m
>> [39m	        return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);[31m
>> [39m	    },[31m
>> [39m	    '*': function (self, locals, a, b) { return a(self, locals) * b(self, locals); },[31m
>> [39m	    '/': function (self, locals, a, b) { return a(self, locals) / b(self, locals); },[31m
>> [39m	    '%': function (self, locals, a, b) { return a(self, locals) % b(self, locals); },[31m
>> [39m	    '^': function (self, locals, a, b) { return a(self, locals) ^ b(self, locals); },[31m
>> [39m	    '=': Utils_1.noop,[31m
>> [39m	    '===': function (self, locals, a, b) { return a(self, locals) === b(self, locals); },[31m
>> [39m	    '!==': function (self, locals, a, b) { return a(self, locals) !== b(self, locals); },[31m
>> [39m	    '==': function (self, locals, a, b) { return a(self, locals) === b(self, locals); },[31m
>> [39m	    '!=': function (self, locals, a, b) { return a(self, locals) !== b(self, locals); },[31m
>> [39m	    '<': function (self, locals, a, b) { return a(self, locals) < b(self, locals); },[31m
>> [39m	    '>': function (self, locals, a, b) { return a(self, locals) > b(self, locals); },[31m
>> [39m	    '<=': function (self, locals, a, b) { return a(self, locals) <= b(self, locals); },[31m
>> [39m	    '>=': function (self, locals, a, b) { return a(self, locals) >= b(self, locals); },[31m
>> [39m	    '&&': function (self, locals, a, b) { return a(self, locals) && b(self, locals); },[31m
>> [39m	    '||': function (self, locals, a, b) { return a(self, locals) || b(self, locals); },[31m
>> [39m	    '&': function (self, locals, a, b) { return a(self, locals) & b(self, locals); },[31m
>> [39m	    //    '|':function(self, locals, a,b){return a|b;},[31m
>> [39m	    '|': function (self, locals, a, b) { return b(self, locals)(self, locals, a(self, locals)); },[31m
>> [39m	    '!': function (self, locals, a) { return !a(self, locals); }[31m
>> [39m	};[31m
>> [39m	/[22m jshint bitwise: true [1m/[31m
>> [39m	var ESCAPE = { "n": "\n", "f": "\f", "r": "\r", "t": "\t", "v": "\v", "'": "'", '"': "\"" };[31m
>> [39m	/*[22m[31m
>> [39m	* @constructor[31m
>> [39m	[1m/[31m
>> [39m	var Lexer = (function () {[31m
>> [39m	    function Lexer(options) {[31m
>> [39m	        this.options = options;[31m
>> [39m	    }[31m
>> [39m	    Lexer.prototype.lex = function (text) {[31m
>> [39m	        this.text = text;[31m
>> [39m	        this.index = 0;[31m
>> [39m	        this.ch = undefined;[31m
>> [39m	        this.lastCh = ":"; // can start regexp[31m
>> [39m	        this.tokens = [];[31m
>> [39m	        var token;[31m
>> [39m	        var json = [];[31m
>> [39m	        while (this.index < this.text.length) {[31m
>> [39m	            this.ch = this.text.charAt(this.index);[31m
>> [39m	            if (this.is("\"'")) {[31m
>> [39m	                this.readString(this.ch);[31m
>> [39m	            }[31m
>> [39m	            else if (this.isNumber(this.ch) || this.is(".") && this.isNumber(this.peek())) {[31m
>> [39m	                this.readNumber();[31m
>> [39m	            }[31m
>> [39m	            else if (this.isIdent(this.ch)) {[31m
>> [39m	                this.readIdent();[31m
>> [39m	                // identifiers can only be if the preceding char was a { or ,[31m
>> [39m	                if (this.was("{,") && json[0] === "{" &&[31m
>> [39m	                    (token = this.tokens[this.tokens.length - 1])) {[31m
>> [39m	                    token.json = token.text.indexOf(".") === -1;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            else if (this.is("(){}[].,;:?")) {[31m
>> [39m	                this.tokens.push({[31m
>> [39m	                    index: this.index,[31m
>> [39m	                    text: this.ch,[31m
>> [39m	                    json: (this.was(":[,") && this.is("{[")) || this.is("}]:,")[31m
>> [39m	                });[31m
>> [39m	                if (this.is("{["))[31m
>> [39m	                    json.unshift(this.ch);[31m
>> [39m	                if (this.is("}]"))[31m
>> [39m	                    json.shift();[31m
>> [39m	                this.index++;[31m
>> [39m	            }[31m
>> [39m	            else if (this.isWhitespace(this.ch)) {[31m
>> [39m	                this.index++;[31m
>> [39m	                continue;[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                var ch2 = this.ch + this.peek();[31m
>> [39m	                var ch3 = ch2 + this.peek(2);[31m
>> [39m	                var fn = OPERATORS[this.ch];[31m
>> [39m	                var fn2 = OPERATORS[ch2];[31m
>> [39m	                var fn3 = OPERATORS[ch3];[31m
>> [39m	                if (fn3) {[31m
>> [39m	                    this.tokens.push({ index: this.index, text: ch3, fn: fn3 });[31m
>> [39m	                    this.index += 3;[31m
>> [39m	                }[31m
>> [39m	                else if (fn2) {[31m
>> [39m	                    this.tokens.push({ index: this.index, text: ch2, fn: fn2 });[31m
>> [39m	                    this.index += 2;[31m
>> [39m	                }[31m
>> [39m	                else if (fn) {[31m
>> [39m	                    this.tokens.push({[31m
>> [39m	                        index: this.index,[31m
>> [39m	                        text: this.ch,[31m
>> [39m	                        fn: fn,[31m
>> [39m	                        json: (this.was("[,:") && this.is(" + -"))[31m
>> [39m	                    });[31m
>> [39m	                    this.index += 1;[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    this.throwError("Unexpected next character ", this.index, this.index + 1);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            this.lastCh = this.ch;[31m
>> [39m	        }[31m
>> [39m	        return this.tokens;[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.is = function (chars) {[31m
>> [39m	        return chars.indexOf(this.ch) !== -1;[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.was = function (chars) {[31m
>> [39m	        return chars.indexOf(this.lastCh) !== -1;[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.peek = function (i) {[31m
>> [39m	        var num = i || 1;[31m
>> [39m	        return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.isNumber = function (ch) {[31m
>> [39m	        return ("0" <= ch && ch <= "9");[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.isWhitespace = function (ch) {[31m
>> [39m	        // IE treats non-breaking space as \u00A0[31m
>> [39m	        return (ch === " " || ch === "\r" || ch === "\t" ||[31m
>> [39m	            ch === "\n" || ch === "\v" || ch === "\u00A0");[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.isIdent = function (ch) {[31m
>> [39m	        return ("a" <= ch && ch <= "z" ||[31m
>> [39m	            "A" <= ch && ch <= "Z" ||[31m
>> [39m	            "_" === ch || ch === "$" || ch === "@");[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.isExpOperator = function (ch) {[31m
>> [39m	        return (ch === "-" || ch === "+" || this.isNumber(ch));[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.throwError = function (error, start, end) {[31m
>> [39m	        end = end || this.index;[31m
>> [39m	        var colStr = (isDefined(start)[31m
>> [39m	            ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]"[31m
>> [39m	            : " " + end);[31m
>> [39m	        throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.readNumber = function () {[31m
>> [39m	        var n = "";[31m
>> [39m	        var start = this.index;[31m
>> [39m	        while (this.index < this.text.length) {[31m
>> [39m	            var ch = lowercase(this.text.charAt(this.index));[31m
>> [39m	            if (ch === "." || this.isNumber(ch)) {[31m
>> [39m	                n += ch;[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                var peekCh = this.peek();[31m
>> [39m	                if (ch === "e" && this.isExpOperator(peekCh)) {[31m
>> [39m	                    n += ch;[31m
>> [39m	                }[31m
>> [39m	                else if (this.isExpOperator(ch) &&[31m
>> [39m	                    peekCh && this.isNumber(peekCh) &&[31m
>> [39m	                    n.charAt(n.length - 1) === "e") {[31m
>> [39m	                    n += ch;[31m
>> [39m	                }[31m
>> [39m	                else if (this.isExpOperator(ch) &&[31m
>> [39m	                    (!peekCh || !this.isNumber(peekCh)) &&[31m
>> [39m	                    n.charAt(n.length - 1) === "e") {[31m
>> [39m	                    this.throwError("Invalid exponent");[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    break;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            this.index++;[31m
>> [39m	        }[31m
>> [39m	        n = 1 * n;[31m
>> [39m	        this.tokens.push({[31m
>> [39m	            index: start,[31m
>> [39m	            text: n,[31m
>> [39m	            json: true,[31m
>> [39m	            fn: function () {[31m
>> [39m	                return n;[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.readIdent = function () {[31m
>> [39m	        var parser = this;[31m
>> [39m	        var ident = "";[31m
>> [39m	        var start = this.index;[31m
>> [39m	        var lastDot, peekIndex, methodName, ch;[31m
>> [39m	        while (this.index < this.text.length) {[31m
>> [39m	            ch = this.text.charAt(this.index);[31m
>> [39m	            if (ch === "." || this.isIdent(ch) || this.isNumber(ch)) {[31m
>> [39m	                if (ch === ".")[31m
>> [39m	                    lastDot = this.index;[31m
>> [39m	                ident += ch;[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                break;[31m
>> [39m	            }[31m
>> [39m	            this.index++;[31m
>> [39m	        }[31m
>> [39m	        //check if this is not a method invocation and if it is back out to last dot[31m
>> [39m	        if (lastDot) {[31m
>> [39m	            peekIndex = this.index;[31m
>> [39m	            while (peekIndex < this.text.length) {[31m
>> [39m	                ch = this.text.charAt(peekIndex);[31m
>> [39m	                if (ch === "(") {[31m
>> [39m	                    methodName = ident.substr(lastDot - start + 1);[31m
>> [39m	                    ident = ident.substr(0, lastDot - start);[31m
>> [39m	                    this.index = peekIndex;[31m
>> [39m	                    break;[31m
>> [39m	                }[31m
>> [39m	                if (this.isWhitespace(ch)) {[31m
>> [39m	                    peekIndex++;[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    break;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        var token = {[31m
>> [39m	            index: start,[31m
>> [39m	            text: ident[31m
>> [39m	        };[31m
>> [39m	        // OPERATORS is our own object so we don't need to use special hasOwnPropertyFn[31m
>> [39m	        if (OPERATORS.hasOwnProperty(ident)) {[31m
>> [39m	            token.fn = OPERATORS[ident];[31m
>> [39m	            token.json = OPERATORS[ident];[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            var getter = getterFn(ident, this.options, this.text);[31m
>> [39m	            token.fn = Utils_1.extend(function (self, locals) {[31m
>> [39m	                return (getter(self, locals));[31m
>> [39m	            }, {[31m
>> [39m	                assign: function (self, value, locals) {[31m
>> [39m	                    return setter(self, ident, value, parser.text, parser.options, locals);[31m
>> [39m	                }[31m
>> [39m	            });[31m
>> [39m	        }[31m
>> [39m	        this.tokens.push(token);[31m
>> [39m	        if (methodName) {[31m
>> [39m	            this.tokens.push({[31m
>> [39m	                index: lastDot,[31m
>> [39m	                text: ".",[31m
>> [39m	                json: false[31m
>> [39m	            });[31m
>> [39m	            this.tokens.push({[31m
>> [39m	                index: lastDot + 1,[31m
>> [39m	                text: methodName,[31m
>> [39m	                json: false[31m
>> [39m	            });[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Lexer.prototype.readString = function (quote) {[31m
>> [39m	        var start = this.index;[31m
>> [39m	        this.index++;[31m
>> [39m	        var value = "";[31m
>> [39m	        var rawString = quote;[31m
>> [39m	        var escape = false;[31m
>> [39m	        while (this.index < this.text.length) {[31m
>> [39m	            var ch = this.text.charAt(this.index);[31m
>> [39m	            rawString += ch;[31m
>> [39m	            if (escape) {[31m
>> [39m	                if (ch === "u") {[31m
>> [39m	                    var hex = this.text.substring(this.index + 1, this.index + 5);[31m
>> [39m	                    if (!hex.match(/[\da-f]{4}/i))[31m
>> [39m	                        this.throwError("Invalid unicode escape [\\u" + hex + "]");[31m
>> [39m	                    this.index += 4;[31m
>> [39m	                    value += String.fromCharCode(parseInt(hex, 16));[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    var rep = ESCAPE[ch];[31m
>> [39m	                    if (rep) {[31m
>> [39m	                        value += rep;[31m
>> [39m	                    }[31m
>> [39m	                    else {[31m
>> [39m	                        value += ch;[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	                escape = false;[31m
>> [39m	            }[31m
>> [39m	            else if (ch === "\\") {[31m
>> [39m	                escape = true;[31m
>> [39m	            }[31m
>> [39m	            else if (ch === quote) {[31m
>> [39m	                this.index++;[31m
>> [39m	                this.tokens.push({[31m
>> [39m	                    index: start,[31m
>> [39m	                    text: rawString,[31m
>> [39m	                    string: value,[31m
>> [39m	                    json: true,[31m
>> [39m	                    fn: function () {[31m
>> [39m	                        return value;[31m
>> [39m	                    }[31m
>> [39m	                });[31m
>> [39m	                return;[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                value += ch;[31m
>> [39m	            }[31m
>> [39m	            this.index++;[31m
>> [39m	        }[31m
>> [39m	        this.throwError("Unterminated quote", start);[31m
>> [39m	    };[31m
>> [39m	    return Lexer;[31m
>> [39m	})();[31m
>> [39m	/*[22m[31m
>> [39m	* @constructor[31m
>> [39m	[1m/[31m
>> [39m	var Parser = (function () {[31m
>> [39m	    function Parser(lexer, options) {[31m
>> [39m	        this.lexer = lexer;[31m
>> [39m	        this.options = options || { filters: {} };[31m
>> [39m	    }[31m
>> [39m	    Parser.prototype.parse = function (text) {[31m
>> [39m	        this.text = text;[31m
>> [39m	        this.tokens = this.lexer.lex(text);[31m
>> [39m	        var value = this.statements();[31m
>> [39m	        if (this.tokens.length !== 0) {[31m
>> [39m	            this.throwError("is an unexpected token", this.tokens[0]);[31m
>> [39m	        }[31m
>> [39m	        value.literal = !!value.literal;[31m
>> [39m	        value.constant = !!value.constant;[31m
>> [39m	        return value;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.primary = function () {[31m
>> [39m	        var primary;[31m
>> [39m	        if (this.expect("(")) {[31m
>> [39m	            primary = this.filterChain();[31m
>> [39m	            this.consume(")");[31m
>> [39m	        }[31m
>> [39m	        else if (this.expect("[")) {[31m
>> [39m	            primary = this.arrayDeclaration();[31m
>> [39m	        }[31m
>> [39m	        else if (this.expect("{")) {[31m
>> [39m	            primary = this.object();[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            var token = this.expect();[31m
>> [39m	            primary = token.fn;[31m
>> [39m	            if (!primary) {[31m
>> [39m	                this.throwError("not a primary expression", token);[31m
>> [39m	            }[31m
>> [39m	            if (token.json) {[31m
>> [39m	                primary.constant = true;[31m
>> [39m	                primary.literal = true;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        var next, context;[31m
>> [39m	        while ((next = this.expect("(", "[", "."))) {[31m
>> [39m	            if (next.text === "(") {[31m
>> [39m	                primary = this.functionCall(primary, context);[31m
>> [39m	                context = null;[31m
>> [39m	            }[31m
>> [39m	            else if (next.text === "[") {[31m
>> [39m	                context = primary;[31m
>> [39m	                primary = this.objectIndex(primary);[31m
>> [39m	            }[31m
>> [39m	            else if (next.text === ".") {[31m
>> [39m	                context = primary;[31m
>> [39m	                primary = this.fieldAccess(primary);[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                this.throwError("IMPOSSIBLE");[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return primary;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.throwError = function (msg, token) {[31m
>> [39m	        throw $parseMinErr("syntax", "WebRx Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.peekToken = function () {[31m
>> [39m	        if (this.tokens.length === 0)[31m
>> [39m	            throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);[31m
>> [39m	        return this.tokens[0];[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.peek = function (e1, e2, e3, e4) {[31m
>> [39m	        if (this.tokens.length > 0) {[31m
>> [39m	            var token = this.tokens[0];[31m
>> [39m	            var t = token.text;[31m
>> [39m	            if (t === e1 || t === e2 || t === e3 || t === e4 ||[31m
>> [39m	                (!e1 && !e2 && !e3 && !e4)) {[31m
>> [39m	                return token;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return false;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.expect = function (e1, e2, e3, e4) {[31m
>> [39m	        var token = this.peek(e1, e2, e3, e4);[31m
>> [39m	        if (token) {[31m
>> [39m	            this.tokens.shift();[31m
>> [39m	            return token;[31m
>> [39m	        }[31m
>> [39m	        return false;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.consume = function (e1) {[31m
>> [39m	        if (!this.expect(e1)) {[31m
>> [39m	            this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.unaryFn = function (fn, right) {[31m
>> [39m	        return Utils_1.extend(function (self, locals) {[31m
>> [39m	            return fn(self, locals, right);[31m
>> [39m	        }, {[31m
>> [39m	            constant: right.constant[31m
>> [39m	        }, true);[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.ternaryFn = function (left, middle, right) {[31m
>> [39m	        return Utils_1.extend(function (self, locals) {[31m
>> [39m	            return left(self, locals) ? middle(self, locals) : right(self, locals);[31m
>> [39m	        }, {[31m
>> [39m	            constant: left.constant && middle.constant && right.constant[31m
>> [39m	        }, true);[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.binaryFn = function (left, fn, right) {[31m
>> [39m	        return Utils_1.extend(function (self, locals) {[31m
>> [39m	            return fn(self, locals, left, right);[31m
>> [39m	        }, {[31m
>> [39m	            constant: left.constant && right.constant[31m
>> [39m	        }, true);[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.statements = function () {[31m
>> [39m	        var statements = [];[31m
>> [39m	        while (true) {[31m
>> [39m	            if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]"))[31m
>> [39m	                statements.push(this.filterChain());[31m
>> [39m	            if (!this.expect(";")) {[31m
>> [39m	                // optimize for the common case where there is only one statement.[31m
>> [39m	                // TODO(size): maybe we should not support multiple statements?[31m
>> [39m	                return (statements.length === 1)[31m
>> [39m	                    ? statements[0] :[31m
>> [39m	                    function (self, locals) {[31m
>> [39m	                        var value;[31m
>> [39m	                        for (var i = 0; i < statements.length; i++) {[31m
>> [39m	                            var statement = statements[i];[31m
>> [39m	                            if (statement) {[31m
>> [39m	                                value = statement(self, locals);[31m
>> [39m	                            }[31m
>> [39m	                        }[31m
>> [39m	                        return value;[31m
>> [39m	                    };[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.filterChain = function () {[31m
>> [39m	        var left = this.expression();[31m
>> [39m	        var token;[31m
>> [39m	        while (true) {[31m
>> [39m	            if ((token = this.expect("|"))) {[31m
>> [39m	                left = this.binaryFn(left, token.fn, this.filter());[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                return left;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.filter = function () {[31m
>> [39m	        var token = this.expect();[31m
>> [39m	        var fn = this.options.filters[token.text];[31m
>> [39m	        var argsFn = [];[31m
>> [39m	        while (true) {[31m
>> [39m	            if ((token = this.expect(":"))) {[31m
>> [39m	                argsFn.push(this.expression());[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                var fnInvoke = function (self, locals, input) {[31m
>> [39m	                    var args = [input];[31m
>> [39m	                    for (var i = 0; i < argsFn.length; i++) {[31m
>> [39m	                        args.push(argsFn[i](self, locals));[31m
>> [39m	                    }[31m
>> [39m	                    return fn.apply(self, args);[31m
>> [39m	                };[31m
>> [39m	                return function () {[31m
>> [39m	                    return fnInvoke;[31m
>> [39m	                };[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.expression = function () {[31m
>> [39m	        return this.assignment();[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.assignment = function () {[31m
>> [39m	        var left = this.ternary();[31m
>> [39m	        var right;[31m
>> [39m	        var token;[31m
>> [39m	        if ((token = this.expect("="))) {[31m
>> [39m	            if (!left.assign) {[31m
>> [39m	                this.throwError("implies assignment but [" +[31m
>> [39m	                    this.text.substring(0, token.index) + "] can not be assigned to", token);[31m
>> [39m	            }[31m
>> [39m	            right = this.ternary();[31m
>> [39m	            return function (scope, locals) {[31m
>> [39m	                return left.assign(scope, right(scope, locals), locals);[31m
>> [39m	            };[31m
>> [39m	        }[31m
>> [39m	        return left;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.ternary = function () {[31m
>> [39m	        var left = this.logicalOR();[31m
>> [39m	        var middle;[31m
>> [39m	        var token;[31m
>> [39m	        if ((token = this.expect("?"))) {[31m
>> [39m	            middle = this.ternary();[31m
>> [39m	            if ((token = this.expect(":"))) {[31m
>> [39m	                return this.ternaryFn(left, middle, this.ternary());[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                this.throwError("expected :", token);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return left;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.logicalOR = function () {[31m
>> [39m	        var left = this.logicalAND();[31m
>> [39m	        var token;[31m
>> [39m	        while (true) {[31m
>> [39m	            if ((token = this.expect("||"))) {[31m
>> [39m	                left = this.binaryFn(left, token.fn, this.logicalAND());[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                return left;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.logicalAND = function () {[31m
>> [39m	        var left = this.equality();[31m
>> [39m	        var token;[31m
>> [39m	        if ((token = this.expect("&&"))) {[31m
>> [39m	            left = this.binaryFn(left, token.fn, this.logicalAND());[31m
>> [39m	        }[31m
>> [39m	        return left;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.equality = function () {[31m
>> [39m	        var left = this.relational();[31m
>> [39m	        var token;[31m
>> [39m	        if ((token = this.expect("==", "!=", "===", "!=="))) {[31m
>> [39m	            left = this.binaryFn(left, token.fn, this.equality());[31m
>> [39m	        }[31m
>> [39m	        return left;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.relational = function () {[31m
>> [39m	        var left = this.additive();[31m
>> [39m	        var token;[31m
>> [39m	        if ((token = this.expect("<", ">", "<=", ">="))) {[31m
>> [39m	            left = this.binaryFn(left, token.fn, this.relational());[31m
>> [39m	        }[31m
>> [39m	        return left;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.additive = function () {[31m
>> [39m	        var left = this.multiplicative();[31m
>> [39m	        var token;[31m
>> [39m	        while ((token = this.expect("+", "-"))) {[31m
>> [39m	            left = this.binaryFn(left, token.fn, this.multiplicative());[31m
>> [39m	        }[31m
>> [39m	        return left;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.multiplicative = function () {[31m
>> [39m	        var left = this.unary();[31m
>> [39m	        var token;[31m
>> [39m	        while ((token = this.expect("*", "/", "%"))) {[31m
>> [39m	            left = this.binaryFn(left, token.fn, this.unary());[31m
>> [39m	        }[31m
>> [39m	        return left;[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.unary = function () {[31m
>> [39m	        var token;[31m
>> [39m	        if (this.expect("+")) {[31m
>> [39m	            return this.primary();[31m
>> [39m	        }[31m
>> [39m	        else if ((token = this.expect("-"))) {[31m
>> [39m	            return this.binaryFn(ZERO, token.fn, this.unary());[31m
>> [39m	        }[31m
>> [39m	        else if ((token = this.expect("!"))) {[31m
>> [39m	            return this.unaryFn(token.fn, this.unary());[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            return this.primary();[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.fieldAccess = function (object) {[31m
>> [39m	        var parser = this;[31m
>> [39m	        var field = this.expect().text;[31m
>> [39m	        var getter = getterFn(field, this.options, this.text);[31m
>> [39m	        return Utils_1.extend(function (scope, locals, self) {[31m
>> [39m	            return getter(self || object(scope, locals));[31m
>> [39m	        }, {[31m
>> [39m	            assign: function (scope, value, locals) {[31m
>> [39m	                return setter(object(scope, locals), field, value, parser.text, parser.options, locals);[31m
>> [39m	            }[31m
>> [39m	        }, true);[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.objectIndex = function (obj) {[31m
>> [39m	        var parser = this;[31m
>> [39m	        var indexFn = this.expression();[31m
>> [39m	        this.consume("]");[31m
>> [39m	        return Utils_1.extend(function (self, locals) {[31m
>> [39m	            var o = obj(self, locals), i = indexFn(self, locals), v, p;[31m
>> [39m	            if (!o)[31m
>> [39m	                return undefined;[31m
>> [39m	            var hooks = getRuntimeHooks(locals);[31m
>> [39m	            if (hooks && hooks.readIndexHook)[31m
>> [39m	                v = hooks.readIndexHook(o, i);[31m
>> [39m	            else[31m
>> [39m	                v = o[i];[31m
>> [39m	            v = ensureSafeObject(v, parser.text);[31m
>> [39m	            return v;[31m
>> [39m	        }, {[31m
>> [39m	            assign: function (self, value, locals) {[31m
>> [39m	                var key = indexFn(self, locals);[31m
>> [39m	                // prevent overwriting of Function.constructor which would break ensureSafeObject check[31m
>> [39m	                var safe = ensureSafeObject(obj(self, locals), parser.text);[31m
>> [39m	                var hooks = getRuntimeHooks(locals);[31m
>> [39m	                if (hooks && hooks.writeIndexHook)[31m
>> [39m	                    return hooks.writeIndexHook(safe, key, value);[31m
>> [39m	                return safe[key] = value;[31m
>> [39m	            }[31m
>> [39m	        }, true);[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.functionCall = function (fn, contextGetter) {[31m
>> [39m	        if (this.options.disallowFunctionCalls)[31m
>> [39m	            this.throwError("Function calls are not allowed");[31m
>> [39m	        var argsFn = [];[31m
>> [39m	        if (this.peekToken().text !== ")") {[31m
>> [39m	            do {[31m
>> [39m	                argsFn.push(this.expression());[31m
>> [39m	            } while (this.expect(","));[31m
>> [39m	        }[31m
>> [39m	        this.consume(")");[31m
>> [39m	        var parser = this;[31m
>> [39m	        return function (scope, locals) {[31m
>> [39m	            var args = [];[31m
>> [39m	            var context = contextGetter ? contextGetter(scope, locals) : scope;[31m
>> [39m	            for (var i = 0; i < argsFn.length; i++) {[31m
>> [39m	                args.push(argsFn[i](scope, locals));[31m
>> [39m	            }[31m
>> [39m	            var fnPtr = fn(scope, locals, context) || Utils_1.noop;[31m
>> [39m	            ensureSafeObject(context, parser.text);[31m
>> [39m	            ensureSafeObject(fnPtr, parser.text);[31m
>> [39m	            // IE stupidity! (IE doesn't have apply for some native functions)[31m
>> [39m	            var v = fnPtr.apply[31m
>> [39m	                ? fnPtr.apply(context, args)[31m
>> [39m	                : fnPtr(args[0], args[1], args[2], args[3], args[4]);[31m
>> [39m	            return ensureSafeObject(v, parser.text);[31m
>> [39m	        };[31m
>> [39m	    };[31m
>> [39m	    // This is used with json array declaration[31m
>> [39m	    Parser.prototype.arrayDeclaration = function () {[31m
>> [39m	        var elementFns = [];[31m
>> [39m	        var allConstant = true;[31m
>> [39m	        if (this.peekToken().text !== "]") {[31m
>> [39m	            do {[31m
>> [39m	                if (this.peek("]")) {[31m
>> [39m	                    // Support trailing commas per ES5.1.[31m
>> [39m	                    break;[31m
>> [39m	                }[31m
>> [39m	                var elementFn = this.expression();[31m
>> [39m	                elementFns.push(elementFn);[31m
>> [39m	                if (!elementFn.constant) {[31m
>> [39m	                    allConstant = false;[31m
>> [39m	                }[31m
>> [39m	            } while (this.expect(","));[31m
>> [39m	        }[31m
>> [39m	        this.consume("]");[31m
>> [39m	        return Utils_1.extend(function (self, locals) {[31m
>> [39m	            var array = [];[31m
>> [39m	            for (var i = 0; i < elementFns.length; i++) {[31m
>> [39m	                array.push(elementFns[i](self, locals));[31m
>> [39m	            }[31m
>> [39m	            return array;[31m
>> [39m	        }, {[31m
>> [39m	            literal: true,[31m
>> [39m	            constant: allConstant[31m
>> [39m	        }, true);[31m
>> [39m	    };[31m
>> [39m	    Parser.prototype.object = function () {[31m
>> [39m	        var keyValues = [];[31m
>> [39m	        var allConstant = true;[31m
>> [39m	        if (this.peekToken().text !== "}") {[31m
>> [39m	            do {[31m
>> [39m	                if (this.peek("}")) {[31m
>> [39m	                    // Support trailing commas per ES5.1.[31m
>> [39m	                    break;[31m
>> [39m	                }[31m
>> [39m	                var token = this.expect(), key = token.string || token.text;[31m
>> [39m	                this.consume(":");[31m
>> [39m	                var value = this.expression();[31m
>> [39m	                keyValues.push({ key: key, value: value });[31m
>> [39m	                if (!value.constant) {[31m
>> [39m	                    allConstant = false;[31m
>> [39m	                }[31m
>> [39m	            } while (this.expect(","));[31m
>> [39m	        }[31m
>> [39m	        this.consume("}");[31m
>> [39m	        return Utils_1.extend(function (self, locals) {[31m
>> [39m	            var object = {};[31m
>> [39m	            for (var i = 0; i < keyValues.length; i++) {[31m
>> [39m	                var keyValue = keyValues[i];[31m
>> [39m	                object[keyValue.key] = keyValue.value(self, locals);[31m
>> [39m	            }[31m
>> [39m	            return object;[31m
>> [39m	        }, {[31m
>> [39m	            literal: true,[31m
>> [39m	            constant: allConstant[31m
>> [39m	        }, true);[31m
>> [39m	    };[31m
>> [39m	    return Parser;[31m
>> [39m	})();[31m
>> [39m	function ZERO() { return 0; }[31m
>> [39m	;[31m
>> [39m	//////////////////////////////////////////////////[31m
>> [39m	// Parser helper functions[31m
>> [39m	//////////////////////////////////////////////////[31m
>> [39m	function setter(obj, path, setValue, fullExp, options, locals) {[31m
>> [39m	    var element = path.split("."), key;[31m
>> [39m	    var i;[31m
>> [39m	    var propertyObj;[31m
>> [39m	    var hooks = getRuntimeHooks(locals);[31m
>> [39m	    if (hooks) {[31m
>> [39m	        for (var i_1 = 0; element.length > 1; i_1++) {[31m
>> [39m	            key = ensureSafeMemberName(element.shift(), fullExp);[31m
>> [39m	            propertyObj = hooks.readFieldHook ?[31m
>> [39m	                hooks.readFieldHook(obj, key) :[31m
>> [39m	                obj[key];[31m
>> [39m	            if (!propertyObj) {[31m
>> [39m	                propertyObj = {};[31m
>> [39m	                if (hooks.writeFieldHook)[31m
>> [39m	                    hooks.writeFieldHook(obj, key, propertyObj);[31m
>> [39m	                else[31m
>> [39m	                    obj[key] = propertyObj;[31m
>> [39m	            }[31m
>> [39m	            obj = propertyObj;[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    else {[31m
>> [39m	        for (var i_2 = 0; element.length > 1; i_2++) {[31m
>> [39m	            key = ensureSafeMemberName(element.shift(), fullExp);[31m
>> [39m	            propertyObj = obj[key];[31m
>> [39m	            if (!propertyObj) {[31m
>> [39m	                propertyObj = {};[31m
>> [39m	                obj[key] = propertyObj;[31m
>> [39m	            }[31m
>> [39m	            obj = propertyObj;[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    key = ensureSafeMemberName(element.shift(), fullExp);[31m
>> [39m	    if (hooks && hooks.writeFieldHook)[31m
>> [39m	        hooks.writeFieldHook(obj, key, setValue);[31m
>> [39m	    else[31m
>> [39m	        obj[key] = setValue;[31m
>> [39m	    return setValue;[31m
>> [39m	}[31m
>> [39m	var getterFnCache = {};[31m
>> [39m	/*[22m[31m
>> [39m	* Implementation of the "Black Hole" variant from:[31m
>> [39m	* - http://jsperf.com/angularjs-parse-getter/4[31m
>> [39m	* - http://jsperf.com/path-evaluation-simplified/7[31m
>> [39m	[1m/[31m
>> [39m	function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {[31m
>> [39m	    ensureSafeMemberName(key0, fullExp);[31m
>> [39m	    ensureSafeMemberName(key1, fullExp);[31m
>> [39m	    ensureSafeMemberName(key2, fullExp);[31m
>> [39m	    ensureSafeMemberName(key3, fullExp);[31m
>> [39m	    ensureSafeMemberName(key4, fullExp);[31m
>> [39m	    return function (scope, locals) {[31m
>> [39m	        var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope;[31m
>> [39m	        var hooks = getRuntimeHooks(locals);[31m
>> [39m	        if (hooks && hooks.readFieldHook) {[31m
>> [39m	            if (pathVal == null)[31m
>> [39m	                return pathVal;[31m
>> [39m	            pathVal = hooks.readFieldHook(pathVal, key0);[31m
>> [39m	            if (!key1)[31m
>> [39m	                return pathVal;[31m
>> [39m	            if (pathVal == null)[31m
>> [39m	                return undefined;[31m
>> [39m	            pathVal = hooks.readFieldHook(pathVal, key1);[31m
>> [39m	            if (!key2)[31m
>> [39m	                return pathVal;[31m
>> [39m	            if (pathVal == null)[31m
>> [39m	                return undefined;[31m
>> [39m	            pathVal = hooks.readFieldHook(pathVal, key2);[31m
>> [39m	            if (!key3)[31m
>> [39m	                return pathVal;[31m
>> [39m	            if (pathVal == null)[31m
>> [39m	                return undefined;[31m
>> [39m	            pathVal = hooks.readFieldHook(pathVal, key3);[31m
>> [39m	            if (!key4)[31m
>> [39m	                return pathVal;[31m
>> [39m	            if (pathVal == null)[31m
>> [39m	                return undefined;[31m
>> [39m	            pathVal = hooks.readFieldHook(pathVal, key4);[31m
>> [39m	            return pathVal;[31m
>> [39m	        }[31m
>> [39m	        if (pathVal == null)[31m
>> [39m	            return pathVal;[31m
>> [39m	        pathVal = pathVal[key0];[31m
>> [39m	        if (!key1)[31m
>> [39m	            return pathVal;[31m
>> [39m	        if (pathVal == null)[31m
>> [39m	            return undefined;[31m
>> [39m	        pathVal = pathVal[key1];[31m
>> [39m	        if (!key2)[31m
>> [39m	            return pathVal;[31m
>> [39m	        if (pathVal == null)[31m
>> [39m	            return undefined;[31m
>> [39m	        pathVal = pathVal[key2];[31m
>> [39m	        if (!key3)[31m
>> [39m	            return pathVal;[31m
>> [39m	        if (pathVal == null)[31m
>> [39m	            return undefined;[31m
>> [39m	        pathVal = pathVal[key3];[31m
>> [39m	        if (!key4)[31m
>> [39m	            return pathVal;[31m
>> [39m	        if (pathVal == null)[31m
>> [39m	            return undefined;[31m
>> [39m	        pathVal = pathVal[key4];[31m
>> [39m	        return pathVal;[31m
>> [39m	    };[31m
>> [39m	}[31m
>> [39m	function simpleGetterFn1(key0, fullExp) {[31m
>> [39m	    ensureSafeMemberName(key0, fullExp);[31m
>> [39m	    return function (scope, locals) {[31m
>> [39m	        scope = ((locals && locals.hasOwnProperty(key0)) ? locals : scope);[31m
>> [39m	        if (scope == null)[31m
>> [39m	            return undefined;[31m
>> [39m	        var hooks = getRuntimeHooks(locals);[31m
>> [39m	        if (hooks && hooks.readFieldHook)[31m
>> [39m	            return hooks.readFieldHook(scope, key0);[31m
>> [39m	        return scope[key0];[31m
>> [39m	    };[31m
>> [39m	}[31m
>> [39m	function simpleGetterFn2(key0, key1, fullExp) {[31m
>> [39m	    ensureSafeMemberName(key0, fullExp);[31m
>> [39m	    ensureSafeMemberName(key1, fullExp);[31m
>> [39m	    return function (scope, locals) {[31m
>> [39m	        var hooks = getRuntimeHooks(locals);[31m
>> [39m	        if (hooks && hooks.readFieldHook) {[31m
>> [39m	            scope = (locals && locals.hasOwnProperty(key0)) ? locals : scope;[31m
>> [39m	            if (scope == null)[31m
>> [39m	                return undefined;[31m
>> [39m	            scope = hooks.readFieldHook(scope, key0);[31m
>> [39m	            return scope == null ? undefined : hooks.readFieldHook(scope, key1);[31m
>> [39m	        }[31m
>> [39m	        scope = ((locals && locals.hasOwnProperty(key0)) ? locals : scope)[key0];[31m
>> [39m	        return scope == null ? undefined : scope[key1];[31m
>> [39m	    };[31m
>> [39m	}[31m
>> [39m	function getterFn(path, options, fullExp) {[31m
>> [39m	    // Check whether the cache has this getter already.[31m
>> [39m	    // We can use hasOwnProperty directly on the cache because we ensure,[31m
>> [39m	    // see below, that the cache never stores a path called 'hasOwnProperty'[31m
>> [39m	    if (getterFnCache.hasOwnProperty(path)) {[31m
>> [39m	        return getterFnCache[path];[31m
>> [39m	    }[31m
>> [39m	    var pathKeys = path.split("."), pathKeysLength = pathKeys.length, fn;[31m
>> [39m	    // When we have only 1 or 2 tokens, use optimized special case closures.[31m
>> [39m	    // http://jsperf.com/angularjs-parse-getter/6[31m
>> [39m	    if (pathKeysLength === 1) {[31m
>> [39m	        fn = simpleGetterFn1(pathKeys[0], fullExp);[31m
>> [39m	    }[31m
>> [39m	    else if (pathKeysLength === 2) {[31m
>> [39m	        fn = simpleGetterFn2(pathKeys[0], pathKeys[1], fullExp);[31m
>> [39m	    }[31m
>> [39m	    else {[31m
>> [39m	        if (pathKeysLength < 6) {[31m
>> [39m	            fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, options);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            fn = function (scope, locals) {[31m
>> [39m	                // backup locals[31m
>> [39m	                var _locals = {};[31m
>> [39m	                Object.keys(locals).forEach(function (x) { return _locals[x] = locals[x]; });[31m
>> [39m	                var i = 0, val;[31m
>> [39m	                do {[31m
>> [39m	                    val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, options)(scope, locals);[31m
>> [39m	                    scope = val;[31m
>> [39m	                    // reset locals[31m
>> [39m	                    locals = {};[31m
>> [39m	                    Object.keys(_locals).forEach(function (x) { return locals[x] = _locals[x]; });[31m
>> [39m	                } while (i < pathKeysLength);[31m
>> [39m	                return val;[31m
>> [39m	            };[31m
>> [39m	        }[31m
>> [39m	    } /[22m else {[31m
>> [39m	    let code = "var p;\n";[31m
>> [39m	    forEach(pathKeys, (key, index) => {[31m
>> [39m	        ensureSafeMemberName(key, fullExp);[31m
>> [39m	        code += "if(s == null) return undefined;\n" +[31m
>> [39m	            "s=" + (index[31m
>> [39m	                // we simply dereference 's' on any .dot notation[31m
>> [39m	                ? "s"[31m
>> [39m	                // but if we are first then we check locals first, and if so read it first[31m
>> [39m	                : "((k&&k.hasOwnProperty(\"" + key + "\"))?k:s)") + "[\"" + key + "\"]" + ";\n";[31m
>> [39m	    });[31m
>> [39m	    code += "return s;";[31m
>> [39m	[31m
>> [39m	    // jshint -W054[31m
>> [39m	    let evaledFnGetter = new Function("s", "k", "pw", code); // s=scope, k=locals, pw=promiseWarning[31m
>> [39m	    // jshint +W054 /[31m
>> [39m	    evaledFnGetter.toString = valueFn(code);[31m
>> [39m	    fn = <(scope: any, locals?: any, self?: any) => any> evaledFnGetter;[31m
>> [39m	} [1m/[31m
>> [39m	    // Only cache the value if it's not going to mess up the cache object[31m
>> [39m	    // This is more performant that using Object.prototype.hasOwnProperty.call[31m
>> [39m	    if (path !== "hasOwnProperty") {[31m
>> [39m	        getterFnCache[path] = fn;[31m
>> [39m	    }[31m
>> [39m	    return fn;[31m
>> [39m	}[31m
>> [39m	function getRuntimeHooks(locals) {[31m
>> [39m	    return locals !== undefined ? locals[hookField] : undefined;[31m
>> [39m	}[31m
>> [39m	exports.getRuntimeHooks = getRuntimeHooks;[31m
>> [39m	function setRuntimeHooks(locals, hooks) {[31m
>> [39m	    locals[hookField] = hooks;[31m
>> [39m	}[31m
>> [39m	exports.setRuntimeHooks = setRuntimeHooks;[31m
>> [39m	/*[22m[31m
>> [39m	 * Compiles src and returns a function that executes src on a target object.[31m
>> [39m	 * The compiled function is cached under compile.cache[src] to speed up further calls.[31m
>> [39m	 *[31m
>> [39m	 * @param {string} src[31m
>> [39m	 * @returns {function}[31m
>> [39m	 [1m/[31m
>> [39m	function compileExpression(src, options, cache) {[31m
>> [39m	    if (typeof src !== "string") {[31m
>> [39m	        throw new TypeError("src must be a string, instead saw '" + typeof src + "'");[31m
>> [39m	    }[31m
>> [39m	    var lexer = new Lexer({});[31m
>> [39m	    var parser = new Parser(lexer, options);[31m
>> [39m	    if (!cache) {[31m
>> [39m	        return parser.parse(src);[31m
>> [39m	    }[31m
>> [39m	    var cached = cache[src];[31m
>> [39m	    if (!cached) {[31m
>> [39m	        cached = cache[src] = parser.parse(src);[31m
>> [39m	    }[31m
>> [39m	    return cached;[31m
>> [39m	}[31m
>> [39m	exports.compileExpression = compileExpression;[31m
>> [39m	//# sourceMappingURL=ExpressionCompiler.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 15 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var WeakMap_1 = __webpack_require__(4);[31m
>> [39m	var Set_1 = __webpack_require__(6);[31m
>> [39m	var IID_1 = __webpack_require__(9);[31m
>> [39m	var Injector_1 = __webpack_require__(1);[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var res = __webpack_require__(10);[31m
>> [39m	var env = __webpack_require__(16);[31m
>> [39m	"use strict";[31m
>> [39m	var DomManager = (function () {[31m
>> [39m	    function DomManager(compiler, app) {[31m
>> [39m	        this.expressionCache = {};[31m
>> [39m	        this.dataContextExtensions = Set_1.createSet();[31m
>> [39m	        this.parserOptions = {[31m
>> [39m	            disallowFunctionCalls: true[31m
>> [39m	        };[31m
>> [39m	        this.nodeState = WeakMap_1.createWeakMap();[31m
>> [39m	        this.compiler = compiler;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    DomManager.prototype.applyBindings = function (model, rootNode) {[31m
>> [39m	        if (rootNode === undefined || rootNode.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("first parameter should be your model, second parameter should be a DOM node!");[31m
>> [39m	        if (this.isNodeBound(rootNode))[31m
>> [39m	            Utils_1.throwError("an element must not be bound multiple times!");[31m
>> [39m	        // create or update node state for root node[31m
>> [39m	        var state = this.getNodeState(rootNode);[31m
>> [39m	        if (state) {[31m
>> [39m	            state.model = model;[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            state = this.createNodeState(model);[31m
>> [39m	            this.setNodeState(rootNode, state);[31m
>> [39m	        }[31m
>> [39m	        // calculate resulting data-context and apply bindings[31m
>> [39m	        var ctx = this.getDataContext(rootNode);[31m
>> [39m	        this.applyBindingsRecursive(ctx, rootNode);[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.applyBindingsToDescendants = function (ctx, node) {[31m
>> [39m	        if (node.hasChildNodes()) {[31m
>> [39m	            for (var i = 0; i < node.childNodes.length; i++) {[31m
>> [39m	                var child = node.childNodes[i];[31m
>> [39m	                // only elements[31m
>> [39m	                if (child.nodeType !== 1)[31m
>> [39m	                    continue;[31m
>> [39m	                this.applyBindingsRecursive(ctx, child);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.cleanNode = function (rootNode) {[31m
>> [39m	        if (rootNode.nodeType !== 1)[31m
>> [39m	            return;[31m
>> [39m	        this.cleanNodeRecursive(rootNode);[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.cleanDescendants = function (node) {[31m
>> [39m	        if (node.hasChildNodes()) {[31m
>> [39m	            for (var i = 0; i < node.childNodes.length; i++) {[31m
>> [39m	                var child = node.childNodes[i];[31m
>> [39m	                // only elements[31m
>> [39m	                if (node.nodeType !== 1)[31m
>> [39m	                    continue;[31m
>> [39m	                this.clearNodeState(child);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.getObjectLiteralTokens = function (value) {[31m
>> [39m	        value = value.trim();[31m
>> [39m	        if (value !== '' && this.isObjectLiteralString(value)) {[31m
>> [39m	            return this.compiler.parseObjectLiteral(value);[31m
>> [39m	        }[31m
>> [39m	        return [];[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.compileBindingOptions = function (value, module) {[31m
>> [39m	        value = value.trim();[31m
>> [39m	        if (value === '') {[31m
>> [39m	            return null;[31m
>> [39m	        }[31m
>> [39m	        if (this.isObjectLiteralString(value)) {[31m
>> [39m	            var result = {};[31m
>> [39m	            var tokens = this.compiler.parseObjectLiteral(value);[31m
>> [39m	            var token;[31m
>> [39m	            for (var i = 0; i < tokens.length; i++) {[31m
>> [39m	                token = tokens[i];[31m
>> [39m	                result[token.key] = this.compileBindingOptions(token.value, module);[31m
>> [39m	            }[31m
>> [39m	            return result;[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // build compiler options[31m
>> [39m	            var options = Utils_1.extend(this.parserOptions, {});[31m
>> [39m	            options.filters = {};[31m
>> [39m	            // enrich with app filters[31m
>> [39m	            Utils_1.extend(this.app.filters(), options.filters);[31m
>> [39m	            // enrich with module filters[31m
>> [39m	            if (module) {[31m
>> [39m	                Utils_1.extend(module.filters(), options.filters);[31m
>> [39m	            }[31m
>> [39m	            return this.compiler.compileExpression(value, options, this.expressionCache);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.getModuleContext = function (node) {[31m
>> [39m	        var state;[31m
>> [39m	        // collect model hierarchy[31m
>> [39m	        while (node) {[31m
>> [39m	            state = this.getNodeState(node);[31m
>> [39m	            if (state != null) {[31m
>> [39m	                if (state.module != null) {[31m
>> [39m	                    return state.module;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            node = node.parentNode;[31m
>> [39m	        }[31m
>> [39m	        // default to app[31m
>> [39m	        return this.app;[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.registerDataContextExtension = function (extension) {[31m
>> [39m	        this.dataContextExtensions.add(extension);[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.getDataContext = function (node) {[31m
>> [39m	        var models = [];[31m
>> [39m	        var state = this.getNodeState(node);[31m
>> [39m	        // collect model hierarchy[31m
>> [39m	        var _node = node;[31m
>> [39m	        while (_node) {[31m
>> [39m	            state = state != null ? state : this.getNodeState(_node);[31m
>> [39m	            if (state != null) {[31m
>> [39m	                if (state.model != null) {[31m
>> [39m	                    models.push(state.model);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            state = null;[31m
>> [39m	            _node = _node.parentNode;[31m
>> [39m	        }[31m
>> [39m	        var ctx;[31m
>> [39m	        if (models.length > 0) {[31m
>> [39m	            ctx = {[31m
>> [39m	                $data: models[0],[31m
>> [39m	                $root: models[models.length - 1],[31m
>> [39m	                $parent: models.length > 1 ? models[1] : null,[31m
>> [39m	                $parents: models.slice(1)[31m
>> [39m	            };[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            ctx = {[31m
>> [39m	                $data: null,[31m
>> [39m	                $root: null,[31m
>> [39m	                $parent: null,[31m
>> [39m	                $parents: [][31m
>> [39m	            };[31m
>> [39m	        }[31m
>> [39m	        // extensions[31m
>> [39m	        this.dataContextExtensions.forEach(function (ext) { return ext(node, ctx); });[31m
>> [39m	        return ctx;[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.createNodeState = function (model, module) {[31m
>> [39m	        return {[31m
>> [39m	            cleanup: new Rx.CompositeDisposable(),[31m
>> [39m	            model: model,[31m
>> [39m	            module: module,[31m
>> [39m	            isBound: false[31m
>> [39m	        };[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.isNodeBound = function (node) {[31m
>> [39m	        var state = this.nodeState.get(node);[31m
>> [39m	        return state && state.isBound;[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.setNodeState = function (node, state) {[31m
>> [39m	        this.nodeState.set(node, state);[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.getNodeState = function (node) {[31m
>> [39m	        return this.nodeState.get(node);[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.clearNodeState = function (node) {[31m
>> [39m	        var state = this.nodeState.get(node);[31m
>> [39m	        if (state) {[31m
>> [39m	            if (state.cleanup != null) {[31m
>> [39m	                state.cleanup.dispose();[31m
>> [39m	                state.cleanup = undefined;[31m
>> [39m	            }[31m
>> [39m	            if (state.model != null) {[31m
>> [39m	                state.model = undefined;[31m
>> [39m	            }[31m
>> [39m	            if (state.module != null) {[31m
>> [39m	                state.module = undefined;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        this.nodeState.delete(node);[31m
>> [39m	        // support external per-node cleanup[31m
>> [39m	        env.cleanExternalData(node);[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.evaluateExpression = function (exp, ctx) {[31m
>> [39m	        var locals = this.createLocals(undefined, ctx);[31m
>> [39m	        var result = exp(ctx.$data, locals);[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.expressionToObservable = function (exp, ctx, evalObs) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var captured = Set_1.createSet();[31m
>> [39m	        var locals;[31m
>> [39m	        var result;[31m
>> [39m	        // initial evaluation[31m
>> [39m	        try {[31m
>> [39m	            locals = this.createLocals(captured, ctx);[31m
>> [39m	            result = exp(ctx.$data, locals);[31m
>> [39m	            // diagnostics[31m
>> [39m	            if (evalObs)[31m
>> [39m	                evalObs.onNext(true);[31m
>> [39m	        }[31m
>> [39m	        catch (e) {[31m
>> [39m	            this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            return Rx.Observable.return(undefined);[31m
>> [39m	        }[31m
>> [39m	        // Optimization: If the initial evaluation didn't touch any observables, treat it as constant expression[31m
>> [39m	        if (captured.size === 0) {[31m
>> [39m	            if (Utils_1.isRxObservable(result))[31m
>> [39m	                return result;[31m
>> [39m	            // wrap it[31m
>> [39m	            return Rx.Observable.return(result);[31m
>> [39m	        }[31m
>> [39m	        var obs = Rx.Observable.create(function (observer) {[31m
>> [39m	            var innerDisp = Rx.Observable.defer(function () {[31m
>> [39m	                // construct observable that represents the first change of any of the expression's dependencies[31m
>> [39m	                return Rx.Observable.merge(Set_1.setToArray(captured)).take(1);[31m
>> [39m	            })[31m
>> [39m	                .repeat()[31m
>> [39m	                .subscribe(function (trigger) {[31m
>> [39m	                try {[31m
>> [39m	                    // reset execution state before evaluation[31m
>> [39m	                    captured.clear();[31m
>> [39m	                    locals = _this.createLocals(captured, ctx);[31m
>> [39m	                    // evaluate and produce next value[31m
>> [39m	                    result = exp(ctx.$data, locals);[31m
>> [39m	                    if (!Utils_1.isRxObservable(result)) {[31m
>> [39m	                        // wrap non-observable[31m
>> [39m	                        observer.onNext(Rx.Observable.return(result));[31m
>> [39m	                    }[31m
>> [39m	                    else {[31m
>> [39m	                        observer.onNext(result);[31m
>> [39m	                    }[31m
>> [39m	                    // diagnostics[31m
>> [39m	                    if (evalObs)[31m
>> [39m	                        evalObs.onNext(true);[31m
>> [39m	                }[31m
>> [39m	                catch (e) {[31m
>> [39m	                    _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                }[31m
>> [39m	            });[31m
>> [39m	            return innerDisp;[31m
>> [39m	        });[31m
>> [39m	        // prefix with initial result[31m
>> [39m	        var startValue = Utils_1.isRxObservable(result) ?[31m
>> [39m	            result :[31m
>> [39m	            Rx.Observable.return(result);[31m
>> [39m	        return obs.startWith(startValue).concatAll();[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.applyBindingsInternal = function (ctx, el, module) {[31m
>> [39m	        var result = false;[31m
>> [39m	        // get or create elment-state[31m
>> [39m	        var state = this.getNodeState(el);[31m
>> [39m	        // create and set if necessary[31m
>> [39m	        if (!state) {[31m
>> [39m	            state = this.createNodeState();[31m
>> [39m	            this.setNodeState(el, state);[31m
>> [39m	        }[31m
>> [39m	        else if (state.isBound) {[31m
>> [39m	            Utils_1.throwError("an element must not be bound multiple times!");[31m
>> [39m	        }[31m
>> [39m	        var _bindings;[31m
>> [39m	        var tagName = el.tagName.toLowerCase();[31m
>> [39m	        // check if tag represents a component[31m
>> [39m	        if (module.hasComponent(tagName) || this.app.hasComponent(tagName)) {[31m
>> [39m	            // when a component is referenced by element, we just apply a virtual 'component' binding[31m
>> [39m	            var params = el.getAttribute(DomManager.paramsAttributename);[31m
>> [39m	            var componentReference;[31m
>> [39m	            if (params)[31m
>> [39m	                componentReference = "{ name: '" + tagName + "', params: {" + el.getAttribute(DomManager.paramsAttributename) + "} }";[31m
>> [39m	            else[31m
>> [39m	                componentReference = "{ name: '" + tagName + "' }";[31m
>> [39m	            _bindings = [{ key: 'component', value: componentReference }];[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // get definitions from attribute[31m
>> [39m	            _bindings = this.getBindingDefinitions(el);[31m
>> [39m	        }[31m
>> [39m	        if (_bindings != null && _bindings.length > 0) {[31m
>> [39m	            // lookup handlers[31m
>> [39m	            var bindings = _bindings.map(function (x) {[31m
>> [39m	                var handler = module.binding(x.key);[31m
>> [39m	                if (!handler)[31m
>> [39m	                    Utils_1.throwError("binding '{0}' has not been registered.", x.key);[31m
>> [39m	                return { handler: handler, value: x.value };[31m
>> [39m	            });[31m
>> [39m	            // sort by priority[31m
>> [39m	            bindings.sort(function (a, b) { return (b.handler.priority || 0) - (a.handler.priority || 0); });[31m
>> [39m	            // check if there's binding-handler competition for descendants (which is illegal)[31m
>> [39m	            var hd = bindings.filter(function (x) { return x.handler.controlsDescendants; }).map(function (x) { return "'" + x.value + "'"; });[31m
>> [39m	            if (hd.length > 1) {[31m
>> [39m	                Utils_1.throwError("bindings {0} are competing for descendants of target element!", hd.join(", "));[31m
>> [39m	            }[31m
>> [39m	            result = hd.length > 0;[31m
>> [39m	            // apply all bindings[31m
>> [39m	            for (var i = 0; i < bindings.length; i++) {[31m
>> [39m	                var binding = bindings[i];[31m
>> [39m	                var handler = binding.handler;[31m
>> [39m	                handler.applyBinding(el, binding.value, ctx, state, module);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // mark bound[31m
>> [39m	        state.isBound = true;[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.isObjectLiteralString = function (str) {[31m
>> [39m	        return str[0] === "{" && str[str.length - 1] === "}";[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.getBindingDefinitions = function (node) {[31m
>> [39m	        var bindingText = null;[31m
>> [39m	        if (node.nodeType === 1) {[31m
>> [39m	            // attempt to get definition from attribute[31m
>> [39m	            var attr = node.getAttribute(DomManager.bindingAttributeName);[31m
>> [39m	            if (attr) {[31m
>> [39m	                bindingText = attr;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // transform textual binding-definition into a key-value store where [31m
>> [39m	        // the key is the binding name and the value is its options[31m
>> [39m	        if (bindingText) {[31m
>> [39m	            bindingText = bindingText.trim();[31m
>> [39m	        }[31m
>> [39m	        if (bindingText)[31m
>> [39m	            return this.compiler.parseObjectLiteral(bindingText);[31m
>> [39m	        return null;[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.applyBindingsRecursive = function (ctx, el, module) {[31m
>> [39m	        // "module" binding receiving first-class treatment here because it is considered part of the core[31m
>> [39m	        module = module || this.getModuleContext(el);[31m
>> [39m	        if (!this.applyBindingsInternal(ctx, el, module) && el.hasChildNodes()) {[31m
>> [39m	            // module binding might have updated state.module[31m
>> [39m	            var state = this.getNodeState(el);[31m
>> [39m	            if (state && state.module)[31m
>> [39m	                module = state.module;[31m
>> [39m	            // iterate over descendants[31m
>> [39m	            for (var i = 0; i < el.childNodes.length; i++) {[31m
>> [39m	                var child = el.childNodes[i];[31m
>> [39m	                // only elements[31m
>> [39m	                if (child.nodeType !== 1)[31m
>> [39m	                    continue;[31m
>> [39m	                this.applyBindingsRecursive(ctx, child, module);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.cleanNodeRecursive = function (node) {[31m
>> [39m	        if (node.hasChildNodes()) {[31m
>> [39m	            var length_1 = node.childNodes.length;[31m
>> [39m	            for (var i = 0; i < length_1; i++) {[31m
>> [39m	                var child = node.childNodes[i];[31m
>> [39m	                // only elements[31m
>> [39m	                if (node.nodeType !== 1)[31m
>> [39m	                    continue;[31m
>> [39m	                this.cleanNodeRecursive(child);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // clear parent after childs[31m
>> [39m	        this.clearNodeState(node);[31m
>> [39m	    };[31m
>> [39m	    DomManager.prototype.createLocals = function (captured, ctx) {[31m
>> [39m	        var locals = {};[31m
>> [39m	        var list;[31m
>> [39m	        var prop;[31m
>> [39m	        var result, target;[31m
>> [39m	        var hooks = {[31m
>> [39m	            readFieldHook: function (o, field) {[31m
>> [39m	                // handle "@propref" access-modifier[31m
>> [39m	                var noUnwrap = false;[31m
>> [39m	                if (field[0] === '@') {[31m
>> [39m	                    noUnwrap = true;[31m
>> [39m	                    field = field.substring(1);[31m
>> [39m	                }[31m
>> [39m	                result = o[field];[31m
>> [39m	                // intercept access to observable properties[31m
>> [39m	                if (!noUnwrap && Utils_1.isProperty(result)) {[31m
>> [39m	                    var prop_1 = result;[31m
>> [39m	                    // register observable[31m
>> [39m	                    if (captured)[31m
>> [39m	                        captured.add(prop_1.changed);[31m
>> [39m	                    // get the property's real value[31m
>> [39m	                    result = prop_1();[31m
>> [39m	                }[31m
>> [39m	                return result;[31m
>> [39m	            },[31m
>> [39m	            writeFieldHook: function (o, field, newValue) {[31m
>> [39m	                // ignore @propref access-modifier on writes[31m
>> [39m	                if (field[0] === '@') {[31m
>> [39m	                    field = field.substring(1);[31m
>> [39m	                }[31m
>> [39m	                target = o[field];[31m
>> [39m	                // intercept access to observable properties[31m
>> [39m	                if (Utils_1.isProperty(target)) {[31m
>> [39m	                    var prop_2 = target;[31m
>> [39m	                    // register observable[31m
>> [39m	                    if (captured)[31m
>> [39m	                        captured.add(prop_2.changed);[31m
>> [39m	                    // replace field assignment with property invocation[31m
>> [39m	                    prop_2(newValue);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    o[field] = newValue;[31m
>> [39m	                }[31m
>> [39m	                return newValue;[31m
>> [39m	            },[31m
>> [39m	            readIndexHook: function (o, index) {[31m
>> [39m	                // recognize observable lists[31m
>> [39m	                if (Utils_1.queryInterface(o, IID_1.default.IObservableList)) {[31m
>> [39m	                    // translate indexer to list.get()[31m
>> [39m	                    list = o;[31m
>> [39m	                    result = list.get(index);[31m
>> [39m	                    // add collectionChanged to monitored observables[31m
>> [39m	                    if (captured)[31m
>> [39m	                        captured.add(list.listChanged);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    result = o[index];[31m
>> [39m	                }[31m
>> [39m	                // intercept access to observable properties[31m
>> [39m	                if (Utils_1.queryInterface(result, IID_1.default.IObservableProperty)) {[31m
>> [39m	                    var prop_3 = result;[31m
>> [39m	                    // register observable[31m
>> [39m	                    if (captured)[31m
>> [39m	                        captured.add(prop_3.changed);[31m
>> [39m	                    // get the property's real value[31m
>> [39m	                    result = prop_3();[31m
>> [39m	                }[31m
>> [39m	                return result;[31m
>> [39m	            },[31m
>> [39m	            writeIndexHook: function (o, index, newValue) {[31m
>> [39m	                // recognize observable lists[31m
>> [39m	                if (Utils_1.queryInterface(o, IID_1.default.IObservableList)) {[31m
>> [39m	                    // translate indexer to list.get()[31m
>> [39m	                    list = o;[31m
>> [39m	                    target = list.get(index);[31m
>> [39m	                    // add collectionChanged to monitored observables[31m
>> [39m	                    if (captured)[31m
>> [39m	                        captured.add(list.listChanged);[31m
>> [39m	                    // intercept access to observable properties[31m
>> [39m	                    if (Utils_1.isProperty(target)) {[31m
>> [39m	                        prop = target;[31m
>> [39m	                        // register observable[31m
>> [39m	                        if (captured)[31m
>> [39m	                            captured.add(prop.changed);[31m
>> [39m	                        // replace field assignment with property invocation[31m
>> [39m	                        prop(newValue);[31m
>> [39m	                    }[31m
>> [39m	                    else {[31m
>> [39m	                        list.set(index, newValue);[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    // intercept access to observable properties[31m
>> [39m	                    if (Utils_1.isProperty(o[index])) {[31m
>> [39m	                        prop = target[index];[31m
>> [39m	                        // register observable[31m
>> [39m	                        if (captured)[31m
>> [39m	                            captured.add(prop.changed);[31m
>> [39m	                        // replace field assignment with property invocation[31m
>> [39m	                        prop(newValue);[31m
>> [39m	                    }[31m
>> [39m	                    else {[31m
>> [39m	                        o[index] = newValue;[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	                return newValue;[31m
>> [39m	            }[31m
>> [39m	        };[31m
>> [39m	        // install property interceptor hooks[31m
>> [39m	        this.compiler.setRuntimeHooks(locals, hooks);[31m
>> [39m	        // injected context members into locals[31m
>> [39m	        var keys = Object.keys(ctx);[31m
>> [39m	        var length = keys.length;[31m
>> [39m	        for (var i = 0; i < length; i++) {[31m
>> [39m	            var key = keys[i];[31m
>> [39m	            locals[key] = ctx[key];[31m
>> [39m	        }[31m
>> [39m	        return locals;[31m
>> [39m	    };[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // Implementation[31m
>> [39m	    DomManager.bindingAttributeName = "data-bind";[31m
>> [39m	    DomManager.paramsAttributename = "params";[31m
>> [39m	    return DomManager;[31m
>> [39m	})();[31m
>> [39m	exports.DomManager = DomManager;[31m
>> [39m	/*[22m[31m
>> [39m	* Applies bindings to the specified node and all of its children using the specified data context.[31m
>> [39m	* @param {any} model The model to bind to[31m
>> [39m	* @param {Node} rootNode The node to be bound[31m
>> [39m	[1m/[31m
>> [39m	function applyBindings(model, node) {[31m
>> [39m	    Injector_1.injector.get(res.domManager).applyBindings(model, node || window.document.documentElement);[31m
>> [39m	}[31m
>> [39m	exports.applyBindings = applyBindings;[31m
>> [39m	/*[22m[31m
>> [39m	* Removes and cleans up any binding-related state from the specified node and its descendants.[31m
>> [39m	* @param {Node} rootNode The node to be cleaned[31m
>> [39m	[1m/[31m
>> [39m	function cleanNode(node) {[31m
>> [39m	    Injector_1.injector.get(res.domManager).cleanNode(node);[31m
>> [39m	}[31m
>> [39m	exports.cleanNode = cleanNode;[31m
>> [39m	//# sourceMappingURL=DomManager.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 16 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	var WeakMap_1 = __webpack_require__(4);[31m
>> [39m	"use strict";[31m
>> [39m	var _window = window;[31m
>> [39m	var userAgent = _window.navigator.userAgent;[31m
>> [39m	exports.ie;[31m
>> [39m	exports.opera;[31m
>> [39m	exports.safari;[31m
>> [39m	exports.firefox;[31m
>> [39m	var parseVersion = function (matches) {[31m
>> [39m	    if (matches) {[31m
>> [39m	        return parseFloat(matches[1]);[31m
>> [39m	    }[31m
>> [39m	    return undefined;[31m
>> [39m	};[31m
>> [39m	// Detect Opera[31m
>> [39m	if (_window.opera && _window.opera.version) {[31m
>> [39m	    exports.opera = { version: parseInt(_window.opera.version()) };[31m
>> [39m	}[31m
>> [39m	// Detect wx.IE versions for bug workarounds (uses wx.IE conditionals, not UA string, for robustness)[31m
>> [39m	// Note that, since wx.IE 10 does not support conditional comments, the following logic only detects wx.IE < 10.[31m
>> [39m	// Currently this is by design, since wx.IE 10+ behaves correctly when treated as a standard browser.[31m
>> [39m	var version = document && (function () {[31m
>> [39m	    var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');[31m
>> [39m	    // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment[31m
>> [39m	    while (div.innerHTML = '<!--[if gt wx.IE ' + (++version) + ']><i></i><![endif]-->',[31m
>> [39m	        iElems[0]) { }[31m
>> [39m	    return version > 4 ? version : undefined;[31m
>> [39m	}());[31m
>> [39m	if (version) {[31m
>> [39m	    exports.ie = { version: version };[31m
>> [39m	    if (version < 10) {[31m
>> [39m	        // for wx.IE9 and lower, provide an accessor for document scoped[31m
>> [39m	        // observables which allow monitoring the selectionchange event[31m
>> [39m	        var map = WeakMap_1.createWeakMap();[31m
>> [39m	        exports.ie.getSelectionChangeObservable = function (el) {[31m
>> [39m	            var doc = el.ownerDocument;[31m
>> [39m	            var result = map.get(doc);[31m
>> [39m	            if (result)[31m
>> [39m	                return result;[31m
>> [39m	            result = Rx.Observable.defer(function () {[31m
>> [39m	                return Rx.Observable.fromEvent(doc, 'selectionchange');[31m
>> [39m	            })[31m
>> [39m	                .select(function (x) { return doc; })[31m
>> [39m	                .publish()[31m
>> [39m	                .refCount();[31m
>> [39m	            map.set(doc, result);[31m
>> [39m	            return result;[31m
>> [39m	        };[31m
>> [39m	    }[31m
>> [39m	}[31m
>> [39m	// Detect Safari (not Chrome or WebKit)[31m
>> [39m	version = parseVersion(userAgent.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i));[31m
>> [39m	if (version) {[31m
>> [39m	    exports.safari = { version: version };[31m
>> [39m	}[31m
>> [39m	// Detect FF[31m
>> [39m	version = parseVersion(userAgent.match(/Firefox\/([^ ]*)/));[31m
>> [39m	if (version) {[31m
>> [39m	    exports.firefox = { version: version };[31m
>> [39m	}[31m
>> [39m	var hasES5 = typeof Array.isArray === "function" &&[31m
>> [39m	    typeof [].forEach === "function" &&[31m
>> [39m	    typeof [].map === "function" &&[31m
>> [39m	    typeof [].some === "function" &&[31m
>> [39m	    typeof [].indexOf === "function" &&[31m
>> [39m	    typeof Object.keys === "function" &&[31m
>> [39m	    typeof Object.defineProperty === "function";[31m
>> [39m	exports.isSupported = (!exports.ie || exports.ie.version >= 9) ||[31m
>> [39m	    (!exports.safari || exports.safari.version >= 5) ||[31m
>> [39m	    (!exports.firefox || exports.firefox.version >= 5) &&[31m
>> [39m	        hasES5;[31m
>> [39m	// Special support for jQuery here because it's so commonly used.[31m
>> [39m	exports.jQueryInstance = window["jQuery"];[31m
>> [39m	/*[22m[31m
>> [39m	* Strips any external data associated with the node from it[31m
>> [39m	* @param {Node} node The node to clean[31m
>> [39m	[1m/[31m
>> [39m	exports.cleanExternalData;[31m
>> [39m	if (exports.jQueryInstance && (typeof exports.jQueryInstance['cleanData'] === "function")) {[31m
>> [39m	    exports.cleanExternalData = function (node) {[31m
>> [39m	        // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData[31m
>> [39m	        // so notify it to tear down any resources associated with the node.[31m
>> [39m	        exports.jQueryInstance['cleanData']([node]);[31m
>> [39m	    };[31m
>> [39m	}[31m
>> [39m	else {[31m
>> [39m	    exports.cleanExternalData = function (node) { };[31m
>> [39m	}[31m
>> [39m	//# sourceMappingURL=Environment.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 17 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* Html Template Engine based on JQuery's parseHTML[31m
>> [39m	* NOTE: This version does not support scripts in templates![31m
>> [39m	[1m/[31m
>> [39m	var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, rtagName = /<([\w:-]+)/, rhtml = /<|&#?\w+;/, rscriptType = /^$|\/(?:java|ecma)script/i, [31m
>> [39m	// We have to close these tags to support XHTML (#13200)[31m
>> [39m	wrapMap = {[31m
>> [39m	    // Support: IE9[31m
>> [39m	    option: [1, "<select multiple='multiple'>", "</select>"],[31m
>> [39m	    thead: [1, "<table>", "</table>"],[31m
>> [39m	    // Some of the following wrappers are not fully defined, because[31m
>> [39m	    // their parent elements (except for "table" element) could be omitted[31m
>> [39m	    // since browser parsers are smart enough to auto-insert them[31m
>> [39m	    // Support: Android 2.3[31m
>> [39m	    // Android browser doesn't auto-insert colgroup[31m
>> [39m	    col: [2, "<table><colgroup>", "</colgroup></table>"],[31m
>> [39m	    // Auto-insert "tbody" element[31m
>> [39m	    tr: [2, "<table>", "</table>"],[31m
>> [39m	    // Auto-insert "tbody" and "tr" elements[31m
>> [39m	    td: [3, "<table>", "</table>"],[31m
>> [39m	    _default: [0, "", ""][31m
>> [39m	};[31m
>> [39m	// Support: IE9[31m
>> [39m	wrapMap.optgroup = wrapMap.option;[31m
>> [39m	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;[31m
>> [39m	wrapMap.th = wrapMap.td;[31m
>> [39m	var supportsCreateHTMLDocument = (function () {[31m
>> [39m	    var doc = document.implementation.createHTMLDocument("");[31m
>> [39m	    // Support: Node with jsdom<=1.5.0+[31m
>> [39m	    // jsdom's document created via the above method doesn't contain the body[31m
>> [39m	    if (!doc.body) {[31m
>> [39m	        return false;[31m
>> [39m	    }[31m
>> [39m	    doc.body.innerHTML = "<form></form><form></form>";[31m
>> [39m	    return doc.body.childNodes.length === 2;[31m
>> [39m	})();[31m
>> [39m	function merge(first, second) {[31m
>> [39m	    var len = +second.length, j = 0, i = first.length;[31m
>> [39m	    for (; j < len; j++) {[31m
>> [39m	        first[i++] = second[j];[31m
>> [39m	    }[31m
>> [39m	    first.length = i;[31m
>> [39m	    return first;[31m
>> [39m	}[31m
>> [39m	function buildFragment(elems, context) {[31m
>> [39m	    var elem, tmp, tag, wrap, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;[31m
>> [39m	    for (; i < l; i++) {[31m
>> [39m	        elem = elems[i];[31m
>> [39m	        if (elem || elem === 0) {[31m
>> [39m	            // Add nodes directly[31m
>> [39m	            if (typeof elem === "object") {[31m
>> [39m	                // Support: Android<4.1, PhantomJS<2[31m
>> [39m	                // push.apply([24m, arraylike) throws on ancient WebKit[31m
>> [39m	                merge(nodes, elem.nodeType ? [elem] : elem);[31m
>> [39m	            }[31m
>> [39m	            else if (!rhtml.test(elem)) {[31m
>> [39m	                nodes.push(context.createTextNode(elem));[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                tmp = tmp || fragment.appendChild(context.createElement("div"));[31m
>> [39m	                // Deserialize a standard representation[31m
>> [39m	                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();[31m
>> [39m	                wrap = wrapMap[tag] || wrapMap._default;[31m
>> [39m	                tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];[31m
>> [39m	                // Descend through wrappers to the right content[31m
>> [39m	                j = wrap[0];[31m
>> [39m	                while (j--) {[31m
>> [39m	                    tmp = tmp.lastChild;[31m
>> [39m	                }[31m
>> [39m	                // Support: Android<4.1, PhantomJS<2[31m
>> [39m	                // push.apply(_, arraylike) throws on ancient WebKit[31m
>> [39m	                merge(nodes, tmp.childNodes);[31m
>> [39m	                // Remember the top-level container[31m
>> [39m	                tmp = fragment.firstChild;[31m
>> [39m	                // Ensure the created nodes are orphaned (#12392)[31m
>> [39m	                tmp.textContent = "";[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    // Remove wrapper from fragment[31m
>> [39m	    fragment.textContent = "";[31m
>> [39m	    i = 0;[31m
>> [39m	    while ((elem = nodes[i++])) {[31m
>> [39m	        // filter out scripts[31m
>> [39m	        if (elem.nodeType !== 1 || elem.tagName.toLowerCase() !== "script" || !rscriptType.test(elem.type || "")) {[31m
>> [39m	            fragment.appendChild(elem);[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    return fragment;[31m
>> [39m	}[31m
>> [39m	var HtmlTemplateEngine = (function () {[31m
>> [39m	    function HtmlTemplateEngine() {[31m
>> [39m	    }[31m
>> [39m	    HtmlTemplateEngine.prototype.parse = function (data) {[31m
>> [39m	        // document.implementation stops scripts or inline event handlers from being executed immediately[31m
>> [39m	        var context = supportsCreateHTMLDocument ? document.implementation.createHTMLDocument("") : document;[31m
>> [39m	        var parsed = rsingleTag.exec(data);[31m
>> [39m	        // Single tag[31m
>> [39m	        if (parsed) {[31m
>> [39m	            return [context.createElement(parsed[1])];[31m
>> [39m	        }[31m
>> [39m	        parsed = buildFragment([data], context);[31m
>> [39m	        var result = merge([], parsed.childNodes);[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    return HtmlTemplateEngine;[31m
>> [39m	})();[31m
>> [39m	exports.default = HtmlTemplateEngine;[31m
>> [39m	//# sourceMappingURL=HtmlTemplateEngine.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 18 [1m/[31m
>> [39m/***/ function(module, exports, [4m_webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var Command_1 = __webpack_require__(19);[31m
>> [39m	"use strict";[31m
>> [39m	var CommandBinding = (function () {[31m
>> [39m	    function CommandBinding(domManager, app) {[31m
>> [39m	        this.priority = 0;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    CommandBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("command-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var compiled = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var el = node;[31m
>> [39m	        var exp;[31m
>> [39m	        var cmdObservable;[31m
>> [39m	        var paramObservable;[31m
>> [39m	        var cleanup;[31m
>> [39m	        var isAnchor = el.tagName.toLowerCase() === "a";[31m
>> [39m	        var event = "click";[31m
>> [39m	        function doCleanup() {[31m
>> [39m	            if (cleanup) {[31m
>> [39m	                cleanup.dispose();[31m
>> [39m	                cleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        if (typeof compiled === "function") {[31m
>> [39m	            exp = compiled;[31m
>> [39m	            cmdObservable = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            var opt = compiled;[31m
>> [39m	            exp = opt.command;[31m
>> [39m	            cmdObservable = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	            if (opt.parameter) {[31m
>> [39m	                exp = opt.parameter;[31m
>> [39m	                paramObservable = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        if (paramObservable == null) {[31m
>> [39m	            paramObservable = Rx.Observable.return(undefined);[31m
>> [39m	        }[31m
>> [39m	        state.cleanup.add(Rx.Observable[31m
>> [39m	            .combineLatest(cmdObservable, paramObservable, function (cmd, param) { return ({ cmd: cmd, param: param }); })[31m
>> [39m	            .subscribe(function (x) {[31m
>> [39m	            try {[31m
>> [39m	                doCleanup();[31m
>> [39m	                cleanup = new Rx.CompositeDisposable();[31m
>> [39m	                if (x.cmd != null) {[31m
>> [39m	                    if (!Command_1.isCommand(x.cmd))[31m
>> [39m	                        Utils_1.throwError("Command-Binding only supports binding to a command!");[31m
>> [39m	                    // disabled handling if supported by element[31m
>> [39m	                    if (Utils_1.elementCanBeDisabled(el)) {[31m
>> [39m	                        // initial update[31m
>> [39m	                        el.disabled = !x.cmd.canExecute(x.param);[31m
>> [39m	                        // listen to changes[31m
>> [39m	                        cleanup.add(x.cmd.canExecuteObservable.subscribe(function (canExecute) {[31m
>> [39m	                            el.disabled = !canExecute;[31m
>> [39m	                        }));[31m
>> [39m	                    }[31m
>> [39m	                    // handle input events[31m
>> [39m	                    cleanup.add(Rx.Observable.fromEvent(el, "click").subscribe(function (e) {[31m
>> [39m	                        // verify that the command can actually execute since we cannot disable [31m
>> [39m	                        // all elements - only form elements such as buttons [31m
>> [39m	                        if (x.cmd.canExecute(x.param)) {[31m
>> [39m	                            x.cmd.execute(x.param);[31m
>> [39m	                        }[31m
>> [39m	                        // prevent default for anchors[31m
>> [39m	                        if (isAnchor) {[31m
>> [39m	                            e.preventDefault();[31m
>> [39m	                        }[31m
>> [39m	                    }));[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            doCleanup();[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    CommandBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    return CommandBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = CommandBinding;[31m
>> [39m	//# sourceMappingURL=Command.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 19 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {[31m
>> [39m	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);[31m
>> [39m	    switch (arguments.length) {[31m
>> [39m	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);[31m
>> [39m	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);[31m
>> [39m	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);[31m
>> [39m	    }[31m
>> [39m	};[31m
>> [39m	var __metadata = (this && this.__metadata) || function (k, v) {[31m
>> [39m	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);[31m
>> [39m	};[31m
>> [39m	var IID_1 = __webpack_require__(9);[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var Reflect_1 = __webpack_require__(3);[31m
>> [39m	var Injector_1 = __webpack_require__(1);[31m
>> [39m	var res = __webpack_require__(10);[31m
>> [39m	"use strict";[31m
>> [39m	var Command = (function () {[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// Don't use this directly, use commandXYZ instead[31m
>> [39m	    /// </summary>[31m
>> [39m	    function Command(canExecute, executeAsync, scheduler) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        this.resultsSubject = new Rx.Subject();[31m
>> [39m	        this.isExecutingSubject = new Rx.Subject();[31m
>> [39m	        this.inflightCount = 0;[31m
>> [39m	        this.canExecuteLatest = false;[31m
>> [39m	        this.canExecuteDisp = null;[31m
>> [39m	        this.scheduler = scheduler || Injector_1.injector.get(res.app).mainThreadScheduler;[31m
>> [39m	        this.func = executeAsync;[31m
>> [39m	        // setup canExecute[31m
>> [39m	        this.canExecuteObs = canExecute[31m
>> [39m	            .combineLatest(this.isExecutingSubject.startWith(false), function (ce, ie) { return ce && !ie; })[31m
>> [39m	            .catch(function (ex) {[31m
>> [39m	            _this.exceptionsSubject.onNext(ex);[31m
>> [39m	            return Rx.Observable.return(false);[31m
>> [39m	        })[31m
>> [39m	            .do(function (x) {[31m
>> [39m	            _this.canExecuteLatest = x;[31m
>> [39m	        })[31m
>> [39m	            .publish();[31m
>> [39m	        if (Utils_1.isInUnitTest()) {[31m
>> [39m	            this.canExecuteObs.connect();[31m
>> [39m	        }[31m
>> [39m	        // setup thrownExceptions[31m
>> [39m	        this.exceptionsSubject = new Rx.Subject();[31m
>> [39m	        this.thrownExceptions = this.exceptionsSubject.asObservable();[31m
>> [39m	        this.exceptionsSubject[31m
>> [39m	            .observeOn(this.scheduler)[31m
>> [39m	            .subscribe(Injector_1.injector.get(res.app).defaultExceptionHandler);[31m
>> [39m	    }[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // IDisposable implementation[31m
>> [39m	    Command.prototype.dispose = function () {[31m
>> [39m	        var disp = this.canExecuteDisp;[31m
>> [39m	        if (disp != null)[31m
>> [39m	            disp.dispose();[31m
>> [39m	    };[31m
>> [39m	    Object.defineProperty(Command.prototype, "canExecuteObservable", {[31m
>> [39m	        ////////////////////[31m
>> [39m	        /// wx.ICommand[31m
>> [39m	        get: function () {[31m
>> [39m	            var _this = this;[31m
>> [39m	            // setup canExecuteObservable[31m
>> [39m	            var ret = this.canExecuteObs.startWith(this.canExecuteLatest).distinctUntilChanged();[31m
>> [39m	            if (this.canExecuteDisp != null)[31m
>> [39m	                return ret;[31m
>> [39m	            return Rx.Observable.create(function (subj) {[31m
>> [39m	                var disp = ret.subscribe(subj);[31m
>> [39m	                // NB: We intentionally leak the CanExecute disconnect, it's[31m
>> [39m	                // cleaned up by the global Dispose. This is kind of a[31m
>> [39m	                // "Lazy Subscription" to CanExecute by the command itself.[31m
>> [39m	                _this.canExecuteDisp = _this.canExecuteObs.connect();[31m
>> [39m	                return disp;[31m
>> [39m	            });[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(Command.prototype, "isExecuting", {[31m
>> [39m	        get: function () {[31m
>> [39m	            return this.isExecutingSubject.startWith(this.inflightCount > 0);[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(Command.prototype, "results", {[31m
>> [39m	        get: function () {[31m
>> [39m	            return this.resultsSubject.asObservable();[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Command.prototype.canExecute = function (parameter) {[31m
>> [39m	        if (this.canExecuteDisp == null)[31m
>> [39m	            this.canExecuteDisp = this.canExecuteObs.connect();[31m
>> [39m	        return this.canExecuteLatest;[31m
>> [39m	    };[31m
>> [39m	    Command.prototype.execute = function (parameter) {[31m
>> [39m	        this.executeAsync(parameter)[31m
>> [39m	            .catch(Rx.Observable.empty())[31m
>> [39m	            .subscribe();[31m
>> [39m	    };[31m
>> [39m	    Command.prototype.executeAsync = function (parameter) {[31m
>> [39m	        var self = this;[31m
>> [39m	        var ret = Rx.Observable.create(function (subj) {[31m
>> [39m	            if (++self.inflightCount === 1) {[31m
>> [39m	                self.isExecutingSubject.onNext(true);[31m
>> [39m	            }[31m
>> [39m	            var decrement = new Rx.SerialDisposable();[31m
>> [39m	            decrement.setDisposable(Rx.Disposable.create(function () {[31m
>> [39m	                if (--self.inflightCount === 0) {[31m
>> [39m	                    self.isExecutingSubject.onNext(false);[31m
>> [39m	                }[31m
>> [39m	            }));[31m
>> [39m	            var disp = self.func(parameter)[31m
>> [39m	                .observeOn(self.scheduler)[31m
>> [39m	                .do(function (_) { }, function (e) { return decrement.setDisposable(Rx.Disposable.empty); }, function () { return decrement.setDisposable(Rx.Disposable.empty); })[31m
>> [39m	                .do(function (x) { return self.resultsSubject.onNext(x); }, function (x) { return self.exceptionsSubject.onNext(x); })[31m
>> [39m	                .subscribe(subj);[31m
>> [39m	            return new Rx.CompositeDisposable(disp, decrement);[31m
>> [39m	        });[31m
>> [39m	        return ret[31m
>> [39m	            .publish()[31m
>> [39m	            .refCount();[31m
>> [39m	    };[31m
>> [39m	    Command = __decorate([[31m
>> [39m	        Reflect_1.Implements(IID_1.default.ICommand),[31m
>> [39m	        Reflect_1.Implements(IID_1.default.IDisposable), [31m
>> [39m	        __metadata('design:paramtypes', [Rx.Observable, Function, Object])[31m
>> [39m	    ], Command);[31m
>> [39m	    return Command;[31m
>> [39m	})();[31m
>> [39m	exports.Command = Command;[31m
>> [39m	var internal;[31m
>> [39m	(function (internal) {[31m
>> [39m	    internal.commandConstructor = Command;[31m
>> [39m	})(internal = exports.internal || (exports.internal = {}));[31m
>> [39m	// factory method implementation[31m
>> [39m	function command() {[31m
>> [39m	    var args = Utils_1.args2Array(arguments);[31m
>> [39m	    var canExecute;[31m
>> [39m	    var execute;[31m
>> [39m	    var scheduler;[31m
>> [39m	    var thisArg;[31m
>> [39m	    if (Utils_1.isFunction(args[0])) {[31m
>> [39m	        // first overload[31m
>> [39m	        execute = args.shift();[31m
>> [39m	        canExecute = Utils_1.isRxObservable(args[0]) ? args.shift() : Rx.Observable.return(true);[31m
>> [39m	        scheduler = Utils_1.isRxScheduler(args[0]) ? args.shift() : undefined;[31m
>> [39m	        thisArg = args.shift();[31m
>> [39m	        if (thisArg != null)[31m
>> [39m	            execute = execute.bind(thisArg);[31m
>> [39m	        return asyncCommand(canExecute, function (parameter) {[31m
>> [39m	            return Rx.Observable.create(function (obs) {[31m
>> [39m	                try {[31m
>> [39m	                    execute(parameter);[31m
>> [39m	                    obs.onNext(null);[31m
>> [39m	                    obs.onCompleted();[31m
>> [39m	                }[31m
>> [39m	                catch (e) {[31m
>> [39m	                    obs.onError(e);[31m
>> [39m	                }[31m
>> [39m	                return Rx.Disposable.empty;[31m
>> [39m	            });[31m
>> [39m	        }, scheduler);[31m
>> [39m	    }[31m
>> [39m	    // second overload[31m
>> [39m	    canExecute = args.shift() || Rx.Observable.return(true);[31m
>> [39m	    scheduler = Utils_1.isRxScheduler(args[0]) ? args.shift() : undefined;[31m
>> [39m	    return new Command(canExecute, function (x) { return Rx.Observable.return(x); }, scheduler);[31m
>> [39m	}[31m
>> [39m	exports.command = command;[31m
>> [39m	// factory method implementation[31m
>> [39m	function asyncCommand() {[31m
>> [39m	    var args = Utils_1.args2Array(arguments);[31m
>> [39m	    var canExecute;[31m
>> [39m	    var executeAsync;[31m
>> [39m	    var scheduler;[31m
>> [39m	    var thisArg;[31m
>> [39m	    if (Utils_1.isFunction(args[0])) {[31m
>> [39m	        // second overload[31m
>> [39m	        executeAsync = args.shift();[31m
>> [39m	        scheduler = Utils_1.isRxScheduler(args[0]) ? args.shift() : undefined;[31m
>> [39m	        thisArg = args.shift();[31m
>> [39m	        if (thisArg != null)[31m
>> [39m	            executeAsync = executeAsync.bind(thisArg);[31m
>> [39m	        return new Command(Rx.Observable.return(true), executeAsync, scheduler);[31m
>> [39m	    }[31m
>> [39m	    // first overload[31m
>> [39m	    canExecute = args.shift();[31m
>> [39m	    executeAsync = args.shift();[31m
>> [39m	    scheduler = Utils_1.isRxScheduler(args[0]) ? args.shift() : undefined;[31m
>> [39m	    return new Command(canExecute, executeAsync, scheduler);[31m
>> [39m	}[31m
>> [39m	exports.asyncCommand = asyncCommand;[31m
>> [39m	// factory method implementation[31m
>> [39m	function combinedCommand() {[31m
>> [39m	    var args = Utils_1.args2Array(arguments);[31m
>> [39m	    var commands = args[31m
>> [39m	        .filter(function (x) { return isCommand(x); });[31m
>> [39m	    var canExecute = args[31m
>> [39m	        .filter(function (x) { return Utils_1.isRxObservable(x); })[31m
>> [39m	        .pop();[31m
>> [39m	    if (!canExecute)[31m
>> [39m	        canExecute = Rx.Observable.return(true);[31m
>> [39m	    var childrenCanExecute = Rx.Observable.combineLatest(commands.map(function (x) { return x.canExecuteObservable; }), function () {[31m
>> [39m	        var latestCanExecute = [];[31m
>> [39m	        for (var _i = 0; _i < arguments.length; _i++) {[31m
>> [39m	            latestCanExecute[_i - 0] = arguments[_i];[31m
>> [39m	        }[31m
>> [39m	        return latestCanExecute.every(function (x) { return x; });[31m
>> [39m	    });[31m
>> [39m	    var canExecuteSum = Rx.Observable.combineLatest(canExecute.startWith(true), childrenCanExecute, function (parent, child) { return parent && child; });[31m
>> [39m	    var ret = command(canExecuteSum);[31m
>> [39m	    ret.results.subscribe(function (x) { return commands.forEach(function (cmd) {[31m
>> [39m	        cmd.execute(x);[31m
>> [39m	    }); });[31m
>> [39m	    return ret;[31m
>> [39m	}[31m
>> [39m	exports.combinedCommand = combinedCommand;[31m
>> [39m	/*[22m[31m
>> [39m	* Determines if target is an instance of a ICommand[31m
>> [39m	* @param {any} target[31m
>> [39m	[1m/[31m
>> [39m	function isCommand(target) {[31m
>> [39m	    if (target == null)[31m
>> [39m	        return false;[31m
>> [39m	    return target instanceof Command ||[31m
>> [39m	        Utils_1.queryInterface(target, IID_1.default.ICommand);[31m
>> [39m	}[31m
>> [39m	exports.isCommand = isCommand;[31m
>> [39m	//# sourceMappingURL=Command.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 20 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var Module_1 = __webpack_require__(13);[31m
>> [39m	"use strict";[31m
>> [39m	var ModuleBinding = (function () {[31m
>> [39m	    function ModuleBinding(domManager, app) {[31m
>> [39m	        this.priority = 100;[31m
>> [39m	        this.controlsDescendants = true;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    ModuleBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("module-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var self = this;[31m
>> [39m	        var exp = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var obs = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	        var initialApply = true;[31m
>> [39m	        var cleanup;[31m
>> [39m	        function doCleanup() {[31m
>> [39m	            if (cleanup) {[31m
>> [39m	                cleanup.dispose();[31m
>> [39m	                cleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // backup inner HTML[31m
>> [39m	        var template = new Array();[31m
>> [39m	        // subscribe[31m
>> [39m	        state.cleanup.add(obs.subscribe(function (x) {[31m
>> [39m	            try {[31m
>> [39m	                doCleanup();[31m
>> [39m	                cleanup = new Rx.CompositeDisposable();[31m
>> [39m	                var value = Utils_1.unwrapProperty(x);[31m
>> [39m	                var moduleNames;[31m
>> [39m	                var disp = undefined;[31m
>> [39m	                // split names[31m
>> [39m	                if (value) {[31m
>> [39m	                    value = value.trim();[31m
>> [39m	                    moduleNames = value.split(" ").filter(function (x) { return x; });[31m
>> [39m	                }[31m
>> [39m	                if (moduleNames.length > 0) {[31m
>> [39m	                    var observables = moduleNames.map(function (x) { return Module_1.loadModule(x); });[31m
>> [39m	                    disp = Rx.Observable.combineLatest(observables, function (_) { return Utils_1.args2Array(arguments); }).subscribe(function (modules) {[31m
>> [39m	                        try {[31m
>> [39m	                            // create intermediate module[31m
>> [39m	                            var moduleName = (module || _this.app).name + "+" + moduleNames.join("+");[31m
>> [39m	                            var merged = new Module_1.Module(moduleName);[31m
>> [39m	                            // merge modules into intermediate[31m
>> [39m	                            merged.merge(module || _this.app);[31m
>> [39m	                            modules.forEach(function (x) { return merged.merge(x); });[31m
>> [39m	                            // done[31m
>> [39m	                            self.applyValue(el, merged, template, ctx, state, initialApply);[31m
>> [39m	                            initialApply = false;[31m
>> [39m	                        }[31m
>> [39m	                        catch (e) {[31m
>> [39m	                            _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                        }[31m
>> [39m	                    });[31m
>> [39m	                    if (disp != null)[31m
>> [39m	                        cleanup.add(disp);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            obs = null;[31m
>> [39m	            self = null;[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    ModuleBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    ModuleBinding.prototype.applyValue = function (el, module, template, ctx, state, initialApply) {[31m
>> [39m	        if (initialApply) {[31m
>> [39m	            // clone to template[31m
>> [39m	            for (var i = 0; i < el.childNodes.length; i++) {[31m
>> [39m	                template.push(el.childNodes[i].cloneNode(true));[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        state.module = module;[31m
>> [39m	        // clean first[31m
>> [39m	        this.domManager.cleanDescendants(el);[31m
>> [39m	        // clear[31m
>> [39m	        while (el.firstChild) {[31m
>> [39m	            el.removeChild(el.firstChild);[31m
>> [39m	        }[31m
>> [39m	        // clone nodes and inject[31m
>> [39m	        for (var i = 0; i < template.length; i++) {[31m
>> [39m	            var node = template[i].cloneNode(true);[31m
>> [39m	            el.appendChild(node);[31m
>> [39m	        }[31m
>> [39m	        this.domManager.applyBindingsToDescendants(ctx, el);[31m
>> [39m	    };[31m
>> [39m	    return ModuleBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = ModuleBinding;[31m
>> [39m	//# sourceMappingURL=Module.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 21 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var __extends = (this && this.__extends) || function (d, b) {[31m
>> [39m	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];[31m
>> [39m	    function __() { this.constructor = d; }[31m
>> [39m	    _[24m.prototype = b.prototype;[31m
>> [39m	    d.prototype = new [4m_();[31m
>> [39m	};[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var IfBinding = (function () {[31m
>> [39m	    function IfBinding(domManager, app) {[31m
>> [39m	        this.priority = 50;[31m
>> [39m	        this.controlsDescendants = true;[31m
>> [39m	        ////////////////////[31m
>> [39m	        // wx.Implementation[31m
>> [39m	        this.inverse = false;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    IfBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("if-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var compiled = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var el = node;[31m
>> [39m	        var self = this;[31m
>> [39m	        var initialApply = true;[31m
>> [39m	        var exp;[31m
>> [39m	        var animations = {};[31m
>> [39m	        var cleanup;[31m
>> [39m	        function doCleanup() {[31m
>> [39m	            if (cleanup) {[31m
>> [39m	                cleanup.dispose();[31m
>> [39m	                cleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        if (typeof compiled === "object") {[31m
>> [39m	            var opt = compiled;[31m
>> [39m	            exp = opt.condition;[31m
>> [39m	            // extract animations[31m
>> [39m	            if (opt.enter) {[31m
>> [39m	                animations.enter = this.domManager.evaluateExpression(opt.enter, ctx);[31m
>> [39m	                if (typeof animations.enter === "string") {[31m
>> [39m	                    animations.enter = module.animation(animations.enter);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            if (opt.leave) {[31m
>> [39m	                animations.leave = this.domManager.evaluateExpression(opt.leave, ctx);[31m
>> [39m	                if (typeof animations.leave === "string") {[31m
>> [39m	                    animations.leave = module.animation(animations.leave);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            exp = compiled;[31m
>> [39m	        }[31m
>> [39m	        var obs = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	        // backup inner HTML[31m
>> [39m	        var template = new Array();[31m
>> [39m	        // subscribe[31m
>> [39m	        state.cleanup.add(obs.subscribe(function (x) {[31m
>> [39m	            try {[31m
>> [39m	                doCleanup();[31m
>> [39m	                cleanup = new Rx.CompositeDisposable();[31m
>> [39m	                cleanup.add(self.applyValue(el, Utils_1.unwrapProperty(x), template, ctx, animations, initialApply));[31m
>> [39m	                initialApply = false;[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            obs = null;[31m
>> [39m	            el = null;[31m
>> [39m	            self = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            template = null;[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    IfBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    IfBinding.prototype.applyValue = function (el, value, template, ctx, animations, initialApply) {[31m
>> [39m	        var leaveAnimation = animations.leave;[31m
>> [39m	        var enterAnimation = animations.enter;[31m
>> [39m	        var self = this;[31m
>> [39m	        var obs = undefined;[31m
>> [39m	        if (initialApply) {[31m
>> [39m	            // clone to template[31m
>> [39m	            for (var i = 0; i < el.childNodes.length; i++) {[31m
>> [39m	                template.push(el.childNodes[i].cloneNode(true));[31m
>> [39m	            }[31m
>> [39m	            // clear[31m
>> [39m	            while (el.firstChild) {[31m
>> [39m	                el.removeChild(el.firstChild);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        var oldElements = Utils_1.nodeChildrenToArray(el);[31m
>> [39m	        value = this.inverse ? !value : value;[31m
>> [39m	        function removeOldElements() {[31m
>> [39m	            oldElements.forEach(function (x) {[31m
>> [39m	                self.domManager.cleanNode(x);[31m
>> [39m	                el.removeChild(x);[31m
>> [39m	            });[31m
>> [39m	        }[31m
>> [39m	        if (!value) {[31m
>> [39m	            if (oldElements.length > 0) {[31m
>> [39m	                if (leaveAnimation) {[31m
>> [39m	                    leaveAnimation.prepare(oldElements);[31m
>> [39m	                    obs = leaveAnimation.run(oldElements)[31m
>> [39m	                        .continueWith(function () { return leaveAnimation.complete(oldElements); })[31m
>> [39m	                        .continueWith(removeOldElements);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    removeOldElements();[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            var nodes = template.map(function (x) { return x.cloneNode(true); });[31m
>> [39m	            if (enterAnimation)[31m
>> [39m	                enterAnimation.prepare(nodes);[31m
>> [39m	            for (var i = 0; i < template.length; i++) {[31m
>> [39m	                el.appendChild(nodes[i]);[31m
>> [39m	            }[31m
>> [39m	            this.domManager.applyBindingsToDescendants(ctx, el);[31m
>> [39m	            if (enterAnimation) {[31m
>> [39m	                obs = enterAnimation.run(nodes)[31m
>> [39m	                    .continueWith(function () { return enterAnimation.complete(nodes); });[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return obs ? (obs.subscribe() || Rx.Disposable.empty) : Rx.Disposable.empty;[31m
>> [39m	    };[31m
>> [39m	    return IfBinding;[31m
>> [39m	})();[31m
>> [39m	exports.IfBinding = IfBinding;[31m
>> [39m	var NotIfBinding = (function (_super) {[31m
>> [39m	    __extends(NotIfBinding, _super);[31m
>> [39m	    function NotIfBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app);[31m
>> [39m	        this.inverse = true;[31m
>> [39m	    }[31m
>> [39m	    return NotIfBinding;[31m
>> [39m	})(IfBinding);[31m
>> [39m	exports.NotIfBinding = NotIfBinding;[31m
>> [39m	//# sourceMappingURL=If.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 22 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var __extends = (this && this.__extends) || function (d, b) {[31m
>> [39m	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];[31m
>> [39m	    function __() { this.constructor = d; }[31m
>> [39m	    _[24m.prototype = b.prototype;[31m
>> [39m	    d.prototype = new [4m_();[31m
>> [39m	};[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var MultiOneWayChangeBindingBase = (function () {[31m
>> [39m	    function MultiOneWayChangeBindingBase(domManager, app, supportsDynamicValues) {[31m
>> [39m	        if (supportsDynamicValues === void 0) { supportsDynamicValues = false; }[31m
>> [39m	        this.priority = 0;[31m
>> [39m	        this.supportsDynamicValues = false;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	        this.supportsDynamicValues = supportsDynamicValues;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    MultiOneWayChangeBindingBase.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("binding only operates on elements!");[31m
>> [39m	        var compiled = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        if (compiled == null || (typeof compiled !== "object" && !this.supportsDynamicValues))[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var observables = new Array();[31m
>> [39m	        var obs;[31m
>> [39m	        var exp;[31m
>> [39m	        var keys = Object.keys(compiled);[31m
>> [39m	        var key;[31m
>> [39m	        if (typeof compiled === "function") {[31m
>> [39m	            exp = compiled;[31m
>> [39m	            obs = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	            observables.push(["", obs]);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            for (var i = 0; i < keys.length; i++) {[31m
>> [39m	                key = keys[i];[31m
>> [39m	                var value = compiled[key];[31m
>> [39m	                exp = value;[31m
>> [39m	                obs = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	                observables.push([key, obs]);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // subscribe[31m
>> [39m	        for (var i = 0; i < observables.length; i++) {[31m
>> [39m	            key = observables[i][0];[31m
>> [39m	            obs = observables[i][1];[31m
>> [39m	            this.subscribe(el, obs, key, state);[31m
>> [39m	        }[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            keys = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            observables = null;[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    MultiOneWayChangeBindingBase.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    MultiOneWayChangeBindingBase.prototype.subscribe = function (el, obs, key, state) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        state.cleanup.add(obs.subscribe(function (x) {[31m
>> [39m	            try {[31m
>> [39m	                _this.applyValue(el, Utils_1.unwrapProperty(x), key);[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    MultiOneWayChangeBindingBase.prototype.applyValue = function (el, key, value) {[31m
>> [39m	        Utils_1.throwError("you need to override this method!");[31m
>> [39m	    };[31m
>> [39m	    return MultiOneWayChangeBindingBase;[31m
>> [39m	})();[31m
>> [39m	exports.MultiOneWayChangeBindingBase = MultiOneWayChangeBindingBase;[31m
>> [39m	var CssBinding = (function (_super) {[31m
>> [39m	    __extends(CssBinding, _super);[31m
>> [39m	    function CssBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app, true);[31m
>> [39m	    }[31m
>> [39m	    CssBinding.prototype.applyValue = function (el, value, key) {[31m
>> [39m	        var classes;[31m
>> [39m	        if (key !== "") {[31m
>> [39m	            classes = key.split(/\s+/).map(function (x) { return x.trim(); }).filter(function (x) { return x; });[31m
>> [39m	            if (classes.length) {[31m
>> [39m	                Utils_1.toggleCssClass.apply(null, [el, !!value].concat(classes));[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            var state = this.domManager.getNodeState(el);[31m
>> [39m	            // if we have previously added classes, remove them[31m
>> [39m	            if (state.cssBindingPreviousDynamicClasses != null) {[31m
>> [39m	                Utils_1.toggleCssClass.apply(null, [el, false].concat(state.cssBindingPreviousDynamicClasses));[31m
>> [39m	                state.cssBindingPreviousDynamicClasses = null;[31m
>> [39m	            }[31m
>> [39m	            if (value) {[31m
>> [39m	                classes = value.split(/\s+/).map(function (x) { return x.trim(); }).filter(function (x) { return x; });[31m
>> [39m	                if (classes.length) {[31m
>> [39m	                    Utils_1.toggleCssClass.apply(null, [el, true].concat(classes));[31m
>> [39m	                    state.cssBindingPreviousDynamicClasses = classes;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    return CssBinding;[31m
>> [39m	})(MultiOneWayChangeBindingBase);[31m
>> [39m	exports.CssBinding = CssBinding;[31m
>> [39m	var AttrBinding = (function (_super) {[31m
>> [39m	    __extends(AttrBinding, _super);[31m
>> [39m	    function AttrBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app);[31m
>> [39m	        this.priority = 5;[31m
>> [39m	    }[31m
>> [39m	    AttrBinding.prototype.applyValue = function (el, value, key) {[31m
>> [39m	        // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely[31m
>> [39m	        // when someProp is a "no value"-like value (strictly null, false, or undefined)[31m
>> [39m	        // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)[31m
>> [39m	        var toRemove = (value === false) || (value === null) || (value === undefined);[31m
>> [39m	        if (toRemove)[31m
>> [39m	            el.removeAttribute(key);[31m
>> [39m	        else {[31m
>> [39m	            el.setAttribute(key, value.toString());[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    return AttrBinding;[31m
>> [39m	})(MultiOneWayChangeBindingBase);[31m
>> [39m	exports.AttrBinding = AttrBinding;[31m
>> [39m	var StyleBinding = (function (_super) {[31m
>> [39m	    __extends(StyleBinding, _super);[31m
>> [39m	    function StyleBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app);[31m
>> [39m	    }[31m
>> [39m	    StyleBinding.prototype.applyValue = function (el, value, key) {[31m
>> [39m	        if (value === null || value === undefined || value === false) {[31m
>> [39m	            // Empty string removes the value, whereas null/undefined have no effect[31m
>> [39m	            value = "";[31m
>> [39m	        }[31m
>> [39m	        el.style[key] = value;[31m
>> [39m	    };[31m
>> [39m	    return StyleBinding;[31m
>> [39m	})(MultiOneWayChangeBindingBase);[31m
>> [39m	exports.StyleBinding = StyleBinding;[31m
>> [39m	//# sourceMappingURL=MultiOneWay.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 23 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var __extends = (this && this.__extends) || function (d, b) {[31m
>> [39m	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];[31m
>> [39m	    function __() { this.constructor = d; }[31m
>> [39m	    _[24m.prototype = b.prototype;[31m
>> [39m	    d.prototype = new [4m_();[31m
>> [39m	};[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var SingleOneWayChangeBindingBase = (function () {[31m
>> [39m	    function SingleOneWayChangeBindingBase(domManager, app) {[31m
>> [39m	        this.priority = 0;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    SingleOneWayChangeBindingBase.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var self = this;[31m
>> [39m	        var exp = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var obs = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	        // subscribe[31m
>> [39m	        state.cleanup.add(obs.subscribe(function (x) {[31m
>> [39m	            try {[31m
>> [39m	                self.applyValue(el, Utils_1.unwrapProperty(x));[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            obs = null;[31m
>> [39m	            self = null;[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    SingleOneWayChangeBindingBase.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    SingleOneWayChangeBindingBase.prototype.applyValue = function (el, value) {[31m
>> [39m	        Utils_1.throwError("you need to override this method!");[31m
>> [39m	    };[31m
>> [39m	    return SingleOneWayChangeBindingBase;[31m
>> [39m	})();[31m
>> [39m	exports.SingleOneWayChangeBindingBase = SingleOneWayChangeBindingBase;[31m
>> [39m	////////////////////[31m
>> [39m	// Bindings[31m
>> [39m	var TextBinding = (function (_super) {[31m
>> [39m	    __extends(TextBinding, _super);[31m
>> [39m	    function TextBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app);[31m
>> [39m	    }[31m
>> [39m	    TextBinding.prototype.applyValue = function (el, value) {[31m
>> [39m	        if ((value === null) || (value === undefined))[31m
>> [39m	            value = "";[31m
>> [39m	        el.textContent = value;[31m
>> [39m	    };[31m
>> [39m	    return TextBinding;[31m
>> [39m	})(SingleOneWayChangeBindingBase);[31m
>> [39m	exports.TextBinding = TextBinding;[31m
>> [39m	var VisibleBinding = (function (_super) {[31m
>> [39m	    __extends(VisibleBinding, _super);[31m
>> [39m	    function VisibleBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app);[31m
>> [39m	        this.inverse = false;[31m
>> [39m	        this.inverse = false;[31m
>> [39m	        this.priority = 10;[31m
>> [39m	    }[31m
>> [39m	    VisibleBinding.prototype.configure = function (_options) {[31m
>> [39m	        var options = _options;[31m
>> [39m	        VisibleBinding.useCssClass = options.useCssClass;[31m
>> [39m	        VisibleBinding.hiddenClass = options.hiddenClass;[31m
>> [39m	    };[31m
>> [39m	    ////////////////////[31m
>> [39m	    // implementation[31m
>> [39m	    VisibleBinding.prototype.applyValue = function (el, value) {[31m
>> [39m	        value = this.inverse ? !value : value;[31m
>> [39m	        if (!VisibleBinding.useCssClass) {[31m
>> [39m	            if (!value) {[31m
>> [39m	                el.style.display = "none";[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                el.style.display = "";[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            Utils_1.toggleCssClass(el, !value, VisibleBinding.hiddenClass);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    return VisibleBinding;[31m
>> [39m	})(SingleOneWayChangeBindingBase);[31m
>> [39m	exports.VisibleBinding = VisibleBinding;[31m
>> [39m	var HiddenBinding = (function (_super) {[31m
>> [39m	    __extends(HiddenBinding, _super);[31m
>> [39m	    function HiddenBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app);[31m
>> [39m	        this.inverse = true;[31m
>> [39m	    }[31m
>> [39m	    return HiddenBinding;[31m
>> [39m	})(VisibleBinding);[31m
>> [39m	exports.HiddenBinding = HiddenBinding;[31m
>> [39m	var HtmlBinding = (function (_super) {[31m
>> [39m	    __extends(HtmlBinding, _super);[31m
>> [39m	    function HtmlBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app);[31m
>> [39m	    }[31m
>> [39m	    HtmlBinding.prototype.applyValue = function (el, value) {[31m
>> [39m	        if ((value === null) || (value === undefined))[31m
>> [39m	            value = "";[31m
>> [39m	        el.innerHTML = value;[31m
>> [39m	    };[31m
>> [39m	    return HtmlBinding;[31m
>> [39m	})(SingleOneWayChangeBindingBase);[31m
>> [39m	exports.HtmlBinding = HtmlBinding;[31m
>> [39m	var DisableBinding = (function (_super) {[31m
>> [39m	    __extends(DisableBinding, _super);[31m
>> [39m	    function DisableBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app);[31m
>> [39m	        this.inverse = false;[31m
>> [39m	        this.inverse = false;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // implementation[31m
>> [39m	    DisableBinding.prototype.applyValue = function (el, value) {[31m
>> [39m	        value = this.inverse ? !value : value;[31m
>> [39m	        if (Utils_1.elementCanBeDisabled(el)) {[31m
>> [39m	            el.disabled = value;[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    return DisableBinding;[31m
>> [39m	})(SingleOneWayChangeBindingBase);[31m
>> [39m	exports.DisableBinding = DisableBinding;[31m
>> [39m	var EnableBinding = (function (_super) {[31m
>> [39m	    __extends(EnableBinding, _super);[31m
>> [39m	    function EnableBinding(domManager, app) {[31m
>> [39m	        _super.call(this, domManager, app);[31m
>> [39m	        this.inverse = true;[31m
>> [39m	    }[31m
>> [39m	    return EnableBinding;[31m
>> [39m	})(DisableBinding);[31m
>> [39m	exports.EnableBinding = EnableBinding;[31m
>> [39m	//# sourceMappingURL=SimpleOneWay.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 24 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../RxExtensions.d.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var VirtualChildNodes_1 = __webpack_require__(25);[31m
>> [39m	var RefCountDisposeWrapper_1 = __webpack_require__(26);[31m
>> [39m	var Injector_1 = __webpack_require__(1);[31m
>> [39m	var List_1 = __webpack_require__(27);[31m
>> [39m	"use strict";[31m
>> [39m	var ForEachBinding = (function () {[31m
>> [39m	    function ForEachBinding(domManager, app) {[31m
>> [39m	        this.priority = 40;[31m
>> [39m	        this.controlsDescendants = true;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	        // hook into getDataContext() to map state['index'] to ctx['$index'][31m
>> [39m	        domManager.registerDataContextExtension(function (node, ctx) {[31m
>> [39m	            var state = domManager.getNodeState(node);[31m
>> [39m	            ctx.$index = state.index;[31m
>> [39m	        });[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    ForEachBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("forEach binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("*[22m invalid binding options!");[31m
>> [39m	        var compiled = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var el = node;[31m
>> [39m	        var self = this;[31m
>> [39m	        var initialApply = true;[31m
>> [39m	        var cleanup = null;[31m
>> [39m	        var hooks;[31m
>> [39m	        var exp;[31m
>> [39m	        var setProxyFunc;[31m
>> [39m	        var animations = {};[31m
>> [39m	        if (typeof compiled === "object" && compiled.hasOwnProperty("data")) {[31m
>> [39m	            var opt = compiled;[31m
>> [39m	            exp = opt.data;[31m
>> [39m	            // extract animations[31m
>> [39m	            if (opt.itemEnter) {[31m
>> [39m	                animations.itemEnter = this.domManager.evaluateExpression(opt.itemEnter, ctx);[31m
>> [39m	                if (typeof animations.itemEnter === "string") {[31m
>> [39m	                    animations.itemEnter = module.animation(animations.itemEnter);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            if (opt.itemLeave) {[31m
>> [39m	                animations.itemLeave = this.domManager.evaluateExpression(opt.itemLeave, ctx);[31m
>> [39m	                if (typeof animations.itemLeave === "string") {[31m
>> [39m	                    animations.itemLeave = module.animation(animations.itemLeave);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            if (opt.hooks) {[31m
>> [39m	                // extract hooks[31m
>> [39m	                hooks = this.domManager.evaluateExpression(opt.hooks, ctx);[31m
>> [39m	            }[31m
>> [39m	            // optionally resolve hooks if passed as string identifier[31m
>> [39m	            if (typeof hooks === "string")[31m
>> [39m	                hooks = Injector_1.injector.get(hooks);[31m
>> [39m	            if (opt['debug']) {[31m
>> [39m	                if (opt['debug']['setProxyFunc']) {[31m
>> [39m	                    setProxyFunc = this.domManager.evaluateExpression(opt['debug']['setProxyFunc'], ctx);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            exp = compiled;[31m
>> [39m	        }[31m
>> [39m	        var obs = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	        // add own disposables[31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            if (cleanup) {[31m
>> [39m	                cleanup.dispose();[31m
>> [39m	                cleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // backup inner HTML[31m
>> [39m	        var template = new Array();[31m
>> [39m	        // subscribe[31m
>> [39m	        state.cleanup.add(obs.subscribe(function (x) {[31m
>> [39m	            try {[31m
>> [39m	                if (cleanup) {[31m
>> [39m	                    cleanup.dispose();[31m
>> [39m	                }[31m
>> [39m	                cleanup = new Rx.CompositeDisposable();[31m
>> [39m	                self.applyValue(el, x, hooks, animations, template, ctx, initialApply, cleanup, setProxyFunc);[31m
>> [39m	                initialApply = false;[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            obs = null;[31m
>> [39m	            el = null;[31m
>> [39m	            self = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            template = null;[31m
>> [39m	            hooks = null;[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.createIndexPropertyForNode = function (proxy, child, startIndex, trigger, templateLength) {[31m
>> [39m	        return Rx.Observable.defer(function () {[31m
>> [39m	            return Rx.Observable.create(function (obs) {[31m
>> [39m	                return trigger.subscribe(function (_) {[31m
>> [39m	                    // recalculate index from node position within parent[31m
>> [39m	                    var index = proxy.childNodes.indexOf(child);[31m
>> [39m	                    index /= templateLength;[31m
>> [39m	                    obs.onNext(index);[31m
>> [39m	                });[31m
>> [39m	            });[31m
>> [39m	        })[31m
>> [39m	            .toProperty(startIndex);[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.appendAllRows = function (proxy, list, ctx, template, hooks, animations, indexTrigger, isInitial) {[31m
>> [39m	        var length = list.length();[31m
>> [39m	        for (var i = 0; i < length; i++) {[31m
>> [39m	            this.appendRow(proxy, i, list.get(i), ctx, template, hooks, animations, indexTrigger, isInitial);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.appendRow = function (proxy, index, item, ctx, template, hooks, animations, indexTrigger, isInitial) {[31m
>> [39m	        var nodes = Utils_1.cloneNodeArray(template);[31m
>> [39m	        var _index = index;[31m
>> [39m	        var enterAnimation = animations.itemEnter;[31m
>> [39m	        var cbData = {[31m
>> [39m	            item: item[31m
>> [39m	        };[31m
>> [39m	        if (indexTrigger) {[31m
>> [39m	            _index = this.createIndexPropertyForNode(proxy, nodes[0], index, indexTrigger, template.length);[31m
>> [39m	            cbData.indexDisp = new RefCountDisposeWrapper_1.default(_index, 0);[31m
>> [39m	        }[31m
>> [39m	        cbData.index = _index;[31m
>> [39m	        if (enterAnimation != null)[31m
>> [39m	            enterAnimation.prepare(nodes);[31m
>> [39m	        proxy.appendChilds(nodes, cbData);[31m
>> [39m	        if (hooks) {[31m
>> [39m	            if (hooks.afterRender)[31m
>> [39m	                hooks.afterRender(nodes, item);[31m
>> [39m	            if (!isInitial && hooks.afterAdd)[31m
>> [39m	                hooks.afterAdd(nodes, item, index);[31m
>> [39m	        }[31m
>> [39m	        if (enterAnimation) {[31m
>> [39m	            var disp = enterAnimation.run(nodes)[31m
>> [39m	                .continueWith(function () { return enterAnimation.complete(nodes); })[31m
>> [39m	                .subscribe(function (x) {[31m
>> [39m	                if (disp != null)[31m
>> [39m	                    disp.dispose();[31m
>> [39m	            });[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.insertRow = function (proxy, index, item, ctx, template, hooks, animations, indexTrigger) {[31m
>> [39m	        var templateLength = template.length;[31m
>> [39m	        var enterAnimation = animations.itemEnter;[31m
>> [39m	        var nodes = Utils_1.cloneNodeArray(template);[31m
>> [39m	        var _index = this.createIndexPropertyForNode(proxy, nodes[0], index, indexTrigger, template.length);[31m
>> [39m	        if (enterAnimation != null)[31m
>> [39m	            enterAnimation.prepare(nodes);[31m
>> [39m	        proxy.insertChilds(index * templateLength, nodes, {[31m
>> [39m	            index: _index,[31m
>> [39m	            item: item,[31m
>> [39m	            indexDisp: new RefCountDisposeWrapper_1.default(_index, 0)[31m
>> [39m	        });[31m
>> [39m	        if (hooks) {[31m
>> [39m	            if (hooks.afterRender)[31m
>> [39m	                hooks.afterRender(nodes, item);[31m
>> [39m	            if (hooks.afterAdd)[31m
>> [39m	                hooks.afterAdd(nodes, item, index);[31m
>> [39m	        }[31m
>> [39m	        if (enterAnimation) {[31m
>> [39m	            var disp = enterAnimation.run(nodes)[31m
>> [39m	                .continueWith(function () { return enterAnimation.complete(nodes); })[31m
>> [39m	                .subscribe(function (x) {[31m
>> [39m	                if (disp != null)[31m
>> [39m	                    disp.dispose();[31m
>> [39m	            });[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.removeRow = function (proxy, index, item, template, hooks, animations) {[31m
>> [39m	        var templateLength = template.length;[31m
>> [39m	        var el = proxy.targetNode;[31m
>> [39m	        var nodes = proxy.removeChilds(index * templateLength, templateLength, true);[31m
>> [39m	        var leaveAnimation = animations.itemLeave;[31m
>> [39m	        function removeNodes() {[31m
>> [39m	            for (var i = 0; i < templateLength; i++) {[31m
>> [39m	                el.removeChild(nodes[i]);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        if (hooks && hooks.beforeRemove) {[31m
>> [39m	            hooks.beforeRemove(nodes, item, index);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            if (leaveAnimation != null) {[31m
>> [39m	                leaveAnimation.prepare(nodes);[31m
>> [39m	                var disp = leaveAnimation.run(nodes)[31m
>> [39m	                    .continueWith(function () { return leaveAnimation.complete(nodes); })[31m
>> [39m	                    .continueWith(removeNodes)[31m
>> [39m	                    .subscribe(function (x) {[31m
>> [39m	                    if (disp != null)[31m
>> [39m	                        disp.dispose();[31m
>> [39m	                });[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                removeNodes();[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.moveRow = function (proxy, from, to, item, template, hooks, animations, indexTrigger) {[31m
>> [39m	        var templateLength = template.length;[31m
>> [39m	        var el = proxy.targetNode;[31m
>> [39m	        var nodes = proxy.removeChilds(from * templateLength, templateLength, true);[31m
>> [39m	        var leaveAnimation = animations.itemLeave;[31m
>> [39m	        var enterAnimation = animations.itemEnter;[31m
>> [39m	        var combined = [];[31m
>> [39m	        var obs;[31m
>> [39m	        var self = this;[31m
>> [39m	        if (hooks && hooks.beforeMove) {[31m
>> [39m	            hooks.beforeMove(nodes, item, from);[31m
>> [39m	        }[31m
>> [39m	        function removeNodes() {[31m
>> [39m	            for (var i = 0; i < templateLength; i++) {[31m
>> [39m	                el.removeChild(nodes[i]);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        function createRow() {[31m
>> [39m	            // create new row[31m
>> [39m	            nodes = Utils_1.cloneNodeArray(template);[31m
>> [39m	            var _index = self.createIndexPropertyForNode(proxy, nodes[0], from, indexTrigger, template.length);[31m
>> [39m	            if (enterAnimation != null)[31m
>> [39m	                enterAnimation.prepare(nodes);[31m
>> [39m	            proxy.insertChilds(templateLength * to, nodes, {[31m
>> [39m	                index: _index,[31m
>> [39m	                item: item,[31m
>> [39m	                indexDisp: new RefCountDisposeWrapper_1.default(_index, 0)[31m
>> [39m	            });[31m
>> [39m	            if (hooks && hooks.afterMove) {[31m
>> [39m	                hooks.afterMove(nodes, item, from);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // construct leave-observable[31m
>> [39m	        if (leaveAnimation) {[31m
>> [39m	            leaveAnimation.prepare(nodes);[31m
>> [39m	            obs = leaveAnimation.run(nodes)[31m
>> [39m	                .continueWith(function () { return leaveAnimation.complete(nodes); })[31m
>> [39m	                .continueWith(removeNodes);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            obs = Rx.Observable.startDeferred(removeNodes);[31m
>> [39m	        }[31m
>> [39m	        combined.push(obs);[31m
>> [39m	        // construct enter-observable[31m
>> [39m	        obs = Rx.Observable.startDeferred(createRow);[31m
>> [39m	        if (enterAnimation) {[31m
>> [39m	            obs = obs.continueWith(enterAnimation.run(nodes))[31m
>> [39m	                .continueWith(function () { return enterAnimation.complete(nodes); });[31m
>> [39m	        }[31m
>> [39m	        combined.push(obs);[31m
>> [39m	        // optimize return[31m
>> [39m	        if (combined.length > 1)[31m
>> [39m	            obs = Rx.Observable.combineLatest(combined, Utils_1.noop).take(1);[31m
>> [39m	        else if (combined.length === 1)[31m
>> [39m	            obs = combined[0].take(1);[31m
>> [39m	        var disp = obs.subscribe(function (x) {[31m
>> [39m	            if (disp != null)[31m
>> [39m	                disp.dispose();[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.rebindRow = function (proxy, index, item, template, indexTrigger) {[31m
>> [39m	        var templateLength = template.length;[31m
>> [39m	        var _index = this.createIndexPropertyForNode(proxy, proxy.childNodes[(index * templateLength)], index, indexTrigger, template.length);[31m
>> [39m	        var indexDisp = new RefCountDisposeWrapper_1.default(_index, 0);[31m
>> [39m	        for (var i = 0; i < template.length; i++) {[31m
>> [39m	            var node = proxy.childNodes[(index * templateLength) + i];[31m
>> [39m	            if (node.nodeType === 1) {[31m
>> [39m	                this.domManager.cleanNode(node);[31m
>> [39m	                var state = this.domManager.createNodeState(item);[31m
>> [39m	                state.index = _index;[31m
>> [39m	                indexDisp.addRef();[31m
>> [39m	                state.cleanup.add(indexDisp);[31m
>> [39m	                this.domManager.setNodeState(node, state);[31m
>> [39m	                this.domManager.applyBindings(item, node);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.observeList = function (proxy, ctx, template, cleanup, list, hooks, animations, indexTrigger) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var i;[31m
>> [39m	        var length;[31m
>> [39m	        cleanup.add(indexTrigger);[31m
>> [39m	        // initial insert[31m
>> [39m	        this.appendAllRows(proxy, list, ctx, template, hooks, animations, indexTrigger, true);[31m
>> [39m	        // track changes[31m
>> [39m	        cleanup.add(list.itemsAdded.subscribe(function (e) {[31m
>> [39m	            length = e.items.length;[31m
>> [39m	            if (e.from === list.length()) {[31m
>> [39m	                for (var i_1 = 0; i_1 < length; i_1++) {[31m
>> [39m	                    _this.appendRow(proxy, i_1 + e.from, e.items[i_1], ctx, template, hooks, animations, indexTrigger, false);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                for (var i_2 = 0; i_2 < e.items.length; i_2++) {[31m
>> [39m	                    _this.insertRow(proxy, i_2 + e.from, e.items[i_2], ctx, template, hooks, animations, indexTrigger);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            indexTrigger.onNext(true);[31m
>> [39m	        }));[31m
>> [39m	        cleanup.add(list.itemsRemoved.subscribe(function (e) {[31m
>> [39m	            length = e.items.length;[31m
>> [39m	            for (var i_3 = 0; i_3 < length; i_3++) {[31m
>> [39m	                _this.removeRow(proxy, i_3 + e.from, e.items[i_3], template, hooks, animations);[31m
>> [39m	            }[31m
>> [39m	            indexTrigger.onNext(true);[31m
>> [39m	        }));[31m
>> [39m	        cleanup.add(list.itemsMoved.subscribe(function (e) {[31m
>> [39m	            _this.moveRow(proxy, e.from, e.to, e.items[0], template, hooks, animations, indexTrigger);[31m
>> [39m	            indexTrigger.onNext(true);[31m
>> [39m	        }));[31m
>> [39m	        cleanup.add(list.itemReplaced.subscribe(function (e) {[31m
>> [39m	            _this.rebindRow(proxy, e.from, e.items[0], template, indexTrigger);[31m
>> [39m	            indexTrigger.onNext(true);[31m
>> [39m	        }));[31m
>> [39m	        cleanup.add(list.shouldReset.subscribe(function (e) {[31m
>> [39m	            proxy.clear();[31m
>> [39m	            _this.appendAllRows(proxy, list, ctx, template, hooks, animations, indexTrigger, false);[31m
>> [39m	            indexTrigger.onNext(true);[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    ForEachBinding.prototype.applyValue = function (el, value, hooks, animations, template, ctx, initialApply, cleanup, setProxyFunc) {[31m
>> [39m	        var i, length;[31m
>> [39m	        if (initialApply) {[31m
>> [39m	            // clone to template[31m
>> [39m	            length = el.childNodes.length;[31m
>> [39m	            for (var i_4 = 0; i_4 < length; i_4++) {[31m
>> [39m	                template.push(el.childNodes[i_4].cloneNode(true));[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // perform initial clear[31m
>> [39m	        while (el.firstChild) {[31m
>> [39m	            el.removeChild(el.firstChild);[31m
>> [39m	        }[31m
>> [39m	        if (template.length === 0)[31m
>> [39m	            return; // nothing to do[31m
>> [39m	        var proxy;[31m
>> [39m	        var self = this;[31m
>> [39m	        var recalcIndextrigger;[31m
>> [39m	        function nodeInsertCB(node, callbackData) {[31m
>> [39m	            var item = callbackData.item;[31m
>> [39m	            var index = callbackData.index;[31m
>> [39m	            var indexDisp = callbackData.indexDisp;[31m
>> [39m	            if (node.nodeType === 1) {[31m
>> [39m	                // propagate index to state[31m
>> [39m	                var state = (self.domManager.getNodeState(node) || self.domManager.createNodeState());[31m
>> [39m	                state.model = item;[31m
>> [39m	                state.index = index;[31m
>> [39m	                self.domManager.setNodeState(node, state);[31m
>> [39m	                if (recalcIndextrigger != null && indexDisp != null) {[31m
>> [39m	                    indexDisp.addRef();[31m
>> [39m	                    state.cleanup.add(indexDisp);[31m
>> [39m	                }[31m
>> [39m	                self.domManager.applyBindings(item, node);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        function nodeRemoveCB(node) {[31m
>> [39m	            if (node.nodeType === 1) {[31m
>> [39m	                self.domManager.cleanNode(node);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        proxy = new VirtualChildNodes_1.default(el, false, nodeInsertCB, nodeRemoveCB);[31m
>> [39m	        if (setProxyFunc)[31m
>> [39m	            setProxyFunc(proxy);[31m
>> [39m	        cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            proxy = null;[31m
>> [39m	        }));[31m
>> [39m	        if (Array.isArray(value)) {[31m
>> [39m	            var arr = value;[31m
>> [39m	            // iterate once and be done with it[31m
>> [39m	            length = arr.length;[31m
>> [39m	            for (var i_5 = 0; i_5 < length; i_5++) {[31m
>> [39m	                this.appendRow(proxy, i_5, arr[i_5], ctx, template, hooks, animations, undefined, true);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else if (List_1.isList(value)) {[31m
>> [39m	            var list = value;[31m
>> [39m	            recalcIndextrigger = new Rx.Subject();[31m
>> [39m	            this.observeList(proxy, ctx, template, cleanup, list, hooks, animations, recalcIndextrigger);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    return ForEachBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = ForEachBinding;[31m
>> [39m	//# sourceMappingURL=ForEach.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/* 25 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* VirtualChildNodes implements consisent and predictable manipulation[31m
>> [39m	* of a DOM Node's childNodes collection regardless its the true contents[31m
>> [39m	* @class[31m
>> [39m	[1m*/[31m
>> [39m	var VirtualChildNodes = (function () {[31m
>> [39m	    function VirtualChildNodes(targetNode, initialSyncToTarget, insertCB, removeCB) {[31m
>> [39m	        this.childNodes = [];[31m
>> [39m	        this.targetNode = targetNode;[31m
>> [39m	        this.insertCB = insertCB;[31m
>> [39m	        this.removeCB = removeCB;[31m
>> [39m	        if (initialSyncToTarget) {[31m
>> [39m	            for (var i = 0; i < targetNode.childNodes.length; i++) {[31m
>> [39m	                this.childNodes.push(targetNode.childNodes[i]);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    VirtualChildNodes.prototype.appendChilds = function (nodes, callbackData) {[31m
>> [39m	        var length = nodes.length;[31m
>> [39m	        // append to proxy array[31m
>> [39m	        if (nodes.length > 1)[31m
>> [39m	            Array.prototype.push.apply(this.childNodes, nodes);[31m
>> [39m	        else[31m
>> [39m	            this.childNodes.push(nodes[0]);[31m
>> [39m	        // append to DOM[31m
>> [39m	        for (var i = 0; i < length; i++) {[31m
>> [39m	            this.targetNode.appendChild(nodes[i]);[31m
>> [39m	        }[31m
>> [39m	        // callback[31m
>> [39m	        if (this.insertCB) {[31m
>> [39m	            for (var i = 0; i < length; i++) {[31m
>> [39m	                this.insertCB(nodes[i], callbackData);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    VirtualChildNodes.prototype.insertChilds = function (index, nodes, callbackData) {[31m
>> [39m	        if (index === this.childNodes.length) {[31m
>> [39m	            this.appendChilds(nodes, callbackData);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            var refNode = this.childNodes[index];[31m
>> [39m	            var length_1 = nodes.length;[31m
>> [39m	            // insert into proxy array[31m
>> [39m	            Array.prototype.splice.apply(this.childNodes, [index, 0].concat(nodes));[31m
>> [39m	            // insert into DOM[31m
>> [39m	            for (var i = 0; i < length_1; i++) {[31m
>> [39m	                this.targetNode.insertBefore(nodes[i], refNode);[31m
>> [39m	            }[31m
>> [39m	            // callback[31m
>> [39m	            if (this.insertCB) {[31m
>> [39m	                for (var i = 0; i < length_1; i++) {[31m
>> [39m	                    this.insertCB(nodes[i], callbackData);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    VirtualChildNodes.prototype.removeChilds = function (index, count, keepDom) {[31m
>> [39m	        var node;[31m
>> [39m	        if (count === 0)[31m
>> [39m	            return [];[31m
>> [39m	        // extract removed nodes[31m
>> [39m	        var nodes = this.childNodes.slice(index, index + count);[31m
>> [39m	        // remove from proxy array[31m
>> [39m	        this.childNodes.splice(index, count);[31m
>> [39m	        if (!keepDom) {[31m
>> [39m	            // remove from DOM[31m
>> [39m	            var length_2 = nodes.length;[31m
>> [39m	            for (var i = 0; i < length_2; i++) {[31m
>> [39m	                node = nodes[i];[31m
>> [39m	                if (this.removeCB)[31m
>> [39m	                    this.removeCB(node);[31m
>> [39m	                this.targetNode.removeChild(node);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return nodes;[31m
>> [39m	    };[31m
>> [39m	    VirtualChildNodes.prototype.clear = function () {[31m
>> [39m	        // remove from DOM[31m
>> [39m	        var length = this.childNodes.length;[31m
>> [39m	        var node;[31m
>> [39m	        for (var i = 0; i < length; i++) {[31m
>> [39m	            node = this.childNodes[i];[31m
>> [39m	            if (this.removeCB)[31m
>> [39m	                this.removeCB(node);[31m
>> [39m	            this.targetNode.removeChild(node);[31m
>> [39m	        }[31m
>> [39m	        // reset proxy array[31m
>> [39m	        this.childNodes = [];[31m
>> [39m	    };[31m
>> [39m	    return VirtualChildNodes;[31m
>> [39m	})();[31m
>> [39m	exports.default = VirtualChildNodes;[31m
>> [39m	//# sourceMappingURL=VirtualChildNodes.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 26 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	"use strict";[31m
>> [39m	var RefCountDisposeWrapper = (function () {[31m
>> [39m	    function RefCountDisposeWrapper(inner, initialRefCount) {[31m
>> [39m	        if (initialRefCount === void 0) { initialRefCount = 1; }[31m
>> [39m	        this.inner = inner;[31m
>> [39m	        this.refCount = initialRefCount;[31m
>> [39m	    }[31m
>> [39m	    RefCountDisposeWrapper.prototype.addRef = function () {[31m
>> [39m	        this.refCount++;[31m
>> [39m	    };[31m
>> [39m	    RefCountDisposeWrapper.prototype.release = function () {[31m
>> [39m	        if (--this.refCount === 0) {[31m
>> [39m	            this.inner.dispose();[31m
>> [39m	            this.inner = null;[31m
>> [39m	        }[31m
>> [39m	        return this.refCount;[31m
>> [39m	    };[31m
>> [39m	    RefCountDisposeWrapper.prototype.dispose = function () {[31m
>> [39m	        this.release();[31m
>> [39m	    };[31m
>> [39m	    return RefCountDisposeWrapper;[31m
>> [39m	})();[31m
>> [39m	exports.default = RefCountDisposeWrapper;[31m
>> [39m	//# sourceMappingURL=RefCountDisposeWrapper.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 27 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var __extends = (this && this.__extends) || function (d, b) {[31m
>> [39m	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];[31m
>> [39m	    function __() { this.constructor = d; }[31m
>> [39m	    _[24m.prototype = b.prototype;[31m
>> [39m	    d.prototype = new [4m_();[31m
>> [39m	};[31m
>> [39m	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {[31m
>> [39m	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);[31m
>> [39m	    switch (arguments.length) {[31m
>> [39m	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);[31m
>> [39m	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);[31m
>> [39m	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);[31m
>> [39m	    }[31m
>> [39m	};[31m
>> [39m	var __metadata = (this && this.__metadata) || function (k, v) {[31m
>> [39m	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);[31m
>> [39m	};[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var Oid_1 = __webpack_require__(5);[31m
>> [39m	var IID_1 = __webpack_require__(9);[31m
>> [39m	var Lazy_1 = __webpack_require__(28);[31m
>> [39m	var ScheduledSubject_1 = __webpack_require__(29);[31m
>> [39m	var Events_1 = __webpack_require__(8);[31m
>> [39m	var RefCountDisposeWrapper_1 = __webpack_require__(26);[31m
>> [39m	var log = __webpack_require__(11);[31m
>> [39m	var Reflect_1 = __webpack_require__(3);[31m
>> [39m	var Injector_1 = __webpack_require__(1);[31m
>> [39m	var res = __webpack_require__(10);[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* ReactiveUI's awesome ReactiveList ported to Typescript[31m
>> [39m	* @class[31m
>> [39m	[1m/[31m
>> [39m	var ObservableList = (function () {[31m
>> [39m	    function ObservableList(initialContents, resetChangeThreshold, scheduler) {[31m
>> [39m	        if (resetChangeThreshold === void 0) { resetChangeThreshold = 0.3; }[31m
>> [39m	        if (scheduler === void 0) { scheduler = null; }[31m
>> [39m	        //////////////////////////[31m
>> [39m	        // Some array convenience members[31m
>> [39m	        this.push = this.add;[31m
>> [39m	        this.changeNotificationsSuppressed = 0;[31m
>> [39m	        this.propertyChangeWatchers = null;[31m
>> [39m	        this.resetChangeThreshold = 0;[31m
>> [39m	        this.resetSubCount = 0;[31m
>> [39m	        this.hasWhinedAboutNoResetSub = false;[31m
>> [39m	        this.app = Injector_1.injector.get(res.app);[31m
>> [39m	        this.setupRx(initialContents, resetChangeThreshold, scheduler);[31m
>> [39m	    }[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // wx.IDisposable implementation[31m
>> [39m	    ObservableList.prototype.dispose = function () {[31m
>> [39m	        this.clearAllPropertyChangeWatchers();[31m
>> [39m	    };[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "isReadOnly", {[31m
>> [39m	        ////////////////////[31m
>> [39m	        /// wx.IObservableList<T>[31m
>> [39m	        get: function () {[31m
>> [39m	            return false;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "itemsAdded", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._itemsAdded)[31m
>> [39m	                this._itemsAdded = this.itemsAddedSubject.value.asObservable();[31m
>> [39m	            return this._itemsAdded;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "beforeItemsAdded", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._beforeItemsAdded)[31m
>> [39m	                this._beforeItemsAdded = this.beforeItemsAddedSubject.value.asObservable();[31m
>> [39m	            return this._beforeItemsAdded;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "itemsRemoved", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._itemsRemoved)[31m
>> [39m	                this._itemsRemoved = this.itemsRemovedSubject.value.asObservable();[31m
>> [39m	            return this._itemsRemoved;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "beforeItemsRemoved", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._beforeItemsRemoved)[31m
>> [39m	                this._beforeItemsRemoved = this.beforeItemsRemovedSubject.value.asObservable();[31m
>> [39m	            return this._beforeItemsRemoved;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "itemReplaced", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._itemReplaced)[31m
>> [39m	                this._itemReplaced = this.itemReplacedSubject.value.asObservable();[31m
>> [39m	            return this._itemReplaced;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "beforeItemReplaced", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._beforeItemReplaced)[31m
>> [39m	                this._beforeItemReplaced = this.beforeItemReplacedSubject.value.asObservable();[31m
>> [39m	            return this._beforeItemReplaced;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "beforeItemsMoved", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._beforeItemsMoved)[31m
>> [39m	                this._beforeItemsMoved = this.beforeItemsMovedSubject.value.asObservable();[31m
>> [39m	            return this._beforeItemsMoved;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "itemsMoved", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._itemsMoved)[31m
>> [39m	                this._itemsMoved = this.itemsMovedSubject.value.asObservable();[31m
>> [39m	            return this._itemsMoved;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "lengthChanging", {[31m
>> [39m	        get: function () {[31m
>> [39m	            var _this = this;[31m
>> [39m	            if (!this._lengthChanging)[31m
>> [39m	                this._lengthChanging = this.listChanging.select(function (_) {[31m
>> [39m	                    return _this.inner.length;[31m
>> [39m	                }).distinctUntilChanged();[31m
>> [39m	            return this._lengthChanging;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "lengthChanged", {[31m
>> [39m	        get: function () {[31m
>> [39m	            var _this = this;[31m
>> [39m	            if (!this._lengthChanged)[31m
>> [39m	                this._lengthChanged = this.listChanged.select(function (_) {[31m
>> [39m	                    return _this.inner.length;[31m
>> [39m	                }).distinctUntilChanged();[31m
>> [39m	            return this._lengthChanged;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "itemChanging", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._itemChanging)[31m
>> [39m	                this._itemChanging = this.itemChangingSubject.value.asObservable();[31m
>> [39m	            return this._itemChanging;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "itemChanged", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this._itemChanged)[31m
>> [39m	                this._itemChanged = this.itemChangedSubject.value.asObservable();[31m
>> [39m	            return this._itemChanged;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "shouldReset", {[31m
>> [39m	        get: function () {[31m
>> [39m	            var _this = this;[31m
>> [39m	            return this.refcountSubscribers(this.listChanged.selectMany(function (x) { return !x ? Rx.Observable.empty() :[31m
>> [39m	                Rx.Observable.return(null); }), function (x) { return _this.resetSubCount += x; });[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    Object.defineProperty(ObservableList.prototype, "changeTrackingEnabled", {[31m
>> [39m	        get: function () {[31m
>> [39m	            return this.propertyChangeWatchers != null;[31m
>> [39m	        },[31m
>> [39m	        set: function (newValue) {[31m
>> [39m	            var _this = this;[31m
>> [39m	            if (this.propertyChangeWatchers != null && newValue)[31m
>> [39m	                return;[31m
>> [39m	            if (this.propertyChangeWatchers == null && !newValue)[31m
>> [39m	                return;[31m
>> [39m	            if (newValue) {[31m
>> [39m	                this.propertyChangeWatchers = {};[31m
>> [39m	                this.inner.forEach(function (x) { return _this.addItemToPropertyTracking(x); });[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                this.clearAllPropertyChangeWatchers();[31m
>> [39m	                this.propertyChangeWatchers = null;[31m
>> [39m	            }[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    ObservableList.prototype.addRange = function (items) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (items == null) {[31m
>> [39m	            Utils_1.throwError("items");[31m
>> [39m	        }[31m
>> [39m	        var disp = this.isLengthAboveResetThreshold(items.length) ? this.suppressChangeNotifications() : Rx.Disposable.empty;[31m
>> [39m	        Utils_1.using(disp, function () {[31m
>> [39m	            // reset notification[31m
>> [39m	            if (!_this.areChangeNotificationsEnabled()) {[31m
>> [39m	                // this._inner.splice(this._inner.length, 0, items)[31m
>> [39m	                Array.prototype.push.apply(_this.inner, items);[31m
>> [39m	                if (_this.changeTrackingEnabled) {[31m
>> [39m	                    items.forEach(function (x) {[31m
>> [39m	                        _this.addItemToPropertyTracking(x);[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                var from = _this.inner.length; // need to capture this before "inner" gets modified [31m
>> [39m	                if (_this.beforeItemsAddedSubject.isValueCreated) {[31m
>> [39m	                    _this.beforeItemsAddedSubject.value.onNext({ items: items, from: from });[31m
>> [39m	                }[31m
>> [39m	                Array.prototype.push.apply(_this.inner, items);[31m
>> [39m	                if (_this.itemsAddedSubject.isValueCreated) {[31m
>> [39m	                    _this.itemsAddedSubject.value.onNext({ items: items, from: from });[31m
>> [39m	                }[31m
>> [39m	                if (_this.changeTrackingEnabled) {[31m
>> [39m	                    items.forEach(function (x) {[31m
>> [39m	                        _this.addItemToPropertyTracking(x);[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.insertRange = function (index, items) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (items == null) {[31m
>> [39m	            Utils_1.throwError("collection");[31m
>> [39m	        }[31m
>> [39m	        if (index > this.inner.length) {[31m
>> [39m	            Utils_1.throwError("index");[31m
>> [39m	        }[31m
>> [39m	        var disp = this.isLengthAboveResetThreshold(items.length) ? this.suppressChangeNotifications() : Rx.Disposable.empty;[31m
>> [39m	        Utils_1.using(disp, function () {[31m
>> [39m	            // reset notification[31m
>> [39m	            if (!_this.areChangeNotificationsEnabled()) {[31m
>> [39m	                // this._inner.splice(index, 0, items)[31m
>> [39m	                Array.prototype.splice.apply(_this.inner, [index, 0].concat(items));[31m
>> [39m	                if (_this.changeTrackingEnabled) {[31m
>> [39m	                    items.forEach(function (x) {[31m
>> [39m	                        _this.addItemToPropertyTracking(x);[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                if (_this.beforeItemsAddedSubject.isValueCreated) {[31m
>> [39m	                    items.forEach(function (x) {[31m
>> [39m	                        _this.beforeItemsAddedSubject.value.onNext({ items: items, from: index });[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	                Array.prototype.splice.apply(_this.inner, [index, 0].concat(items));[31m
>> [39m	                if (_this.itemsAddedSubject.isValueCreated) {[31m
>> [39m	                    _this.itemsAddedSubject.value.onNext({ items: items, from: index });[31m
>> [39m	                }[31m
>> [39m	                if (_this.changeTrackingEnabled) {[31m
>> [39m	                    items.forEach(function (x) {[31m
>> [39m	                        _this.addItemToPropertyTracking(x);[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.removeAll = function (items) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (items == null) {[31m
>> [39m	            Utils_1.throwError("items");[31m
>> [39m	        }[31m
>> [39m	        var disp = this.isLengthAboveResetThreshold(items.length) ?[31m
>> [39m	            this.suppressChangeNotifications() : Rx.Disposable.empty;[31m
>> [39m	        Utils_1.using(disp, function () {[31m
>> [39m	            // NB: wx.If we don't do this, we'll break Collection<T>'s[31m
>> [39m	            // accounting of the length[31m
>> [39m	            items.forEach(function (x) { return _this.remove(x); });[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.removeRange = function (index, count) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var disp = this.isLengthAboveResetThreshold(count) ? this.suppressChangeNotifications() : Rx.Disposable.empty;[31m
>> [39m	        Utils_1.using(disp, function () {[31m
>> [39m	            // construct items[31m
>> [39m	            var items = _this.inner.slice(index, index + count);[31m
>> [39m	            // reset notification[31m
>> [39m	            if (!_this.areChangeNotificationsEnabled()) {[31m
>> [39m	                _this.inner.splice(index, count);[31m
>> [39m	                if (_this.changeTrackingEnabled) {[31m
>> [39m	                    items.forEach(function (x) {[31m
>> [39m	                        _this.removeItemFromPropertyTracking(x);[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                if (_this.beforeItemsRemovedSubject.isValueCreated) {[31m
>> [39m	                    items.forEach(function (x) {[31m
>> [39m	                        _this.beforeItemsRemovedSubject.value.onNext({ items: items, from: index });[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	                _this.inner.splice(index, count);[31m
>> [39m	                if (_this.changeTrackingEnabled) {[31m
>> [39m	                    items.forEach(function (x) {[31m
>> [39m	                        _this.removeItemFromPropertyTracking(x);[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	                if (_this.itemsRemovedSubject.isValueCreated) {[31m
>> [39m	                    items.forEach(function (x) {[31m
>> [39m	                        _this.itemsRemovedSubject.value.onNext({ items: items, from: index });[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.toArray = function () {[31m
>> [39m	        return this.inner;[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.reset = function () {[31m
>> [39m	        this.publishResetNotification();[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.add = function (item) {[31m
>> [39m	        this.insertItem(this.inner.length, item);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.clear = function () {[31m
>> [39m	        this.clearItems();[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.contains = function (item) {[31m
>> [39m	        return this.inner.indexOf(item) !== -1;[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.remove = function (item) {[31m
>> [39m	        var index = this.inner.indexOf(item);[31m
>> [39m	        if (index === -1)[31m
>> [39m	            return false;[31m
>> [39m	        this.removeItem(index);[31m
>> [39m	        return true;[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.indexOf = function (item) {[31m
>> [39m	        return this.inner.indexOf(item);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.insert = function (index, item) {[31m
>> [39m	        this.insertItem(index, item);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.removeAt = function (index) {[31m
>> [39m	        this.removeItem(index);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.move = function (oldIndex, newIndex) {[31m
>> [39m	        this.moveItem(oldIndex, newIndex);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.project = function () {[31m
>> [39m	        var args = Utils_1.args2Array(arguments);[31m
>> [39m	        var filter = args.shift();[31m
>> [39m	        if (filter != null && Utils_1.isRxObservable(filter)) {[31m
>> [39m	            return new ObservableListProjection(this, undefined, undefined, undefined, filter, args.shift());[31m
>> [39m	        }[31m
>> [39m	        var orderer = args.shift();[31m
>> [39m	        if (orderer != null && Utils_1.isRxObservable(orderer)) {[31m
>> [39m	            return new ObservableListProjection(this, filter, undefined, undefined, orderer, args.shift());[31m
>> [39m	        }[31m
>> [39m	        var selector = args.shift();[31m
>> [39m	        if (selector != null && Utils_1.isRxObservable(selector)) {[31m
>> [39m	            return new ObservableListProjection(this, filter, orderer, undefined, selector, args.shift());[31m
>> [39m	        }[31m
>> [39m	        return new ObservableListProjection(this, filter, orderer, selector, args.shift(), args.shift());[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.suppressChangeNotifications = function () {[31m
>> [39m	        var _this = this;[31m
>> [39m	        this.changeNotificationsSuppressed++;[31m
>> [39m	        if (!this.hasWhinedAboutNoResetSub && this.resetSubCount === 0 && !Utils_1.isInUnitTest()) {[31m
>> [39m	            log.info("suppressChangeNotifications was called (perhaps via addRange), yet you do not have a subscription to shouldReset. This probably isn't what you want, as itemsAdded and friends will appear to 'miss' items");[31m
>> [39m	            this.hasWhinedAboutNoResetSub = true;[31m
>> [39m	        }[31m
>> [39m	        return Rx.Disposable.create(function () {[31m
>> [39m	            _this.changeNotificationsSuppressed--;[31m
>> [39m	            if (_this.changeNotificationsSuppressed === 0) {[31m
>> [39m	                _this.publishBeforeResetNotification();[31m
>> [39m	                _this.publishResetNotification();[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.get = function (index) {[31m
>> [39m	        return this.inner[index];[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.set = function (index, item) {[31m
>> [39m	        if (!this.areChangeNotificationsEnabled()) {[31m
>> [39m	            if (this.changeTrackingEnabled) {[31m
>> [39m	                this.removeItemFromPropertyTracking(this.inner[index]);[31m
>> [39m	                this.addItemToPropertyTracking(item);[31m
>> [39m	            }[31m
>> [39m	            this.inner[index] = item;[31m
>> [39m	            return;[31m
>> [39m	        }[31m
>> [39m	        if (this.beforeItemReplacedSubject.isValueCreated)[31m
>> [39m	            this.beforeItemReplacedSubject.value.onNext({ from: index, items: [item] });[31m
>> [39m	        if (this.changeTrackingEnabled) {[31m
>> [39m	            this.removeItemFromPropertyTracking(this.inner[index]);[31m
>> [39m	            this.addItemToPropertyTracking(item);[31m
>> [39m	        }[31m
>> [39m	        this.inner[index] = item;[31m
>> [39m	        if (this.itemReplacedSubject.isValueCreated)[31m
>> [39m	            this.itemReplacedSubject.value.onNext({ from: index, items: [item] });[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.sort = function (comparison) {[31m
>> [39m	        this.publishBeforeResetNotification();[31m
>> [39m	        this.inner.sort(comparison);[31m
>> [39m	        this.publishResetNotification();[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.forEach = function (callbackfn, thisArg) {[31m
>> [39m	        this.inner.forEach(callbackfn, thisArg);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.map = function (callbackfn, thisArg) {[31m
>> [39m	        return this.inner.map(callbackfn, thisArg);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.filter = function (callbackfn, thisArg) {[31m
>> [39m	        return this.inner.filter(callbackfn, thisArg);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.some = function (callbackfn, thisArg) {[31m
>> [39m	        return this.inner.some(callbackfn, thisArg);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.every = function (callbackfn, thisArg) {[31m
>> [39m	        return this.inner.every(callbackfn, thisArg);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.setupRx = function (initialContents, resetChangeThreshold, scheduler) {[31m
>> [39m	        if (resetChangeThreshold === void 0) { resetChangeThreshold = 0.3; }[31m
>> [39m	        if (scheduler === void 0) { scheduler = null; }[31m
>> [39m	        scheduler = scheduler || Injector_1.injector.get(res.app).mainThreadScheduler;[31m
>> [39m	        this.resetChangeThreshold = resetChangeThreshold;[31m
>> [39m	        if (this.inner === undefined)[31m
>> [39m	            this.inner = new Array();[31m
>> [39m	        this.beforeItemsAddedSubject = new Lazy_1.default(function () { return new Rx.Subject(); });[31m
>> [39m	        this.itemsAddedSubject = new Lazy_1.default(function () { return new Rx.Subject(); });[31m
>> [39m	        this.beforeItemsRemovedSubject = new Lazy_1.default(function () { return new Rx.Subject(); });[31m
>> [39m	        this.itemsRemovedSubject = new Lazy_1.default(function () { return new Rx.Subject(); });[31m
>> [39m	        this.beforeItemReplacedSubject = new Lazy_1.default(function () { return new Rx.Subject(); });[31m
>> [39m	        this.itemReplacedSubject = new Lazy_1.default(function () { return new Rx.Subject(); });[31m
>> [39m	        this.resetSubject = new Rx.Subject();[31m
>> [39m	        this.beforeResetSubject = new Rx.Subject();[31m
>> [39m	        this.itemChangingSubject = new Lazy_1.default(function () {[31m
>> [39m	            return ScheduledSubject_1.createScheduledSubject(scheduler);[31m
>> [39m	        });[31m
>> [39m	        this.itemChangedSubject = new Lazy_1.default(function () {[31m
>> [39m	            return ScheduledSubject_1.createScheduledSubject(scheduler);[31m
>> [39m	        });[31m
>> [39m	        this.beforeItemsMovedSubject = new Lazy_1.default(function () { return new Rx.Subject(); });[31m
>> [39m	        this.itemsMovedSubject = new Lazy_1.default(function () { return new Rx.Subject(); });[31m
>> [39m	        this.listChanged = Rx.Observable.merge(this.itemsAdded.select(function (x) { return false; }), this.itemsRemoved.select(function (x) { return false; }), this.itemReplaced.select(function (x) { return false; }), this.itemsMoved.select(function (x) { return false; }), this.resetSubject.select(function (x) { return true; }))[31m
>> [39m	            .publish()[31m
>> [39m	            .refCount();[31m
>> [39m	        this.listChanging = Rx.Observable.merge(this.beforeItemsAdded.select(function (x) { return false; }), this.beforeItemsRemoved.select(function (x) { return false; }), this.beforeItemReplaced.select(function (x) { return false; }), this.beforeItemsMoved.select(function (x) { return false; }), this.beforeResetSubject.select(function (x) { return true; }))[31m
>> [39m	            .publish()[31m
>> [39m	            .refCount();[31m
>> [39m	        if (initialContents) {[31m
>> [39m	            Array.prototype.splice.apply(this.inner, [0, 0].concat(initialContents));[31m
>> [39m	        }[31m
>> [39m	        this.length = this.lengthChanged.toProperty(this.inner.length);[31m
>> [39m	        this.isEmpty = this.lengthChanged[31m
>> [39m	            .select(function (x) { return (x === 0); })[31m
>> [39m	            .toProperty(this.inner.length === 0);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.areChangeNotificationsEnabled = function () {[31m
>> [39m	        return this.changeNotificationsSuppressed === 0;[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.insertItem = function (index, item) {[31m
>> [39m	        if (!this.areChangeNotificationsEnabled()) {[31m
>> [39m	            this.inner.splice(index, 0, item);[31m
>> [39m	            if (this.changeTrackingEnabled)[31m
>> [39m	                this.addItemToPropertyTracking(item);[31m
>> [39m	            return;[31m
>> [39m	        }[31m
>> [39m	        if (this.beforeItemsAddedSubject.isValueCreated)[31m
>> [39m	            this.beforeItemsAddedSubject.value.onNext({ items: [item], from: index });[31m
>> [39m	        this.inner.splice(index, 0, item);[31m
>> [39m	        if (this.itemsAddedSubject.isValueCreated)[31m
>> [39m	            this.itemsAddedSubject.value.onNext({ items: [item], from: index });[31m
>> [39m	        if (this.changeTrackingEnabled)[31m
>> [39m	            this.addItemToPropertyTracking(item);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.removeItem = function (index) {[31m
>> [39m	        var item = this.inner[index];[31m
>> [39m	        if (!this.areChangeNotificationsEnabled()) {[31m
>> [39m	            this.inner.splice(index, 1);[31m
>> [39m	            if (this.changeTrackingEnabled)[31m
>> [39m	                this.removeItemFromPropertyTracking(item);[31m
>> [39m	            return;[31m
>> [39m	        }[31m
>> [39m	        if (this.beforeItemsRemovedSubject.isValueCreated)[31m
>> [39m	            this.beforeItemsRemovedSubject.value.onNext({ items: [item], from: index });[31m
>> [39m	        this.inner.splice(index, 1);[31m
>> [39m	        if (this.itemsRemovedSubject.isValueCreated)[31m
>> [39m	            this.itemsRemovedSubject.value.onNext({ items: [item], from: index });[31m
>> [39m	        if (this.changeTrackingEnabled)[31m
>> [39m	            this.removeItemFromPropertyTracking(item);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.moveItem = function (oldIndex, newIndex) {[31m
>> [39m	        var item = this.inner[oldIndex];[31m
>> [39m	        if (!this.areChangeNotificationsEnabled()) {[31m
>> [39m	            this.inner.splice(oldIndex, 1);[31m
>> [39m	            this.inner.splice(newIndex, 0, item);[31m
>> [39m	            return;[31m
>> [39m	        }[31m
>> [39m	        var mi = { items: [item], from: oldIndex, to: newIndex };[31m
>> [39m	        if (this.beforeItemsMovedSubject.isValueCreated)[31m
>> [39m	            this.beforeItemsMovedSubject.value.onNext(mi);[31m
>> [39m	        this.inner.splice(oldIndex, 1);[31m
>> [39m	        this.inner.splice(newIndex, 0, item);[31m
>> [39m	        if (this.itemsMovedSubject.isValueCreated)[31m
>> [39m	            this.itemsMovedSubject.value.onNext(mi);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.clearItems = function () {[31m
>> [39m	        if (!this.areChangeNotificationsEnabled()) {[31m
>> [39m	            this.inner.length = 0; // see http://stackoverflow.com/a/1232046/88513[31m
>> [39m	            if (this.changeTrackingEnabled)[31m
>> [39m	                this.clearAllPropertyChangeWatchers();[31m
>> [39m	            return;[31m
>> [39m	        }[31m
>> [39m	        this.publishBeforeResetNotification();[31m
>> [39m	        this.inner.length = 0; // see http://stackoverflow.com/a/1232046/88513[31m
>> [39m	        this.publishResetNotification();[31m
>> [39m	        if (this.changeTrackingEnabled)[31m
>> [39m	            this.clearAllPropertyChangeWatchers();[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.addItemToPropertyTracking = function (toTrack) {[31m
>> [39m	        var rcd = this.propertyChangeWatchers[Oid_1.getOid(toTrack)];[31m
>> [39m	        var self = this;[31m
>> [39m	        if (rcd) {[31m
>> [39m	            rcd.addRef();[31m
>> [39m	            return;[31m
>> [39m	        }[31m
>> [39m	        var changing = Utils_1.observeObject(toTrack, this.app.defaultExceptionHandler, true)[31m
>> [39m	            .select(function (i) { return new Events_1.PropertyChangedEventArgs(toTrack, i.propertyName); });[31m
>> [39m	        var changed = Utils_1.observeObject(toTrack, this.app.defaultExceptionHandler, false)[31m
>> [39m	            .select(function (i) { return new Events_1.PropertyChangedEventArgs(toTrack, i.propertyName); });[31m
>> [39m	        var disp = new Rx.CompositeDisposable(changing.where(function (_) { return self.areChangeNotificationsEnabled(); }).subscribe(function (x) { return self.itemChangingSubject.value.onNext(x); }), changed.where(function (_) { return self.areChangeNotificationsEnabled(); }).subscribe(function (x) { return self.itemChangedSubject.value.onNext(x); }));[31m
>> [39m	        this.propertyChangeWatchers[Oid_1.getOid(toTrack)] = new RefCountDisposeWrapper_1.default(Rx.Disposable.create(function () {[31m
>> [39m	            disp.dispose();[31m
>> [39m	            delete self.propertyChangeWatchers[Oid_1.getOid(toTrack)];[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.removeItemFromPropertyTracking = function (toUntrack) {[31m
>> [39m	        var rcd = this.propertyChangeWatchers[Oid_1.getOid(toUntrack)];[31m
>> [39m	        if (rcd) {[31m
>> [39m	            rcd.release();[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.clearAllPropertyChangeWatchers = function () {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (this.propertyChangeWatchers != null) {[31m
>> [39m	            Object.keys(this.propertyChangeWatchers).forEach(function (x) {[31m
>> [39m	                _this.propertyChangeWatchers[x].release();[31m
>> [39m	            });[31m
>> [39m	            this.propertyChangeWatchers = null;[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.refcountSubscribers = function (input, block) {[31m
>> [39m	        return Rx.Observable.create(function (subj) {[31m
>> [39m	            block(1);[31m
>> [39m	            return new Rx.CompositeDisposable(input.subscribe(subj), Rx.Disposable.create(function () { return block(-1); }));[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.publishResetNotification = function () {[31m
>> [39m	        this.resetSubject.onNext(true);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.publishBeforeResetNotification = function () {[31m
>> [39m	        this.beforeResetSubject.onNext(true);[31m
>> [39m	    };[31m
>> [39m	    ObservableList.prototype.isLengthAboveResetThreshold = function (toChangeLength) {[31m
>> [39m	        return toChangeLength / this.inner.length > this.resetChangeThreshold && toChangeLength > 10;[31m
>> [39m	    };[31m
>> [39m	    ObservableList = __decorate([[31m
>> [39m	        Reflect_1.Implements(IID_1.default.IObservableList),[31m
>> [39m	        Reflect_1.Implements(IID_1.default.IDisposable), [31m
>> [39m	        __metadata('design:paramtypes', [Array, Number, Object])[31m
>> [39m	    ], ObservableList);[31m
>> [39m	    return ObservableList;[31m
>> [39m	})();[31m
>> [39m	exports.ObservableList = ObservableList;[31m
>> [39m	var ObservableListProjection = (function (_super) {[31m
>> [39m	    __extends(ObservableListProjection, _super);[31m
>> [39m	    function ObservableListProjection(source, filter, orderer, selector, refreshTrigger, scheduler) {[31m
>> [39m	        _super.call(this);[31m
>> [39m	        ////////////////////[31m
>> [39m	        // wx.Implementation[31m
>> [39m	        this.readonlyExceptionMessage = "Derived collections cannot be modified.";[31m
>> [39m	        // This list maps indices in this collection to their corresponding indices in the source collection.[31m
>> [39m	        this.indexToSourceIndexMap = [];[31m
>> [39m	        this.sourceCopy = [];[31m
>> [39m	        this.disp = new Rx.CompositeDisposable();[31m
>> [39m	        this.source = source;[31m
>> [39m	        this.selector = selector || (function (x) { return x; });[31m
>> [39m	        this._filter = filter;[31m
>> [39m	        this.orderer = orderer;[31m
>> [39m	        this.refreshTrigger = refreshTrigger;[31m
>> [39m	        this.scheduler = scheduler || Rx.Scheduler.immediate;[31m
>> [39m	        this.addAllItemsFromSourceCollection();[31m
>> [39m	        this.wireUpChangeNotifications();[31m
>> [39m	    }[31m
>> [39m	    Object.defineProperty(ObservableListProjection.prototype, "isReadOnly", {[31m
>> [39m	        //////////////////////////////////[31m
>> [39m	        // ObservableList overrides to enforce readonly contract[31m
>> [39m	        get: function () {[31m
>> [39m	            return true;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    ObservableListProjection.prototype.set = function (index, item) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.addRange = function (items) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.insertRange = function (index, items) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.removeAll = function (items) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.removeRange = function (index, count) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.add = function (item) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.clear = function () {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.remove = function (item) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	        return undefined;[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.insert = function (index, item) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.removeAt = function (index) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.move = function (oldIndex, newIndex) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.sort = function (comparison) {[31m
>> [39m	        Utils_1.throwError(this.readonlyExceptionMessage);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.reset = function () {[31m
>> [39m	        var _this = this;[31m
>> [39m	        Utils_1.using(_super.prototype.suppressChangeNotifications.call(this), function () {[31m
>> [39m	            _super.prototype.clear.call(_this);[31m
>> [39m	            _this.addAllItemsFromSourceCollection();[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // wx.IDisposable implementation[31m
>> [39m	    ObservableListProjection.prototype.dispose = function () {[31m
>> [39m	        this.disp.dispose();[31m
>> [39m	        _super.prototype.dispose.call(this);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.referenceEquals = function (a, b) {[31m
>> [39m	        return Oid_1.getOid(a) === Oid_1.getOid(b);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.refresh = function () {[31m
>> [39m	        var length = this.sourceCopy.length;[31m
>> [39m	        for (var i = 0; i < length; i++) {[31m
>> [39m	            this.onItemChanged(this.sourceCopy[i]);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.wireUpChangeNotifications = function () {[31m
>> [39m	        var _this = this;[31m
>> [39m	        this.disp.add(this.source.itemsAdded.observeOn(this.scheduler).subscribe(function (e) {[31m
>> [39m	            _this.onItemsAdded(e);[31m
>> [39m	        }));[31m
>> [39m	        this.disp.add(this.source.itemsRemoved.observeOn(this.scheduler).subscribe(function (e) {[31m
>> [39m	            _this.onItemsRemoved(e);[31m
>> [39m	        }));[31m
>> [39m	        this.disp.add(this.source.itemsMoved.observeOn(this.scheduler).subscribe(function (e) {[31m
>> [39m	            _this.onItemsMoved(e);[31m
>> [39m	        }));[31m
>> [39m	        this.disp.add(this.source.itemReplaced.observeOn(this.scheduler).subscribe(function (e) {[31m
>> [39m	            _this.onItemsReplaced(e);[31m
>> [39m	        }));[31m
>> [39m	        this.disp.add(this.source.shouldReset.observeOn(this.scheduler).subscribe(function (e) {[31m
>> [39m	            _this.reset();[31m
>> [39m	        }));[31m
>> [39m	        this.disp.add(this.source.itemChanged.select(function (x) { return x.sender; }).observeOn(this.scheduler).subscribe(function (x) { return _this.onItemChanged(x); }));[31m
>> [39m	        if (this.refreshTrigger != null) {[31m
>> [39m	            this.disp.add(this.refreshTrigger.observeOn(this.scheduler).subscribe(function (_) { return _this.refresh(); }));[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.onItemsAdded = function (e) {[31m
>> [39m	        this.shiftIndicesAtOrOverThreshold(e.from, e.items.length);[31m
>> [39m	        for (var i = 0; i < e.items.length; i++) {[31m
>> [39m	            var sourceItem = e.items[i];[31m
>> [39m	            this.sourceCopy.splice(e.from + i, 0, sourceItem);[31m
>> [39m	            if (this._filter && !this._filter(sourceItem)) {[31m
>> [39m	                continue;[31m
>> [39m	            }[31m
>> [39m	            var destinationItem = this.selector(sourceItem);[31m
>> [39m	            this.nsertAndMap(e.from + i, destinationItem);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.onItemsRemoved = function (e) {[31m
>> [39m	        this.sourceCopy.splice(e.from, e.items.length);[31m
>> [39m	        for (var i = 0; i < e.items.length; i++) {[31m
>> [39m	            var destinationIndex = this.getIndexFromSourceIndex(e.from + i);[31m
>> [39m	            if (destinationIndex !== -1) {[31m
>> [39m	                this.emoveAt(destinationIndex);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        var removedCount = e.items.length;[31m
>> [39m	        this.shiftIndicesAtOrOverThreshold(e.from + removedCount, -removedCount);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.onItemsMoved = function (e) {[31m
>> [39m	        if (e.items.length > 1) {[31m
>> [39m	            Utils_1.throwError("Derived collections doesn't support multi-item moves");[31m
>> [39m	        }[31m
>> [39m	        if (e.from === e.to) {[31m
>> [39m	            return;[31m
>> [39m	        }[31m
>> [39m	        var oldSourceIndex = e.from;[31m
>> [39m	        var newSourceIndex = e.to;[31m
>> [39m	        this.sourceCopy.splice(oldSourceIndex, 1);[31m
>> [39m	        this.sourceCopy.splice(newSourceIndex, 0, e.items[0]);[31m
>> [39m	        var currentDestinationIndex = this.getIndexFromSourceIndex(oldSourceIndex);[31m
>> [39m	        this.moveSourceIndexInMap(oldSourceIndex, newSourceIndex);[31m
>> [39m	        if (currentDestinationIndex === -1) {[31m
>> [39m	            return;[31m
>> [39m	        }[31m
>> [39m	        if (this.orderer == null) {[31m
>> [39m	            // We mirror the order of the source collection so we'll perform the same move operation[31m
>> [39m	            // as the source. As is the case with when we have an orderer we don't test whether or not[31m
>> [39m	            // the item should be included or not here. wx.If it has been included at some point it'll[31m
>> [39m	            // stay included until onItemChanged picks up a change which filters it.[31m
>> [39m	            var newDestinationIndex = ObservableListProjection.newPositionForExistingItem2(this.indexToSourceIndexMap, newSourceIndex, currentDestinationIndex);[31m
>> [39m	            if (newDestinationIndex !== currentDestinationIndex) {[31m
>> [39m	                this.indexToSourceIndexMap.splice(currentDestinationIndex, 1);[31m
>> [39m	                this.indexToSourceIndexMap.splice(newDestinationIndex, 0, newSourceIndex);[31m
>> [39m	                _super.prototype.move.call(this, currentDestinationIndex, newDestinationIndex);[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                this.indexToSourceIndexMap[currentDestinationIndex] = newSourceIndex;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // TODO: Conceptually wx.I feel like we shouldn't concern ourselves with ordering when we [31m
>> [39m	            // receive a Move notification. wx.If it affects ordering it should be picked up by the[31m
>> [39m	            // onItemChange and resorted there instead.[31m
>> [39m	            this.indexToSourceIndexMap[currentDestinationIndex] = newSourceIndex;[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.onItemsReplaced = function (e) {[31m
>> [39m	        for (var i = 0; i < e.items.length; i++) {[31m
>> [39m	            var sourceItem = e.items[i];[31m
>> [39m	            this.sourceCopy[e.from + i] = sourceItem;[31m
>> [39m	            this.onItemChanged(sourceItem);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.onItemChanged = function (changedItem) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var sourceIndices = this.indexOfAll(this.sourceCopy, changedItem);[31m
>> [39m	        var shouldBeIncluded = !this._filter || this._filter(changedItem);[31m
>> [39m	        sourceIndices.forEach(function (sourceIndex) {[31m
>> [39m	            var currentDestinationIndex = _this.getIndexFromSourceIndex(sourceIndex);[31m
>> [39m	            var isIncluded = currentDestinationIndex >= 0;[31m
>> [39m	            if (isIncluded && !shouldBeIncluded) {[31m
>> [39m	                _this.emoveAt(currentDestinationIndex);[31m
>> [39m	            }[31m
>> [39m	            else if (!isIncluded && shouldBeIncluded) {[31m
>> [39m	                _this.nsertAndMap(sourceIndex, _this.selector(changedItem));[31m
>> [39m	            }[31m
>> [39m	            else if (isIncluded && shouldBeIncluded) {[31m
>> [39m	                // The item is already included and it should stay there but it's possible that the change that[31m
>> [39m	                // caused this event affects the ordering. This gets a little tricky so let's be verbose.[31m
>> [39m	                var newItem = _this.selector(changedItem);[31m
>> [39m	                if (_this.orderer == null) {[31m
>> [39m	                    // We don't have an orderer so we're currently using the source collection index for sorting [31m
>> [39m	                    // meaning that no item change will affect ordering. Look at our current item and see if it's[31m
>> [39m	                    // the exact (reference-wise) same object. wx.If it is then we're done, if it's not (for example [31m
>> [39m	                    // if it's an integer) we'll issue a replace event so that subscribers get the new value.[31m
>> [39m	                    if (!_this.referenceEquals(newItem, _this.get(currentDestinationIndex))) {[31m
>> [39m	                        _super.prototype.set.call(_this, currentDestinationIndex, newItem);[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    // Don't be tempted to just use the orderer to compare the new item with the previous since[31m
>> [39m	                    // they'll almost certainly be equal (for reference types). We need to test whether or not the[31m
>> [39m	                    // new item can stay in the same position that the current item is in without comparing them.[31m
>> [39m	                    if (_this.canItemStayAtPosition(newItem, currentDestinationIndex)) {[31m
>> [39m	                        // The new item should be in the same position as the current but there's no need to signal[31m
>> [39m	                        // that in case they are the same object.[31m
>> [39m	                        if (!_this.referenceEquals(newItem, _this.get(currentDestinationIndex))) {[31m
>> [39m	                            _super.prototype.set.call(_this, currentDestinationIndex, newItem);[31m
>> [39m	                        }[31m
>> [39m	                    }[31m
>> [39m	                    else {[31m
>> [39m	                        // The change is forcing us to reorder. We'll use a move operation if the item hasn't [31m
>> [39m	                        // changed (ie it's the same object) and we'll implement it as a remove and add if the[31m
>> [39m	                        // object has changed (ie the selector is not an identity function).[31m
>> [39m	                        if (_this.referenceEquals(newItem, _this.get(currentDestinationIndex))) {[31m
>> [39m	                            var newDestinationIndex = _this.newPositionForExistingItem(sourceIndex, currentDestinationIndex, newItem);[31m
>> [39m	                            // Debug.Assert(newDestinationIndex != currentDestinationIndex, "This can't be, canItemStayAtPosition said it this couldn't happen");[31m
>> [39m	                            _this.indexToSourceIndexMap.splice(currentDestinationIndex, 1);[31m
>> [39m	                            _this.indexToSourceIndexMap.splice(newDestinationIndex, 0, sourceIndex);[31m
>> [39m	                            _super.prototype.move.call(_this, currentDestinationIndex, newDestinationIndex);[31m
>> [39m	                        }[31m
>> [39m	                        else {[31m
>> [39m	                            _this.emoveAt(currentDestinationIndex);[31m
>> [39m	                            _this.nsertAndMap(sourceIndex, newItem);[31m
>> [39m	                        }[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// Gets a value indicating whether or not the item fits (sort-wise) at the provided index. The determination[31m
>> [39m	    /// is made by checking whether or not it's considered larger than or equal to the preceeding item and if[31m
>> [39m	    /// it's less than or equal to the succeeding item.[31m
>> [39m	    /// </summary>[31m
>> [39m	    ObservableListProjection.prototype.canItemStayAtPosition = function (item, currentIndex) {[31m
>> [39m	        var hasPrecedingItem = currentIndex > 0;[31m
>> [39m	        if (hasPrecedingItem) {[31m
>> [39m	            var isGreaterThanOrEqualToPrecedingItem = this.orderer(item, this[currentIndex - 1]) >= 0;[31m
>> [39m	            if (!isGreaterThanOrEqualToPrecedingItem) {[31m
>> [39m	                return false;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        var hasSucceedingItem = currentIndex < this.length() - 1;[31m
>> [39m	        if (hasSucceedingItem) {[31m
>> [39m	            var isLessThanOrEqualToSucceedingItem = this.orderer(item, this[currentIndex + 1]) <= 0;[31m
>> [39m	            if (!isLessThanOrEqualToSucceedingItem) {[31m
>> [39m	                return false;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return true;[31m
>> [39m	    };[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// Gets the index of the dervived item super. on it's originating element index in the source collection.[31m
>> [39m	    /// </summary>[31m
>> [39m	    ObservableListProjection.prototype.getIndexFromSourceIndex = function (sourceIndex) {[31m
>> [39m	        return this.indexToSourceIndexMap.indexOf(sourceIndex);[31m
>> [39m	    };[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// Returns one or more positions in the source collection where the given item is found super. on the[31m
>> [39m	    /// provided equality comparer.[31m
>> [39m	    /// </summary>[31m
>> [39m	    ObservableListProjection.prototype.indexOfAll = function (source, item) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var indices = [];[31m
>> [39m	        var sourceIndex = 0;[31m
>> [39m	        source.forEach(function (x) {[31m
>> [39m	            if (_this.referenceEquals(x, item)) {[31m
>> [39m	                indices.push(sourceIndex);[31m
>> [39m	            }[31m
>> [39m	            sourceIndex++;[31m
>> [39m	        });[31m
>> [39m	        return indices;[31m
>> [39m	    };[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// wx.Increases (or decreases depending on move direction) all source indices between the source and destination[31m
>> [39m	    /// move indices.[31m
>> [39m	    /// </summary>[31m
>> [39m	    ObservableListProjection.prototype.moveSourceIndexInMap = function (oldSourceIndex, newSourceIndex) {[31m
>> [39m	        if (newSourceIndex > oldSourceIndex) {[31m
>> [39m	            // wx.Item is moving towards the end of the list, everything between its current position and its [31m
>> [39m	            // new position needs to be shifted down one index[31m
>> [39m	            this.shiftSourceIndicesInRange(oldSourceIndex + 1, newSourceIndex + 1, -1);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // wx.Item is moving towards the front of the list, everything between its current position and its[31m
>> [39m	            // new position needs to be shifted up one index[31m
>> [39m	            this.shiftSourceIndicesInRange(newSourceIndex, oldSourceIndex, 1);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// wx.Increases (or decreases) all source indices equal to or higher than the threshold. Represents an[31m
>> [39m	    /// insert or remove of one or more items in the source list thus causing all subsequent items to shift[31m
>> [39m	    /// up or down.[31m
>> [39m	    /// </summary>[31m
>> [39m	    ObservableListProjection.prototype.shiftIndicesAtOrOverThreshold = function (threshold, value) {[31m
>> [39m	        for (var i = 0; i < this.indexToSourceIndexMap.length; i++) {[31m
>> [39m	            if (this.indexToSourceIndexMap[i] >= threshold) {[31m
>> [39m	                this.indexToSourceIndexMap[i] += value;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// wx.Increases (or decreases) all source indices within the range (lower inclusive, upper exclusive). [31m
>> [39m	    /// </summary>[31m
>> [39m	    ObservableListProjection.prototype.shiftSourceIndicesInRange = function (rangeStart, rangeStop, value) {[31m
>> [39m	        for (var i = 0; i < this.indexToSourceIndexMap.length; i++) {[31m
>> [39m	            var sourceIndex = this.indexToSourceIndexMap[i];[31m
>> [39m	            if (sourceIndex >= rangeStart && sourceIndex < rangeStop) {[31m
>> [39m	                this.indexToSourceIndexMap[i] += value;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.addAllItemsFromSourceCollection = function () {[31m
>> [39m	        var _this = this;[31m
>> [39m	        // Debug.Assert(sourceCopy.length == 0, "Expected source copy to be empty");[31m
>> [39m	        var sourceIndex = 0;[31m
>> [39m	        this.source.forEach(function (sourceItem) {[31m
>> [39m	            _this.sourceCopy.push(sourceItem);[31m
>> [39m	            if (!_this._filter || _this._filter(sourceItem)) {[31m
>> [39m	                var destinationItem = _this.selector(sourceItem);[31m
>> [39m	                _this.nsertAndMap(sourceIndex, destinationItem);[31m
>> [39m	            }[31m
>> [39m	            sourceIndex++;[31m
>> [39m	        });[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.lear = function () {[31m
>> [39m	        this.indexToSourceIndexMap = [];[31m
>> [39m	        this.sourceCopy = [];[31m
>> [39m	        _super.prototype.clear.call(this);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.nsertAndMap = function (sourceIndex, value) {[31m
>> [39m	        var destinationIndex = this.positionForNewItem(sourceIndex, value);[31m
>> [39m	        this.indexToSourceIndexMap.splice(destinationIndex, 0, sourceIndex);[31m
>> [39m	        _super.prototype.insert.call(this, destinationIndex, value);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.emoveAt = function (destinationIndex) {[31m
>> [39m	        this.indexToSourceIndexMap.splice(destinationIndex, 1);[31m
>> [39m	        _super.prototype.removeAt.call(this, destinationIndex);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.prototype.positionForNewItem = function (sourceIndex, value) {[31m
>> [39m	        // wx.If we haven't got an orderer we'll simply match our items to that of the source collection.[31m
>> [39m	        return this.orderer == null[31m
>> [39m	            ? ObservableListProjection.positionForNewItemArray(this.indexToSourceIndexMap, sourceIndex, ObservableListProjection.defaultOrderer)[31m
>> [39m	            : ObservableListProjection.positionForNewItemArray2(this.inner, 0, this.inner.length, value, this.orderer);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.positionForNewItemArray = function (array, item, orderer) {[31m
>> [39m	        return ObservableListProjection.positionForNewItemArray2(array, 0, array.length, item, orderer);[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.positionForNewItemArray2 = function (array, index, count, item, orderer) {[31m
>> [39m	        // Debug.Assert(index >= 0);[31m
>> [39m	        // Debug.Assert(count >= 0);[31m
>> [39m	        // Debug.Assert((list.length - index) >= count);[31m
>> [39m	        if (count === 0) {[31m
>> [39m	            return index;[31m
>> [39m	        }[31m
>> [39m	        if (count === 1) {[31m
>> [39m	            return orderer(array[index], item) >= 0 ? index : index + 1;[31m
>> [39m	        }[31m
>> [39m	        if (orderer(array[index], item) >= 1)[31m
>> [39m	            return index;[31m
>> [39m	        var low = index, hi = index + count - 1;[31m
>> [39m	        var cmp;[31m
>> [39m	        while (low <= hi) {[31m
>> [39m	            var mid = Math.floor(low + (hi - low) / 2);[31m
>> [39m	            cmp = orderer(array[mid], item);[31m
>> [39m	            if (cmp === 0) {[31m
>> [39m	                return mid;[31m
>> [39m	            }[31m
>> [39m	            if (cmp < 0) {[31m
>> [39m	                low = mid + 1;[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                hi = mid - 1;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return low;[31m
>> [39m	    };[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// Calculates a new destination for an updated item that's already in the list.[31m
>> [39m	    /// </summary>[31m
>> [39m	    ObservableListProjection.prototype.newPositionForExistingItem = function (sourceIndex, currentIndex, item) {[31m
>> [39m	        // wx.If we haven't got an orderer we'll simply match our items to that of the source collection.[31m
>> [39m	        return this.orderer == null[31m
>> [39m	            ? ObservableListProjection.newPositionForExistingItem2(this.indexToSourceIndexMap, sourceIndex, currentIndex)[31m
>> [39m	            : ObservableListProjection.newPositionForExistingItem2(this.inner, item, currentIndex, this.orderer);[31m
>> [39m	    };[31m
>> [39m	    /// <summary>[31m
>> [39m	    /// Calculates a new destination for an updated item that's already in the list.[31m
>> [39m	    /// </summary>[31m
>> [39m	    ObservableListProjection.newPositionForExistingItem2 = function (array, item, currentIndex, orderer) {[31m
>> [39m	        // Since the item changed is most likely a value type we must refrain from ever comparing it to itself.[31m
>> [39m	        // We do this by figuring out how the updated item compares to its neighbors. By knowing if it's[31m
>> [39m	        // less than or greater than either one of its neighbors we can limit the search range to a range exlusive[31m
>> [39m	        // of the current index.[31m
>> [39m	        // Debug.Assert(list.length > 0);[31m
>> [39m	        if (array.length === 1) {[31m
>> [39m	            return 0;[31m
>> [39m	        }[31m
>> [39m	        var precedingIndex = currentIndex - 1;[31m
>> [39m	        var succeedingIndex = currentIndex + 1;[31m
>> [39m	        // The item on the preceding or succeeding index relative to currentIndex.[31m
>> [39m	        var comparand = array[precedingIndex >= 0 ? precedingIndex : succeedingIndex];[31m
>> [39m	        if (orderer == null) {[31m
>> [39m	            orderer = ObservableListProjection.defaultOrderer;[31m
>> [39m	        }[31m
>> [39m	        // Compare that to the (potentially) new value.[31m
>> [39m	        var cmp = orderer(item, comparand);[31m
>> [39m	        var min = 0;[31m
>> [39m	        var max = array.length;[31m
>> [39m	        if (cmp === 0) {[31m
>> [39m	            // The new value is equal to the preceding or succeeding item, it may stay at the current position[31m
>> [39m	            return currentIndex;[31m
>> [39m	        }[31m
>> [39m	        else if (cmp > 0) {[31m
>> [39m	            // The new value is greater than the preceding or succeeding item, limit the search to indices after[31m
>> [39m	            // the succeeding item.[31m
>> [39m	            min = succeedingIndex;[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // The new value is less than the preceding or succeeding item, limit the search to indices before[31m
>> [39m	            // the preceding item.[31m
>> [39m	            max = precedingIndex;[31m
>> [39m	        }[31m
>> [39m	        // Bail if the search range is invalid.[31m
>> [39m	        if (min === array.length || max < 0) {[31m
>> [39m	            return currentIndex;[31m
>> [39m	        }[31m
>> [39m	        var ix = ObservableListProjection.positionForNewItemArray2(array, min, max - min, item, orderer);[31m
>> [39m	        // wx.If the item moves 'forward' in the collection we have to account for the index where[31m
>> [39m	        // the item currently resides getting removed first.[31m
>> [39m	        return ix >= currentIndex ? ix - 1 : ix;[31m
>> [39m	    };[31m
>> [39m	    ObservableListProjection.defaultOrderer = function (a, b) {[31m
>> [39m	        var result;[31m
>> [39m	        if (a == null && b == null)[31m
>> [39m	            result = 0;[31m
>> [39m	        else if (a == null)[31m
>> [39m	            result = -1;[31m
>> [39m	        else if (b == null)[31m
>> [39m	            result = 1;[31m
>> [39m	        else[31m
>> [39m	            result = a - b;[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    return ObservableListProjection;[31m
>> [39m	})(ObservableList);[31m
>> [39m	/*[22m[31m
>> [39m	* Creates a new observable list with optional default contents[31m
>> [39m	* @param {Array<T>} initialContents The initial contents of the list[31m
>> [39m	* @param {number = 0.3} resetChangeThreshold[31m
>> [39m	[1m/[31m
>> [39m	function list(initialContents, resetChangeThreshold, scheduler) {[31m
>> [39m	    if (resetChangeThreshold === void 0) { resetChangeThreshold = 0.3; }[31m
>> [39m	    if (scheduler === void 0) { scheduler = null; }[31m
>> [39m	    return new ObservableList(initialContents, resetChangeThreshold, scheduler);[31m
>> [39m	}[31m
>> [39m	exports.list = list;[31m
>> [39m	/*[22m[31m
>> [39m	* Determines if target is an instance of a IObservableList[31m
>> [39m	* @param {any} target[31m
>> [39m	[1m/[31m
>> [39m	function isList(target) {[31m
>> [39m	    if (target == null)[31m
>> [39m	        return false;[31m
>> [39m	    return target instanceof ObservableList;[31m
>> [39m	}[31m
>> [39m	exports.isList = isList;[31m
>> [39m	//# sourceMappingURL=List.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 28 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	"use strict";[31m
>> [39m	/*[22m[31m
>> [39m	* .Net's Lazy<T>[31m
>> [39m	* @class[31m
>> [39m	[1m/[31m
>> [39m	var Lazy = (function () {[31m
>> [39m	    function Lazy(createValue) {[31m
>> [39m	        this.createValue = createValue;[31m
>> [39m	    }[31m
>> [39m	    Object.defineProperty(Lazy.prototype, "value", {[31m
>> [39m	        get: function () {[31m
>> [39m	            if (!this.isValueCreated) {[31m
>> [39m	                this.createdValue = this.createValue();[31m
>> [39m	                this.isValueCreated = true;[31m
>> [39m	            }[31m
>> [39m	            return this.createdValue;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    return Lazy;[31m
>> [39m	})();[31m
>> [39m	exports.default = Lazy;[31m
>> [39m	//# sourceMappingURL=Lazy.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 29 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var ScheduledSubject = (function () {[31m
>> [39m	    function ScheduledSubject(scheduler, defaultObserver, defaultSubject) {[31m
>> [39m	        this._observerRefCount = 0;[31m
>> [39m	        this._defaultObserverSub = Rx.Disposable.empty;[31m
>> [39m	        this._scheduler = scheduler;[31m
>> [39m	        this._defaultObserver = defaultObserver;[31m
>> [39m	        this._subject = defaultSubject || new Rx.Subject();[31m
>> [39m	        if (defaultObserver != null) {[31m
>> [39m	            this._defaultObserverSub = this._subject[31m
>> [39m	                .observeOn(this._scheduler)[31m
>> [39m	                .subscribe(this._defaultObserver);[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    ScheduledSubject.prototype.dispose = function () {[31m
>> [39m	        if (Utils_1.isDisposable(this._subject)) {[31m
>> [39m	            this._subject.dispose();[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    ScheduledSubject.prototype.onCompleted = function () {[31m
>> [39m	        this._subject.onCompleted();[31m
>> [39m	    };[31m
>> [39m	    ScheduledSubject.prototype.onError = function (error) {[31m
>> [39m	        this._subject.onError(error);[31m
>> [39m	    };[31m
>> [39m	    ScheduledSubject.prototype.onNext = function (value) {[31m
>> [39m	        this._subject.onNext(value);[31m
>> [39m	    };[31m
>> [39m	    ScheduledSubject.prototype.subscribe = function (observer) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (this._defaultObserverSub)[31m
>> [39m	            this._defaultObserverSub.dispose();[31m
>> [39m	        this._observerRefCount++;[31m
>> [39m	        return new Rx.CompositeDisposable(this._subject.observeOn(this._scheduler).subscribe(observer), Rx.Disposable.create(function () {[31m
>> [39m	            if ((--_this._observerRefCount) <= 0 && _this._defaultObserver != null) {[31m
>> [39m	                _this._defaultObserverSub = _this._subject.observeOn(_this._scheduler).subscribe(_this._defaultObserver);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    return ScheduledSubject;[31m
>> [39m	})();[31m
>> [39m	function createScheduledSubject(scheduler, defaultObserver, defaultSubject) {[31m
>> [39m	    var scheduled = new ScheduledSubject(scheduler, defaultObserver, defaultSubject);[31m
>> [39m	    var result = Utils_1.extend(scheduled, new Rx.Subject(), true);[31m
>> [39m	    return result;[31m
>> [39m	}[31m
>> [39m	exports.createScheduledSubject = createScheduledSubject;[31m
>> [39m	//# sourceMappingURL=ScheduledSubject.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 30 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var Command_1 = __webpack_require__(19);[31m
>> [39m	"use strict";[31m
>> [39m	var EventBinding = (function () {[31m
>> [39m	    function EventBinding(domManager, app) {[31m
>> [39m	        this.priority = 0;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    EventBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("event-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        // create an observable for each event handler value[31m
>> [39m	        var tokens = this.domManager.getObjectLiteralTokens(options);[31m
>> [39m	        tokens.forEach(function (token) {[31m
>> [39m	            _this.wireEvent(el, token.value, token.key, ctx, state, module);[31m
>> [39m	        });[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    EventBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    EventBinding.prototype.wireEvent = function (el, value, eventName, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var exp = this.domManager.compileBindingOptions(value, module);[31m
>> [39m	        var command;[31m
>> [39m	        var commandParameter = undefined;[31m
>> [39m	        var obs = Rx.Observable.fromEvent(el, eventName);[31m
>> [39m	        if (typeof exp === "function") {[31m
>> [39m	            var handler = this.domManager.evaluateExpression(exp, ctx);[31m
>> [39m	            handler = Utils_1.unwrapProperty(handler);[31m
>> [39m	            if (Utils_1.isFunction(handler)) {[31m
>> [39m	                state.cleanup.add(obs.subscribe(function (e) {[31m
>> [39m	                    handler.apply(ctx.$data, [ctx, e]);[31m
>> [39m	                }));[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                if (Command_1.isCommand(handler)) {[31m
>> [39m	                    command = handler;[31m
>> [39m	                    state.cleanup.add(obs.subscribe(function (_) {[31m
>> [39m	                        command.execute(undefined);[31m
>> [39m	                    }));[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    // assumed to be an Rx.Observer[31m
>> [39m	                    var observer = handler;[31m
>> [39m	                    // subscribe event directly to observer[31m
>> [39m	                    state.cleanup.add(obs.subscribe(observer));[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else if (typeof exp === "object") {[31m
>> [39m	            var opt = exp;[31m
>> [39m	            command = this.domManager.evaluateExpression(opt.command, ctx);[31m
>> [39m	            command = Utils_1.unwrapProperty(command);[31m
>> [39m	            if (exp.hasOwnProperty("parameter"))[31m
>> [39m	                commandParameter = this.domManager.evaluateExpression(opt.parameter, ctx);[31m
>> [39m	            state.cleanup.add(obs.subscribe(function (_) {[31m
>> [39m	                try {[31m
>> [39m	                    command.execute(commandParameter);[31m
>> [39m	                }[31m
>> [39m	                catch (e) {[31m
>> [39m	                    _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                }[31m
>> [39m	            }));[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            Utils_1.throwError("invalid binding options");[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    return EventBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = EventBinding;[31m
>> [39m	//# sourceMappingURL=Event.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 31 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var res = __webpack_require__(10);[31m
>> [39m	"use strict";[31m
>> [39m	var ValueBinding = (function () {[31m
>> [39m	    function ValueBinding(domManager, app) {[31m
>> [39m	        this.priority = 5;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    ValueBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("value-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var tag = el.tagName.toLowerCase();[31m
>> [39m	        if (tag !== 'input' && tag !== 'option' && tag !== 'select' && tag !== 'textarea')[31m
>> [39m	            Utils_1.throwError("value-binding only operates on checkboxes and radio-buttons");[31m
>> [39m	        var useDomManagerForValueUpdates = (tag === 'input' && el.type === 'radio') || tag === 'option';[31m
>> [39m	        var prop;[31m
>> [39m	        var cleanup;[31m
>> [39m	        var exp = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        function doCleanup() {[31m
>> [39m	            if (cleanup) {[31m
>> [39m	                cleanup.dispose();[31m
>> [39m	                cleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        function updateElement(domManager, value) {[31m
>> [39m	            if (useDomManagerForValueUpdates)[31m
>> [39m	                setNodeValue(el, value, domManager);[31m
>> [39m	            else {[31m
>> [39m	                if ((value === null) || (value === undefined))[31m
>> [39m	                    value = "";[31m
>> [39m	                el.value = value;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // options is supposed to be a field-access path[31m
>> [39m	        state.cleanup.add(this.domManager.expressionToObservable(exp, ctx).subscribe(function (model) {[31m
>> [39m	            try {[31m
>> [39m	                if (!Utils_1.isProperty(model)) {[31m
>> [39m	                    // initial and final update[31m
>> [39m	                    updateElement(_this.domManager, model);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    doCleanup();[31m
>> [39m	                    cleanup = new Rx.CompositeDisposable();[31m
>> [39m	                    // update on property change[31m
>> [39m	                    prop = model;[31m
>> [39m	                    cleanup.add(prop.changed.subscribe(function (x) {[31m
>> [39m	                        updateElement(_this.domManager, x);[31m
>> [39m	                    }));[31m
>> [39m	                    // initial update[31m
>> [39m	                    updateElement(_this.domManager, prop());[31m
>> [39m	                    // don't attempt to updated computed properties[31m
>> [39m	                    if (!prop.source) {[31m
>> [39m	                        cleanup.add(Rx.Observable.fromEvent(el, 'change').subscribe(function (e) {[31m
>> [39m	                            try {[31m
>> [39m	                                if (useDomManagerForValueUpdates)[31m
>> [39m	                                    prop(getNodeValue(el, _this.domManager));[31m
>> [39m	                                else[31m
>> [39m	                                    prop(el.value);[31m
>> [39m	                            }[31m
>> [39m	                            catch (e) {[31m
>> [39m	                                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                            }[31m
>> [39m	                        }));[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            doCleanup();[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    ValueBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    return ValueBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = ValueBinding;[31m
>> [39m	/*[22m[31m
>> [39m	 * For certain elements such as select and input type=radio we store[31m
>> [39m	 * the real element value in NodeState if it is anything other than a[31m
>> [39m	 * string. This method returns that value.[31m
>> [39m	 * @param {Node} node[31m
>> [39m	 * @param {IDomManager} domManager[31m
>> [39m	 [1m/[31m
>> [39m	function getNodeValue(node, domManager) {[31m
>> [39m	    var state = domManager.getNodeState(node);[31m
>> [39m	    if (state != null && state[res.hasValueBindingValue]) {[31m
>> [39m	        return state[res.valueBindingValue];[31m
>> [39m	    }[31m
>> [39m	    return node.value;[31m
>> [39m	}[31m
>> [39m	exports.getNodeValue = getNodeValue;[31m
>> [39m	/*[22m[31m
>> [39m	 * Associate a value with an element. Either by using its value-attribute[31m
>> [39m	 * or storing it in NodeState[31m
>> [39m	 * @param {Node} node[31m
>> [39m	 * @param {any} value[31m
>> [39m	 * @param {IDomManager} domManager[31m
>> [39m	 [1m/[31m
>> [39m	function setNodeValue(node, value, domManager) {[31m
>> [39m	    if ((value === null) || (value === undefined))[31m
>> [39m	        value = "";[31m
>> [39m	    var state = domManager.getNodeState(node);[31m
>> [39m	    if (typeof value === "string") {[31m
>> [39m	        // Update the element only if the element and model are different. On some browsers, updating the value[31m
>> [39m	        // will move the cursor to the end of the input, which would be bad while the user is typing.[31m
>> [39m	        if (node.value !== value) {[31m
>> [39m	            node.value = value;[31m
>> [39m	            // clear state since value is stored in attribute[31m
>> [39m	            if (state != null && state[res.hasValueBindingValue]) {[31m
>> [39m	                state[res.hasValueBindingValue] = false;[31m
>> [39m	                state[res.valueBindingValue] = undefined;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    else {[31m
>> [39m	        // get or create state[31m
>> [39m	        if (state == null) {[31m
>> [39m	            state = this.createNodeState();[31m
>> [39m	            this.setNodeState(node, state);[31m
>> [39m	        }[31m
>> [39m	        // store value[31m
>> [39m	        state[res.valueBindingValue] = value;[31m
>> [39m	        state[res.hasValueBindingValue] = true;[31m
>> [39m	    }[31m
>> [39m	}[31m
>> [39m	exports.setNodeValue = setNodeValue;[31m
>> [39m	//# sourceMappingURL=Value.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 32 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var HasFocusBinding = (function () {[31m
>> [39m	    function HasFocusBinding(domManager, app) {[31m
>> [39m	        this.priority = -1;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    HasFocusBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("hasFocus-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var prop;[31m
>> [39m	        var cleanup;[31m
>> [39m	        var compiled = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var exp;[31m
>> [39m	        var delay = 0;[31m
>> [39m	        if (typeof compiled === "object" && compiled.hasOwnProperty("property")) {[31m
>> [39m	            var opt = compiled;[31m
>> [39m	            exp = opt.property;[31m
>> [39m	            delay = this.domManager.evaluateExpression(opt.delay, ctx);[31m
>> [39m	            // convert boolean to number[31m
>> [39m	            if (typeof delay === "boolean")[31m
>> [39m	                delay = delay ? 1 : 0;[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            exp = compiled;[31m
>> [39m	        }[31m
>> [39m	        function doCleanup() {[31m
>> [39m	            if (cleanup) {[31m
>> [39m	                cleanup.dispose();[31m
>> [39m	                cleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        function handleElementFocusChange(isFocused) {[31m
>> [39m	            // wx.If possible, ignore which event was raised and determine focus state using activeElement,[31m
>> [39m	            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.[31m
>> [39m	            var ownerDoc = el.ownerDocument;[31m
>> [39m	            if ("activeElement" in ownerDoc) {[31m
>> [39m	                var active;[31m
>> [39m	                try {[31m
>> [39m	                    active = ownerDoc.activeElement;[31m
>> [39m	                }[31m
>> [39m	                catch (e) {[31m
>> [39m	                    // wx.IE9 throws if you access activeElement during page load (see issue #703)[31m
>> [39m	                    active = ownerDoc.body;[31m
>> [39m	                }[31m
>> [39m	                isFocused = (active === el);[31m
>> [39m	            }[31m
>> [39m	            prop(isFocused);[31m
>> [39m	        }[31m
>> [39m	        function updateElement(value) {[31m
>> [39m	            if (value) {[31m
>> [39m	                // Note: wx.If the element is currently hidden, we schedule the focus change[31m
>> [39m	                // to occur "soonish". Technically this is a hack because it hides the fact[31m
>> [39m	                // that we make tricky assumption about the presence of a "visible" binding [31m
>> [39m	                // on the same element who's subscribe handler runs after us [31m
>> [39m	                if (delay === 0 && el.style.display !== 'none') {[31m
>> [39m	                    el.focus();[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    Rx.Observable.timer(delay).subscribe(function () {[31m
>> [39m	                        el.focus();[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                el.blur();[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // options is supposed to be a @propref[31m
>> [39m	        state.cleanup.add(this.domManager.expressionToObservable(exp, ctx).subscribe(function (model) {[31m
>> [39m	            try {[31m
>> [39m	                if (!Utils_1.isProperty(model)) {[31m
>> [39m	                    // initial and final update[31m
>> [39m	                    updateElement(model);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    doCleanup();[31m
>> [39m	                    cleanup = new Rx.CompositeDisposable();[31m
>> [39m	                    // update on property change[31m
>> [39m	                    prop = model;[31m
>> [39m	                    cleanup.add(prop.changed.subscribe(function (x) {[31m
>> [39m	                        updateElement(x);[31m
>> [39m	                    }));[31m
>> [39m	                    // initial update[31m
>> [39m	                    updateElement(prop());[31m
>> [39m	                    // don't attempt to updated computed properties[31m
>> [39m	                    if (!prop.source) {[31m
>> [39m	                        cleanup.add(Rx.Observable.merge(_this.getFocusEventObservables(el)).subscribe(function (hasFocus) {[31m
>> [39m	                            handleElementFocusChange(hasFocus);[31m
>> [39m	                        }));[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            doCleanup();[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    HasFocusBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    HasFocusBinding.prototype.getFocusEventObservables = function (el) {[31m
>> [39m	        var result = [];[31m
>> [39m	        result.push(Rx.Observable.fromEvent(el, 'focus').select(function (x) { return true; }));[31m
>> [39m	        result.push(Rx.Observable.fromEvent(el, 'focusin').select(function (x) { return true; }));[31m
>> [39m	        result.push(Rx.Observable.fromEvent(el, 'blur').select(function (x) { return false; }));[31m
>> [39m	        result.push(Rx.Observable.fromEvent(el, 'focusout').select(function (x) { return false; }));[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    return HasFocusBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = HasFocusBinding;[31m
>> [39m	//# sourceMappingURL=HasFocus.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 33 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var WithBinding = (function () {[31m
>> [39m	    function WithBinding(domManager, app) {[31m
>> [39m	        this.priority = 50;[31m
>> [39m	        this.controlsDescendants = true;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    WithBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("with-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var self = this;[31m
>> [39m	        var exp = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var obs = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	        // subscribe[31m
>> [39m	        state.cleanup.add(obs.subscribe(function (x) {[31m
>> [39m	            try {[31m
>> [39m	                self.applyValue(el, Utils_1.unwrapProperty(x), state);[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            obs = null;[31m
>> [39m	            el = null;[31m
>> [39m	            self = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    WithBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    WithBinding.prototype.applyValue = function (el, value, state) {[31m
>> [39m	        state.model = value;[31m
>> [39m	        var ctx = this.domManager.getDataContext(el);[31m
>> [39m	        this.domManager.cleanDescendants(el);[31m
>> [39m	        this.domManager.applyBindingsToDescendants(ctx, el);[31m
>> [39m	    };[31m
>> [39m	    return WithBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = WithBinding;[31m
>> [39m	//# sourceMappingURL=With.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 34 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var CheckedBinding = (function () {[31m
>> [39m	    function CheckedBinding(domManager, app) {[31m
>> [39m	        this.priority = 0;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    CheckedBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("checked-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var tag = el.tagName.toLowerCase();[31m
>> [39m	        var isCheckBox = el.type === 'checkbox';[31m
>> [39m	        var isRadioButton = el.type === 'radio';[31m
>> [39m	        if (tag !== 'input' || (!isCheckBox && !isRadioButton))[31m
>> [39m	            Utils_1.throwError("checked-binding only operates on checkboxes and radio-buttons");[31m
>> [39m	        var exp = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var prop;[31m
>> [39m	        var cleanup;[31m
>> [39m	        function doCleanup() {[31m
>> [39m	            if (cleanup) {[31m
>> [39m	                cleanup.dispose();[31m
>> [39m	                cleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        function updateElement(value) {[31m
>> [39m	            el.checked = value;[31m
>> [39m	        }[31m
>> [39m	        state.cleanup.add(this.domManager.expressionToObservable(exp, ctx).subscribe(function (model) {[31m
>> [39m	            try {[31m
>> [39m	                if (!Utils_1.isProperty(model)) {[31m
>> [39m	                    // initial and final update[31m
>> [39m	                    updateElement(model);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    doCleanup();[31m
>> [39m	                    cleanup = new Rx.CompositeDisposable();[31m
>> [39m	                    // update on property change[31m
>> [39m	                    prop = model;[31m
>> [39m	                    cleanup.add(prop.changed.subscribe(function (x) {[31m
>> [39m	                        updateElement(x);[31m
>> [39m	                    }));[31m
>> [39m	                    // initial update[31m
>> [39m	                    updateElement(prop());[31m
>> [39m	                    // don't attempt to updated computed properties[31m
>> [39m	                    if (!prop.source) {[31m
>> [39m	                        // wire change-events depending on browser and version[31m
>> [39m	                        var events = _this.getCheckedEventObservables(el);[31m
>> [39m	                        cleanup.add(Rx.Observable.merge(events).subscribe(function (e) {[31m
>> [39m	                            try {[31m
>> [39m	                                prop(el.checked);[31m
>> [39m	                            }[31m
>> [39m	                            catch (e) {[31m
>> [39m	                                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                            }[31m
>> [39m	                        }));[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            doCleanup();[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    CheckedBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    CheckedBinding.prototype.getCheckedEventObservables = function (el) {[31m
>> [39m	        var result = [];[31m
>> [39m	        result.push(Rx.Observable.fromEvent(el, 'click'));[31m
>> [39m	        result.push(Rx.Observable.fromEvent(el, 'change'));[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    return CheckedBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = CheckedBinding;[31m
>> [39m	//# sourceMappingURL=Checked.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 35 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var Command_1 = __webpack_require__(19);[31m
>> [39m	"use strict";[31m
>> [39m	var keysByCode = {[31m
>> [39m	    8: 'backspace',[31m
>> [39m	    9: 'tab',[31m
>> [39m	    13: 'enter',[31m
>> [39m	    27: 'esc',[31m
>> [39m	    32: 'space',[31m
>> [39m	    33: 'pageup',[31m
>> [39m	    34: 'pagedown',[31m
>> [39m	    35: 'end',[31m
>> [39m	    36: 'home',[31m
>> [39m	    37: 'left',[31m
>> [39m	    38: 'up',[31m
>> [39m	    39: 'right',[31m
>> [39m	    40: 'down',[31m
>> [39m	    45: 'insert',[31m
>> [39m	    46: 'delete'[31m
>> [39m	};[31m
>> [39m	var KeyPressBinding = (function () {[31m
>> [39m	    function KeyPressBinding(domManager, app) {[31m
>> [39m	        this.priority = 0;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    KeyPressBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("keyPress-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        // create an observable for key combination[31m
>> [39m	        var tokens = this.domManager.getObjectLiteralTokens(options);[31m
>> [39m	        var obs = Rx.Observable.fromEvent(el, "keydown")[31m
>> [39m	            .where(function (x) { return !x.repeat; })[31m
>> [39m	            .publish()[31m
>> [39m	            .refCount();[31m
>> [39m	        tokens.forEach(function (token) {[31m
>> [39m	            var keyDesc = token.key;[31m
>> [39m	            var combination, combinations = [];[31m
>> [39m	            // parse key combinations[31m
>> [39m	            keyDesc.split(' ').forEach(function (variation) {[31m
>> [39m	                combination = {[31m
>> [39m	                    expression: keyDesc,[31m
>> [39m	                    keys: {}[31m
>> [39m	                };[31m
>> [39m	                variation.split('-').forEach(function (value) {[31m
>> [39m	                    combination.keys[value.trim()] = true;[31m
>> [39m	                });[31m
>> [39m	                combinations.push(combination);[31m
>> [39m	            });[31m
>> [39m	            _this.wireKey(token.value, obs, combinations, ctx, state, module);[31m
>> [39m	        });[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    KeyPressBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    KeyPressBinding.prototype.testCombination = function (combination, event) {[31m
>> [39m	        var metaPressed = !!(event.metaKey && !event.ctrlKey);[31m
>> [39m	        var altPressed = !!event.altKey;[31m
>> [39m	        var ctrlPressed = !!event.ctrlKey;[31m
>> [39m	        var shiftPressed = !!event.shiftKey;[31m
>> [39m	        var keyCode = event.keyCode;[31m
>> [39m	        var metaRequired = !!combination.keys.meta;[31m
>> [39m	        var altRequired = !!combination.keys.alt;[31m
>> [39m	        var ctrlRequired = !!combination.keys.ctrl;[31m
>> [39m	        var shiftRequired = !!combination.keys.shift;[31m
>> [39m	        // normalize keycodes[31m
>> [39m	        if ((!shiftPressed || shiftRequired) && keyCode >= 65 && keyCode <= 90)[31m
>> [39m	            keyCode = keyCode + 32;[31m
>> [39m	        var mainKeyPressed = combination.keys[keysByCode[keyCode]] || combination.keys[keyCode.toString()] || combination.keys[String.fromCharCode(keyCode)];[31m
>> [39m	        return (mainKeyPressed &&[31m
>> [39m	            (metaRequired === metaPressed) &&[31m
>> [39m	            (altRequired === altPressed) &&[31m
>> [39m	            (ctrlRequired === ctrlPressed) &&[31m
>> [39m	            (shiftRequired === shiftPressed));[31m
>> [39m	    };[31m
>> [39m	    KeyPressBinding.prototype.testCombinations = function (combinations, event) {[31m
>> [39m	        for (var i = 0; i < combinations.length; i++) {[31m
>> [39m	            if (this.testCombination(combinations[i], event))[31m
>> [39m	                return true;[31m
>> [39m	        }[31m
>> [39m	        return false;[31m
>> [39m	    };[31m
>> [39m	    KeyPressBinding.prototype.wireKey = function (value, obs, combinations, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var exp = this.domManager.compileBindingOptions(value, module);[31m
>> [39m	        var command;[31m
>> [39m	        var commandParameter = undefined;[31m
>> [39m	        if (typeof exp === "function") {[31m
>> [39m	            var handler = this.domManager.evaluateExpression(exp, ctx);[31m
>> [39m	            handler = Utils_1.unwrapProperty(handler);[31m
>> [39m	            if (!Command_1.isCommand(handler)) {[31m
>> [39m	                state.cleanup.add(obs.where(function (e) { return _this.testCombinations(combinations, e); }).subscribe(function (e) {[31m
>> [39m	                    try {[31m
>> [39m	                        handler.apply(ctx.$data, [ctx]);[31m
>> [39m	                        e.preventDefault();[31m
>> [39m	                    }[31m
>> [39m	                    catch (e) {[31m
>> [39m	                        _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                    }[31m
>> [39m	                }));[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                command = handler;[31m
>> [39m	                state.cleanup.add(obs.where(function (e) { return _this.testCombinations(combinations, e); }).subscribe(function (e) {[31m
>> [39m	                    try {[31m
>> [39m	                        command.execute(undefined);[31m
>> [39m	                        e.preventDefault();[31m
>> [39m	                    }[31m
>> [39m	                    catch (e) {[31m
>> [39m	                        _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                    }[31m
>> [39m	                }));[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else if (typeof exp === "object") {[31m
>> [39m	            command = this.domManager.evaluateExpression(exp.command, ctx);[31m
>> [39m	            command = Utils_1.unwrapProperty(command);[31m
>> [39m	            if (exp.hasOwnProperty("parameter"))[31m
>> [39m	                commandParameter = this.domManager.evaluateExpression(exp.parameter, ctx);[31m
>> [39m	            state.cleanup.add(obs.where(function (e) { return _this.testCombinations(combinations, e); }).subscribe(function (e) {[31m
>> [39m	                try {[31m
>> [39m	                    command.execute(commandParameter);[31m
>> [39m	                    e.preventDefault();[31m
>> [39m	                }[31m
>> [39m	                catch (e) {[31m
>> [39m	                    _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                }[31m
>> [39m	            }));[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            Utils_1.throwError("invalid binding options");[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    return KeyPressBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = KeyPressBinding;[31m
>> [39m	//# sourceMappingURL=KeyPress.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 36 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var env = __webpack_require__(16);[31m
>> [39m	"use strict";[31m
>> [39m	var TextInputBinding = (function () {[31m
>> [39m	    function TextInputBinding(domManager, app) {[31m
>> [39m	        this.priority = 0;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    TextInputBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("textInput-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var tag = el.tagName.toLowerCase();[31m
>> [39m	        var isTextArea = tag === "textarea";[31m
>> [39m	        if (tag !== 'input' && tag !== 'textarea')[31m
>> [39m	            Utils_1.throwError("textInput-binding can only be applied to input or textarea elements");[31m
>> [39m	        var exp = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var prop;[31m
>> [39m	        var propertySubscription;[31m
>> [39m	        var eventSubscription;[31m
>> [39m	        var previousElementValue;[31m
>> [39m	        function updateElement(value) {[31m
>> [39m	            if (value === null || value === undefined) {[31m
>> [39m	                value = "";[31m
>> [39m	            }[31m
>> [39m	            // Update the element only if the element and model are different. On some browsers, updating the value[31m
>> [39m	            // will move the cursor to the end of the input, which would be bad while the user is typing.[31m
>> [39m	            if (el.value !== value) {[31m
>> [39m	                previousElementValue = value; // Make sure we ignore events (propertychange) that result from updating the value[31m
>> [39m	                el.value = value;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        function doCleanup() {[31m
>> [39m	            if (propertySubscription) {[31m
>> [39m	                propertySubscription.dispose();[31m
>> [39m	                propertySubscription = null;[31m
>> [39m	            }[31m
>> [39m	            if (eventSubscription) {[31m
>> [39m	                eventSubscription.dispose();[31m
>> [39m	                eventSubscription = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        state.cleanup.add(this.domManager.expressionToObservable(exp, ctx).subscribe(function (src) {[31m
>> [39m	            try {[31m
>> [39m	                if (!Utils_1.isProperty(src)) {[31m
>> [39m	                    // initial and final update[31m
>> [39m	                    updateElement(src);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    doCleanup();[31m
>> [39m	                    // update on property change[31m
>> [39m	                    prop = src;[31m
>> [39m	                    propertySubscription = prop.changed.subscribe(function (x) {[31m
>> [39m	                        updateElement(x);[31m
>> [39m	                    });[31m
>> [39m	                    // initial update[31m
>> [39m	                    updateElement(prop());[31m
>> [39m	                    // don't attempt to updated computed properties[31m
>> [39m	                    if (!prop.source) {[31m
>> [39m	                        // wire change-events depending on browser and version[31m
>> [39m	                        var events = _this.getTextInputEventObservables(el, isTextArea);[31m
>> [39m	                        eventSubscription = Rx.Observable.merge(events).subscribe(function (e) {[31m
>> [39m	                            try {[31m
>> [39m	                                prop(el.value);[31m
>> [39m	                            }[31m
>> [39m	                            catch (e) {[31m
>> [39m	                                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                            }[31m
>> [39m	                        });[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            doCleanup();[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    TextInputBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    TextInputBinding.prototype.getTextInputEventObservables = function (el, isTextArea) {[31m
>> [39m	        var result = [];[31m
>> [39m	        if (env.ie && env.ie.version < 10) {[31m
>> [39m	            if (env.ie.version <= 9) {[31m
>> [39m	                // wx.Internet Explorer 9 doesn't fire the 'input' event when deleting text, including using[31m
>> [39m	                // the backspace, delete, or ctrl-x keys, clicking the 'x' to clear the input, dragging text[31m
>> [39m	                // out of the field, and cutting or deleting text using the context menu. 'selectionchange'[31m
>> [39m	                // can detect all of those except dragging text out of the field, for which we use 'dragend'.[31m
>> [39m	                result.push(env.ie.getSelectionChangeObservable(el).where(function (doc) { return doc.activeElement === el; }));[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'dragend'));[31m
>> [39m	                // wx.IE 9 does support 'input', but since it doesn't fire it when[31m
>> [39m	                // using autocomplete, we'll use 'propertychange' for it also.[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'input'));[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'propertychange').where(function (e) { return e.propertyName === 'value'; }));[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // All other supported browsers support the 'input' event, which fires whenever the content of the element is changed[31m
>> [39m	            // through the user interface.[31m
>> [39m	            result.push(Rx.Observable.fromEvent(el, 'input'));[31m
>> [39m	            if (env.safari && env.safari.version < 5 && isTextArea) {[31m
>> [39m	                // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'[31m
>> [39m	                // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'keydown'));[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'paste'));[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'cut'));[31m
>> [39m	            }[31m
>> [39m	            else if (env.opera && env.opera.version < 11) {[31m
>> [39m	                // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.[31m
>> [39m	                // We can try to catch some of those using 'keydown'.[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'keydown'));[31m
>> [39m	            }[31m
>> [39m	            else if (env.firefox && env.firefox.version < 4.0) {[31m
>> [39m	                // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'DOMAutoComplete'));[31m
>> [39m	                // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'dragdrop')); // <3.5[31m
>> [39m	                result.push(Rx.Observable.fromEvent(el, 'drop')); // 3.5[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // Bind to the change event so that we can catch programmatic updates of the value that fire this event.[31m
>> [39m	        result.push(Rx.Observable.fromEvent(el, 'change'));[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    return TextInputBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = TextInputBinding;[31m
>> [39m	//# sourceMappingURL=TextInput.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 37 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var Value_1 = __webpack_require__(31);[31m
>> [39m	var List_1 = __webpack_require__(27);[31m
>> [39m	"use strict";[31m
>> [39m	var impls = new Array();[31m
>> [39m	var RadioSingleSelectionImpl = (function () {[31m
>> [39m	    function RadioSingleSelectionImpl(domManager) {[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	    }[31m
>> [39m	    RadioSingleSelectionImpl.prototype.supports = function (el, model) {[31m
>> [39m	        return (el.tagName.toLowerCase() === 'input' &&[31m
>> [39m	            el.getAttribute("type") === 'radio') &&[31m
>> [39m	            !List_1.isList(model);[31m
>> [39m	    };[31m
>> [39m	    RadioSingleSelectionImpl.prototype.observeElement = function (el) {[31m
>> [39m	        return Rx.Observable.merge(Rx.Observable.fromEvent(el, 'click'), Rx.Observable.fromEvent(el, 'change'));[31m
>> [39m	    };[31m
>> [39m	    RadioSingleSelectionImpl.prototype.observeModel = function (model) {[31m
>> [39m	        if (Utils_1.isProperty(model)) {[31m
>> [39m	            var prop = model;[31m
>> [39m	            return prop.changed;[31m
>> [39m	        }[31m
>> [39m	        return Rx.Observable.never();[31m
>> [39m	    };[31m
>> [39m	    RadioSingleSelectionImpl.prototype.updateElement = function (el, model) {[31m
>> [39m	        var input = el;[31m
>> [39m	        input.checked = Value_1.getNodeValue(input, this.domManager) == Utils_1.unwrapProperty(model);[31m
>> [39m	    };[31m
>> [39m	    RadioSingleSelectionImpl.prototype.updateModel = function (el, model, e) {[31m
>> [39m	        var input = el;[31m
>> [39m	        if (input.checked) {[31m
>> [39m	            model(Value_1.getNodeValue(input, this.domManager));[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    return RadioSingleSelectionImpl;[31m
>> [39m	})();[31m
>> [39m	var OptionSingleSelectionImpl = (function () {[31m
>> [39m	    function OptionSingleSelectionImpl(domManager) {[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	    }[31m
>> [39m	    OptionSingleSelectionImpl.prototype.supports = function (el, model) {[31m
>> [39m	        return el.tagName.toLowerCase() === 'select' &&[31m
>> [39m	            !List_1.isList(model);[31m
>> [39m	    };[31m
>> [39m	    OptionSingleSelectionImpl.prototype.observeElement = function (el) {[31m
>> [39m	        return Rx.Observable.fromEvent(el, 'change');[31m
>> [39m	    };[31m
>> [39m	    OptionSingleSelectionImpl.prototype.observeModel = function (model) {[31m
>> [39m	        if (Utils_1.isProperty(model)) {[31m
>> [39m	            var prop = model;[31m
>> [39m	            return prop.changed;[31m
>> [39m	        }[31m
>> [39m	        return Rx.Observable.never();[31m
>> [39m	    };[31m
>> [39m	    OptionSingleSelectionImpl.prototype.updateElement = function (el, model) {[31m
>> [39m	        var select = el;[31m
>> [39m	        var value = Utils_1.unwrapProperty(model);[31m
>> [39m	        var length = select.options.length;[31m
>> [39m	        if (value == null) {[31m
>> [39m	            select.selectedIndex = -1;[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            for (var i = 0; i < length; i++) {[31m
>> [39m	                var option = select.options[i];[31m
>> [39m	                if (Value_1.getNodeValue(option, this.domManager) == value) {[31m
>> [39m	                    select.selectedIndex = i;[31m
>> [39m	                    break;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    OptionSingleSelectionImpl.prototype.updateModel = function (el, model, e) {[31m
>> [39m	        var select = el;[31m
>> [39m	        // selected-value comes from the option at selectedIndex[31m
>> [39m	        var value = select.selectedIndex !== -1 ?[31m
>> [39m	            Value_1.getNodeValue(select.options[select.selectedIndex], this.domManager) :[31m
>> [39m	            undefined;[31m
>> [39m	        model(value);[31m
>> [39m	    };[31m
>> [39m	    return OptionSingleSelectionImpl;[31m
>> [39m	})();[31m
>> [39m	var SelectedValueBinding = (function () {[31m
>> [39m	    function SelectedValueBinding(domManager, app) {[31m
>> [39m	        this.priority = 0;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	        impls.push(new RadioSingleSelectionImpl(domManager));[31m
>> [39m	        impls.push(new OptionSingleSelectionImpl(domManager));[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    SelectedValueBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("selectedValue-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var impl;[31m
>> [39m	        var implCleanup;[31m
>> [39m	        var exp = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        function cleanupImpl() {[31m
>> [39m	            if (implCleanup) {[31m
>> [39m	                implCleanup.dispose();[31m
>> [39m	                implCleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // options is supposed to be a field-access path[31m
>> [39m	        state.cleanup.add(this.domManager.expressionToObservable(exp, ctx).subscribe(function (model) {[31m
>> [39m	            try {[31m
>> [39m	                cleanupImpl();[31m
>> [39m	                // lookup implementation[31m
>> [39m	                impl = undefined;[31m
>> [39m	                for (var i = 0; i < impls.length; i++) {[31m
>> [39m	                    if (impls[i].supports(el, model)) {[31m
>> [39m	                        impl = impls[i];[31m
>> [39m	                        break;[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	                if (!impl)[31m
>> [39m	                    Utils_1.throwError("selectedValue-binding does not support this combination of bound element and model!");[31m
>> [39m	                implCleanup = new Rx.CompositeDisposable();[31m
>> [39m	                // initial update[31m
>> [39m	                impl.updateElement(el, model);[31m
>> [39m	                // update on model change[31m
>> [39m	                implCleanup.add(impl.observeModel(model).subscribe(function (x) {[31m
>> [39m	                    try {[31m
>> [39m	                        impl.updateElement(el, model);[31m
>> [39m	                    }[31m
>> [39m	                    catch (e) {[31m
>> [39m	                        _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                    }[31m
>> [39m	                }));[31m
>> [39m	                // wire change-events[31m
>> [39m	                if (Utils_1.isProperty(model)) {[31m
>> [39m	                    implCleanup.add(impl.observeElement(el).subscribe(function (e) {[31m
>> [39m	                        try {[31m
>> [39m	                            impl.updateModel(el, model, e);[31m
>> [39m	                        }[31m
>> [39m	                        catch (e) {[31m
>> [39m	                            _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	                        }[31m
>> [39m	                    }));[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            el = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            cleanupImpl();[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    SelectedValueBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    return SelectedValueBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = SelectedValueBinding;[31m
>> [39m	//# sourceMappingURL=SelectedValue.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 38 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var ComponentBinding = (function () {[31m
>> [39m	    function ComponentBinding(domManager, app) {[31m
>> [39m	        this.priority = 30;[31m
>> [39m	        this.controlsDescendants = true;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    ComponentBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("component-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var compiled = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var opt = compiled;[31m
>> [39m	        var exp;[31m
>> [39m	        var componentNameObservable;[31m
>> [39m	        var componentParams = {};[31m
>> [39m	        var cleanup;[31m
>> [39m	        function doCleanup() {[31m
>> [39m	            if (cleanup) {[31m
>> [39m	                cleanup.dispose();[31m
>> [39m	                cleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        if (typeof compiled === "function") {[31m
>> [39m	            exp = compiled;[31m
>> [39m	            componentNameObservable = this.domManager.expressionToObservable(exp, ctx);[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // collect component-name observable[31m
>> [39m	            componentNameObservable = this.domManager.expressionToObservable(opt.name, ctx);[31m
>> [39m	            // collect params observables[31m
>> [39m	            if (opt.params) {[31m
>> [39m	                if (Utils_1.isFunction(opt.params)) {[31m
>> [39m	                    // opt params is object passed by value (probably $componentParams from view-binding)[31m
>> [39m	                    componentParams = this.domManager.evaluateExpression(opt.params, ctx);[31m
>> [39m	                }[31m
>> [39m	                else if (typeof opt.params === "object") {[31m
>> [39m	                    Object.keys(opt.params).forEach(function (x) {[31m
>> [39m	                        componentParams[x] = _this.domManager.evaluateExpression(opt.params[x], ctx);[31m
>> [39m	                    });[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    Utils_1.throwError("invalid component-params");[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // clear children[31m
>> [39m	        var oldContents = new Array();[31m
>> [39m	        while (el.firstChild) {[31m
>> [39m	            oldContents.push(el.removeChild(el.firstChild));[31m
>> [39m	        }[31m
>> [39m	        // subscribe to any input changes[31m
>> [39m	        state.cleanup.add(componentNameObservable.subscribe(function (componentName) {[31m
>> [39m	            try {[31m
>> [39m	                doCleanup();[31m
>> [39m	                cleanup = new Rx.CompositeDisposable();[31m
>> [39m	                // lookup component[31m
>> [39m	                var obs = module.loadComponent(componentName, componentParams);[31m
>> [39m	                var disp = undefined;[31m
>> [39m	                if (obs == null)[31m
>> [39m	                    Utils_1.throwError("component '{0}' is not registered with current module-context", componentName);[31m
>> [39m	                disp = obs.subscribe(function (component) {[31m
>> [39m	                    // loader cleanup[31m
>> [39m	                    if (disp != null) {[31m
>> [39m	                        disp.dispose();[31m
>> [39m	                        disp = undefined;[31m
>> [39m	                    }[31m
>> [39m	                    // auto-dispose view-model[31m
>> [39m	                    if (component.viewModel) {[31m
>> [39m	                        if (Utils_1.isDisposable(component.viewModel)) {[31m
>> [39m	                            cleanup.add(component.viewModel);[31m
>> [39m	                        }[31m
>> [39m	                    }[31m
>> [39m	                    // done[31m
>> [39m	                    _this.applyTemplate(component, el, ctx, state, component.template, component.viewModel);[31m
>> [39m	                });[31m
>> [39m	                if (disp != null)[31m
>> [39m	                    cleanup.add(disp);[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	            oldContents = null;[31m
>> [39m	            compiled = null;[31m
>> [39m	            doCleanup();[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    ComponentBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    ComponentBinding.prototype.applyTemplate = function (component, el, ctx, state, template, vm) {[31m
>> [39m	        // clear[31m
>> [39m	        while (el.firstChild) {[31m
>> [39m	            this.domManager.cleanNode(el.firstChild);[31m
>> [39m	            el.removeChild(el.firstChild);[31m
>> [39m	        }[31m
>> [39m	        // clone template and inject[31m
>> [39m	        for (var i = 0; i < template.length; i++) {[31m
>> [39m	            var node = template[i].cloneNode(true);[31m
>> [39m	            el.appendChild(node);[31m
>> [39m	        }[31m
>> [39m	        if (vm) {[31m
>> [39m	            state.model = vm;[31m
>> [39m	            // refresh context[31m
>> [39m	            ctx = this.domManager.getDataContext(el);[31m
>> [39m	        }[31m
>> [39m	        // invoke preBindingInit [31m
>> [39m	        if (vm && component.preBindingInit && vm.hasOwnProperty(component.preBindingInit)) {[31m
>> [39m	            vm[component.preBindingInit].call(vm, el);[31m
>> [39m	        }[31m
>> [39m	        // done[31m
>> [39m	        this.domManager.applyBindingsToDescendants(ctx, el);[31m
>> [39m	        // invoke postBindingInit [31m
>> [39m	        if (vm && component.postBindingInit && vm.hasOwnProperty(component.postBindingInit)) {[31m
>> [39m	            vm[component.postBindingInit].call(vm, el);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    return ComponentBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = ComponentBinding;[31m
>> [39m	//# sourceMappingURL=Component.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 39 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var StateActiveBinding = (function () {[31m
>> [39m	    function StateActiveBinding(domManager, router, app) {[31m
>> [39m	        this.priority = 5;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.router = router;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    StateActiveBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("stateActive-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var compiled = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var exp;[31m
>> [39m	        var observables = [];[31m
>> [39m	        var opt = compiled;[31m
>> [39m	        var paramsKeys = [];[31m
>> [39m	        var stateName;[31m
>> [39m	        var stateParams;[31m
>> [39m	        var cssClass = "active";[31m
>> [39m	        observables.push(this.router.current.changed.startWith(this.router.current()));[31m
>> [39m	        if (typeof compiled === "function") {[31m
>> [39m	            exp = compiled;[31m
>> [39m	            observables.push(this.domManager.expressionToObservable(exp, ctx));[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // collect state-name observable[31m
>> [39m	            observables.push(this.domManager.expressionToObservable(opt.name, ctx));[31m
>> [39m	            // collect params observables[31m
>> [39m	            if (opt.params) {[31m
>> [39m	                Object.keys(opt.params).forEach(function (x) {[31m
>> [39m	                    paramsKeys.push(x);[31m
>> [39m	                    observables.push(_this.domManager.expressionToObservable(opt.params[x], ctx));[31m
>> [39m	                });[31m
>> [39m	            }[31m
>> [39m	            if (opt.cssClass) {[31m
>> [39m	                cssClass = this.domManager.evaluateExpression(opt.cssClass, ctx);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // subscribe to any input changes[31m
>> [39m	        state.cleanup.add(Rx.Observable.combineLatest(observables, function (_) { return Utils_1.args2Array(arguments); }).subscribe(function (latest) {[31m
>> [39m	            try {[31m
>> [39m	                // first element is the current state[31m
>> [39m	                var currentState = latest.shift();[31m
>> [39m	                // second element is the state-name[31m
>> [39m	                stateName = Utils_1.unwrapProperty(latest.shift());[31m
>> [39m	                // subsequent entries are latest param values[31m
>> [39m	                stateParams = {};[31m
>> [39m	                for (var i = 0; i < paramsKeys.length; i++) {[31m
>> [39m	                    stateParams[paramsKeys[i]] = Utils_1.unwrapProperty(latest[i]);[31m
>> [39m	                }[31m
>> [39m	                var active = _this.router.includes(stateName, stateParams);[31m
>> [39m	                var classes = cssClass.split(/\s+/).map(function (x) { return x.trim(); }).filter(function (x) { return x; });[31m
>> [39m	                if (classes.length) {[31m
>> [39m	                    Utils_1.toggleCssClass.apply(null, [el, active].concat(classes));[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            observables = null;[31m
>> [39m	            compiled = null;[31m
>> [39m	            stateName = null;[31m
>> [39m	            stateParams = null;[31m
>> [39m	            opt = null;[31m
>> [39m	            paramsKeys = null;[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    StateActiveBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    return StateActiveBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = StateActiveBinding;[31m
>> [39m	//# sourceMappingURL=StateActive.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 40 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var ViewBinding = (function () {[31m
>> [39m	    function ViewBinding(domManager, router, app) {[31m
>> [39m	        this.priority = 1000;[31m
>> [39m	        this.controlsDescendants = true;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.router = router;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    ViewBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("view-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var compiled = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var viewName = this.domManager.evaluateExpression(compiled, ctx);[31m
>> [39m	        var currentConfig;[31m
>> [39m	        var cleanup;[31m
>> [39m	        function doCleanup() {[31m
>> [39m	            if (cleanup) {[31m
>> [39m	                cleanup.dispose();[31m
>> [39m	                cleanup = null;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        if (viewName == null || typeof viewName !== "string")[31m
>> [39m	            Utils_1.throwError("views must be named!");[31m
>> [39m	        // subscribe to router-state changes[31m
>> [39m	        state.cleanup.add(this.router.current.changed.startWith(this.router.current()).subscribe(function (newState) {[31m
>> [39m	            try {[31m
>> [39m	                doCleanup();[31m
>> [39m	                cleanup = new Rx.CompositeDisposable();[31m
>> [39m	                var config = _this.router.getViewComponent(viewName);[31m
>> [39m	                if (config != null) {[31m
>> [39m	                    if (!Utils_1.isEqual(currentConfig, config)) {[31m
>> [39m	                        cleanup.add(_this.applyTemplate(viewName, config.component, currentConfig ? currentConfig.component : undefined, config.params, config.animations, el, ctx, module));[31m
>> [39m	                        currentConfig = config;[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    cleanup.add(_this.applyTemplate(viewName, null, currentConfig ? currentConfig.component : undefined, null, currentConfig ? currentConfig.animations : {}, el, ctx, module));[31m
>> [39m	                    currentConfig = {};[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify common locals[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    ViewBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    ViewBinding.prototype.applyTemplate = function (viewName, componentName, previousComponentName, componentParams, animations, el, ctx, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var self = this;[31m
>> [39m	        var oldElements = Utils_1.nodeChildrenToArray(el);[31m
>> [39m	        var combined = [];[31m
>> [39m	        var obs;[31m
>> [39m	        function removeOldElements() {[31m
>> [39m	            oldElements.forEach(function (x) {[31m
>> [39m	                self.domManager.cleanNode(x);[31m
>> [39m	                el.removeChild(x);[31m
>> [39m	            });[31m
>> [39m	        }[31m
>> [39m	        function instantiateComponent(animation) {[31m
>> [39m	            // extend the data-context[31m
>> [39m	            ctx.$componentParams = componentParams;[31m
>> [39m	            // create component container element[31m
>> [39m	            var container = document.createElement("div");[31m
>> [39m	            var binding = Utils_1.formatString("component: { name: '{0}', params: $componentParams }", componentName);[31m
>> [39m	            container.setAttribute("data-bind", binding);[31m
>> [39m	            // prepare container for animation[31m
>> [39m	            if (animation != null)[31m
>> [39m	                animation.prepare(container);[31m
>> [39m	            // now insert it[31m
>> [39m	            el.appendChild(container);[31m
>> [39m	            // and apply bindings[31m
>> [39m	            self.domManager.applyBindings(ctx, container);[31m
>> [39m	        }[31m
>> [39m	        // construct leave-observable[31m
>> [39m	        if (oldElements.length > 0) {[31m
>> [39m	            var leaveAnimation;[31m
>> [39m	            if (animations && animations.leave) {[31m
>> [39m	                if (typeof animations.leave === "string") {[31m
>> [39m	                    leaveAnimation = module.animation(animations.leave);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    leaveAnimation = animations.leave;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            if (leaveAnimation) {[31m
>> [39m	                leaveAnimation.prepare(oldElements);[31m
>> [39m	                obs = leaveAnimation.run(oldElements)[31m
>> [39m	                    .continueWith(function () { return leaveAnimation.complete(oldElements); })[31m
>> [39m	                    .continueWith(removeOldElements);[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                obs = Rx.Observable.startDeferred(removeOldElements);[31m
>> [39m	            }[31m
>> [39m	            combined.push(obs);[31m
>> [39m	        }[31m
>> [39m	        // construct enter-observable[31m
>> [39m	        if (componentName != null) {[31m
>> [39m	            var enterAnimation;[31m
>> [39m	            if (animations && animations.enter) {[31m
>> [39m	                if (typeof animations.enter === "string") {[31m
>> [39m	                    enterAnimation = module.animation(animations.enter);[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    enterAnimation = animations.enter;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            obs = Rx.Observable.startDeferred(function () { return instantiateComponent(enterAnimation); });[31m
>> [39m	            if (enterAnimation) {[31m
>> [39m	                obs = obs.continueWith(enterAnimation.run(el.childNodes))[31m
>> [39m	                    .continueWith(function () { return enterAnimation.complete(el.childNodes); });[31m
>> [39m	            }[31m
>> [39m	            // notify world[31m
>> [39m	            obs = obs.continueWith(function () {[31m
>> [39m	                var transition = {[31m
>> [39m	                    view: viewName,[31m
>> [39m	                    fromComponent: previousComponentName,[31m
>> [39m	                    toComponent: componentName[31m
>> [39m	                };[31m
>> [39m	                var ri = _this.router;[31m
>> [39m	                ri.viewTransitionsSubject.onNext(transition);[31m
>> [39m	            });[31m
>> [39m	            combined.push(obs);[31m
>> [39m	        }[31m
>> [39m	        // optimize return[31m
>> [39m	        if (combined.length > 1)[31m
>> [39m	            obs = Rx.Observable.combineLatest(combined, Utils_1.noop).take(1);[31m
>> [39m	        else if (combined.length === 1)[31m
>> [39m	            obs = combined[0].take(1);[31m
>> [39m	        else[31m
>> [39m	            obs = null;[31m
>> [39m	        // no-op return[31m
>> [39m	        return obs ? (obs.subscribe() || Rx.Disposable.empty) : Rx.Disposable.empty;[31m
>> [39m	    };[31m
>> [39m	    return ViewBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = ViewBinding;[31m
>> [39m	//# sourceMappingURL=View.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 41 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../../../node_modules/rx/ts/rx.all.d.ts" />[31m
>> [39m	/// <reference path="../../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var StateRefBinding = (function () {[31m
>> [39m	    function StateRefBinding(domManager, router, app) {[31m
>> [39m	        this.priority = 5;[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.router = router;[31m
>> [39m	        this.app = app;[31m
>> [39m	    }[31m
>> [39m	    ////////////////////[31m
>> [39m	    // wx.IBinding[31m
>> [39m	    StateRefBinding.prototype.applyBinding = function (node, options, ctx, state, module) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        if (node.nodeType !== 1)[31m
>> [39m	            Utils_1.throwError("stateRef-binding only operates on elements!");[31m
>> [39m	        if (options == null)[31m
>> [39m	            Utils_1.throwError("invalid binding-options!");[31m
>> [39m	        var el = node;[31m
>> [39m	        var isAnchor = el.tagName.toLowerCase() === "a";[31m
>> [39m	        var anchor = isAnchor ? el : undefined;[31m
>> [39m	        var compiled = this.domManager.compileBindingOptions(options, module);[31m
>> [39m	        var exp;[31m
>> [39m	        var observables = [];[31m
>> [39m	        var opt = compiled;[31m
>> [39m	        var paramsKeys = [];[31m
>> [39m	        var stateName;[31m
>> [39m	        var stateParams;[31m
>> [39m	        if (typeof compiled === "function") {[31m
>> [39m	            exp = compiled;[31m
>> [39m	            observables.push(this.domManager.expressionToObservable(exp, ctx));[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // collect state-name observable[31m
>> [39m	            observables.push(this.domManager.expressionToObservable(opt.name, ctx));[31m
>> [39m	            // collect params observables[31m
>> [39m	            if (opt.params) {[31m
>> [39m	                Object.keys(opt.params).forEach(function (x) {[31m
>> [39m	                    paramsKeys.push(x);[31m
>> [39m	                    observables.push(_this.domManager.expressionToObservable(opt.params[x], ctx));[31m
>> [39m	                });[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // subscribe to any input changes[31m
>> [39m	        state.cleanup.add(Rx.Observable.combineLatest(observables, function (_) { return Utils_1.args2Array(arguments); }).subscribe(function (latest) {[31m
>> [39m	            try {[31m
>> [39m	                // first element is always the state-name[31m
>> [39m	                stateName = Utils_1.unwrapProperty(latest.shift());[31m
>> [39m	                // subsequent entries are latest param values[31m
>> [39m	                stateParams = {};[31m
>> [39m	                for (var i = 0; i < paramsKeys.length; i++) {[31m
>> [39m	                    stateParams[paramsKeys[i]] = Utils_1.unwrapProperty(latest[i]);[31m
>> [39m	                }[31m
>> [39m	                if (anchor != null) {[31m
>> [39m	                    anchor.href = _this.router.url(stateName, stateParams);[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                _this.app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        }));[31m
>> [39m	        // subscribe to anchor's click event[31m
>> [39m	        state.cleanup.add(Rx.Observable.fromEvent(el, "click").subscribe(function (e) {[31m
>> [39m	            e.preventDefault();[31m
>> [39m	            // initiate state change using latest name and params[31m
>> [39m	            _this.router.go(stateName, stateParams, { location: true });[31m
>> [39m	        }));[31m
>> [39m	        // release closure references to GC [31m
>> [39m	        state.cleanup.add(Rx.Disposable.create(function () {[31m
>> [39m	            // nullify args[31m
>> [39m	            node = null;[31m
>> [39m	            options = null;[31m
>> [39m	            ctx = null;[31m
>> [39m	            state = null;[31m
>> [39m	            // nullify locals[31m
>> [39m	            observables = null;[31m
>> [39m	            compiled = null;[31m
>> [39m	            stateName = null;[31m
>> [39m	            stateParams = null;[31m
>> [39m	            opt = null;[31m
>> [39m	            paramsKeys = null;[31m
>> [39m	        }));[31m
>> [39m	    };[31m
>> [39m	    StateRefBinding.prototype.configure = function (options) {[31m
>> [39m	        // intentionally left blank[31m
>> [39m	    };[31m
>> [39m	    return StateRefBinding;[31m
>> [39m	})();[31m
>> [39m	exports.default = StateRefBinding;[31m
>> [39m	//# sourceMappingURL=StateRef.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 42 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var templateCache = {};[31m
>> [39m	var SelectComponent = (function () {[31m
>> [39m	    function SelectComponent(htmlTemplateEngine) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        this.template = function (params) {[31m
>> [39m	            return _this.buildTemplate(params);[31m
>> [39m	        };[31m
>> [39m	        this.viewModel = function (params) {[31m
>> [39m	            var opt = params;[31m
>> [39m	            return {[31m
>> [39m	                items: params.items,[31m
>> [39m	                selectedValue: params.selectedValue,[31m
>> [39m	                hooks: { afterRender: opt.afterRender }[31m
>> [39m	            };[31m
>> [39m	        };[31m
>> [39m	        this.htmlTemplateEngine = htmlTemplateEngine;[31m
>> [39m	    }[31m
>> [39m	    SelectComponent.prototype.buildTemplate = function (params) {[31m
>> [39m	        var result;[31m
>> [39m	        var key = undefined;[31m
>> [39m	        var nodes;[31m
>> [39m	        // check cache[31m
>> [39m	        if (!params.noCache) {[31m
>> [39m	            key = (params.name != null ? params.name : "") + "-" +[31m
>> [39m	                (params.itemText != null ? params.itemText : "") + "-" +[31m
>> [39m	                (params.itemValue != null ? params.itemValue : "") + "-" +[31m
>> [39m	                (params.itemClass != null ? params.itemClass : "") + "-" +[31m
>> [39m	                (params.selectedValue != null ? "true" : "false") + "-" +[31m
>> [39m	                (params.multiple ? "true" : "false") + "-" +[31m
>> [39m	                (params.required ? "true" : "false") + "-" +[31m
>> [39m	                (params.autofocus ? "true" : "false") + "-" +[31m
>> [39m	                (params.size ? params.size.toString() : "0");[31m
>> [39m	            nodes = templateCache[key];[31m
>> [39m	            if (nodes != null) {[31m
>> [39m	                //console.log("cache hit", key, result);[31m
>> [39m	                return nodes;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // base-template[31m
>> [39m	        result = '<select class="wx-select" data-bind="{0}"><option data-bind="{1}"></option></select>';[31m
>> [39m	        var bindings = [];[31m
>> [39m	        var attrs = [];[31m
>> [39m	        var itemBindings = [];[31m
>> [39m	        var itemAttrs = [];[31m
>> [39m	        bindings.push({ key: "foreach", value: "{ data: items, hooks: hooks }" });[31m
>> [39m	        // selection (two-way)[31m
>> [39m	        if (params.selectedValue)[31m
>> [39m	            bindings.push({ key: "selectedValue", value: "@selectedValue" });[31m
>> [39m	        // name[31m
>> [39m	        if (params.name) {[31m
>> [39m	            attrs.push({ key: 'name', value: params.name });[31m
>> [39m	        }[31m
>> [39m	        // multi-select[31m
>> [39m	        if (params.multiple) {[31m
>> [39m	            attrs.push({ key: 'multiple', value: "true" });[31m
>> [39m	        }[31m
>> [39m	        // size[31m
>> [39m	        if (params.size !== undefined) {[31m
>> [39m	            attrs.push({ key: 'size', value: params.size.toString() });[31m
>> [39m	        }[31m
>> [39m	        // required[31m
>> [39m	        if (params.required) {[31m
>> [39m	            attrs.push({ key: 'required', value: "true" });[31m
>> [39m	        }[31m
>> [39m	        // required[31m
>> [39m	        if (params.autofocus) {[31m
>> [39m	            attrs.push({ key: 'autofocus', value: "true" });[31m
>> [39m	        }[31m
>> [39m	        // assemble attr-binding[31m
>> [39m	        if (attrs.length)[31m
>> [39m	            bindings.push({ key: "attr", value: "{ " + attrs.map(function (x) { return x.key + ": " + x.value; }).join(", ") + " }" });[31m
>> [39m	        // value[31m
>> [39m	        itemBindings.push({ key: "value", value: params.itemValue || "$data" });[31m
>> [39m	        // label[31m
>> [39m	        itemBindings.push({ key: 'text', value: params.itemText || "$data" });[31m
>> [39m	        // per-item css class[31m
>> [39m	        if (params.itemClass) {[31m
>> [39m	            itemAttrs.push({ key: 'class', value: "'" + params.itemClass + "'" });[31m
>> [39m	        }[31m
>> [39m	        // assemble attr-binding[31m
>> [39m	        if (itemAttrs.length)[31m
>> [39m	            itemBindings.push({ key: "attr", value: "{ " + itemAttrs.map(function (x) { return x.key + ": " + x.value; }).join(", ") + " }" });[31m
>> [39m	        // assemble all bindings[31m
>> [39m	        var bindingString = bindings.map(function (x) { return x.key + ": " + x.value; }).join(", ");[31m
>> [39m	        var itemBindingString = itemBindings.map(function (x) { return x.key + ": " + x.value; }).join(", ");[31m
>> [39m	        // assemble template[31m
>> [39m	        result = Utils_1.formatString(result, bindingString, itemBindingString);[31m
>> [39m	        //console.log(result);[31m
>> [39m	        // store[31m
>> [39m	        if (!params.noCache) {[31m
>> [39m	            templateCache[key] = result;[31m
>> [39m	        }[31m
>> [39m	        // app.templateEngine can be altered by developer therefore we make sure to parse using HtmlTemplateEngine[31m
>> [39m	        nodes = this.htmlTemplateEngine.parse(result);[31m
>> [39m	        return nodes;[31m
>> [39m	    };[31m
>> [39m	    return SelectComponent;[31m
>> [39m	})();[31m
>> [39m	exports.default = SelectComponent;[31m
>> [39m	//# sourceMappingURL=Select.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 43 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	"use strict";[31m
>> [39m	var groupId = 0;[31m
>> [39m	var templateCache = {};[31m
>> [39m	var RadioGroupComponent = (function () {[31m
>> [39m	    function RadioGroupComponent(htmlTemplateEngine) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        this.template = function (params) {[31m
>> [39m	            return _this.buildTemplate(params);[31m
>> [39m	        };[31m
>> [39m	        this.viewModel = function (params) {[31m
>> [39m	            var opt = params;[31m
>> [39m	            var groupName = opt.groupName != null ?[31m
>> [39m	                opt.groupName :[31m
>> [39m	                Utils_1.formatString("wx-radiogroup-{0}", groupId++);[31m
>> [39m	            return {[31m
>> [39m	                items: params.items,[31m
>> [39m	                selectedValue: params.selectedValue,[31m
>> [39m	                groupName: groupName,[31m
>> [39m	                hooks: { afterRender: params.afterRender }[31m
>> [39m	            };[31m
>> [39m	        };[31m
>> [39m	        this.htmlTemplateEngine = htmlTemplateEngine;[31m
>> [39m	    }[31m
>> [39m	    RadioGroupComponent.prototype.buildTemplate = function (params) {[31m
>> [39m	        var result;[31m
>> [39m	        var key = undefined;[31m
>> [39m	        var nodes;[31m
>> [39m	        // check cache[31m
>> [39m	        if (!params.noCache) {[31m
>> [39m	            key = (params.itemText != null ? params.itemText : "") + "-" +[31m
>> [39m	                (params.itemValue != null ? params.itemValue : "") + "-" +[31m
>> [39m	                (params.itemClass != null ? params.itemClass : "") + "-" +[31m
>> [39m	                (params.selectedValue != null ? "true" : "false");[31m
>> [39m	            nodes = templateCache[key];[31m
>> [39m	            if (nodes != null) {[31m
>> [39m	                //console.log("cache hit", key, result);[31m
>> [39m	                return nodes;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // base-template[31m
>> [39m	        result = '<div class="wx-radiogroup" data-bind="{0}"><input type="radio" data-bind="{1}"/>{2}</div>';[31m
>> [39m	        var bindings = [];[31m
>> [39m	        var attrs = [];[31m
>> [39m	        var itemBindings = [];[31m
>> [39m	        var itemAttrs = [];[31m
>> [39m	        var perItemExtraMarkup = "";[31m
>> [39m	        bindings.push({ key: "foreach", value: "{ data: items, hooks: hooks }" });[31m
>> [39m	        // assemble attr-binding[31m
>> [39m	        if (attrs.length)[31m
>> [39m	            bindings.push({ key: "attr", value: "{ " + attrs.map(function (x) { return x.key + ": " + x.value; }).join(", ") + " }" });[31m
>> [39m	        // value[31m
>> [39m	        itemBindings.push({ key: "value", value: params.itemValue || "$data" });[31m
>> [39m	        // name[31m
>> [39m	        itemAttrs.push({ key: 'name', value: "$parent.groupName" });[31m
>> [39m	        // selection (two-way)[31m
>> [39m	        if (params.selectedValue) {[31m
>> [39m	            itemBindings.push({ key: "selectedValue", value: "$parent.@selectedValue" });[31m
>> [39m	        }[31m
>> [39m	        // label[31m
>> [39m	        if (params.itemText) {[31m
>> [39m	            perItemExtraMarkup += Utils_1.formatString('<label data-bind="text: {0}, attr: { for: {1} }"></label>', params.itemText, "$parent.groupName + '-' + $index");[31m
>> [39m	            itemAttrs.push({ key: 'id', value: "$parent.groupName + '-' + $index" });[31m
>> [39m	        }[31m
>> [39m	        // per-item css class[31m
>> [39m	        if (params.itemClass) {[31m
>> [39m	            itemAttrs.push({ key: 'class', value: "'" + params.itemClass + "'" });[31m
>> [39m	        }[31m
>> [39m	        // assemble attr-binding[31m
>> [39m	        if (itemAttrs.length)[31m
>> [39m	            itemBindings.push({ key: "attr", value: "{ " + itemAttrs.map(function (x) { return x.key + ": " + x.value; }).join(", ") + " }" });[31m
>> [39m	        // assemble all bindings[31m
>> [39m	        var bindingString = bindings.map(function (x) { return x.key + ": " + x.value; }).join(", ");[31m
>> [39m	        var itemBindingString = itemBindings.map(function (x) { return x.key + ": " + x.value; }).join(", ");[31m
>> [39m	        // assemble template[31m
>> [39m	        result = Utils_1.formatString(result, bindingString, itemBindingString, perItemExtraMarkup);[31m
>> [39m	        // store[31m
>> [39m	        if (!params.noCache) {[31m
>> [39m	            templateCache[key] = result;[31m
>> [39m	        }[31m
>> [39m	        // app.templateEngine can be altered by developer therefore we make sure to parse using HtmlTemplateEngine[31m
>> [39m	        nodes = this.htmlTemplateEngine.parse(result);[31m
>> [39m	        return nodes;[31m
>> [39m	    };[31m
>> [39m	    return RadioGroupComponent;[31m
>> [39m	})();[31m
>> [39m	exports.default = RadioGroupComponent;[31m
>> [39m	//# sourceMappingURL=RadioGroup.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 44 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var Property_1 = __webpack_require__(12);[31m
>> [39m	var RouteMatcher_1 = __webpack_require__(45);[31m
>> [39m	"use strict";[31m
>> [39m	var Router = (function () {[31m
>> [39m	    function Router(domManager, app) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        this.current = Property_1.property();[31m
>> [39m	        //////////////////////////////////[31m
>> [39m	        // Implementation[31m
>> [39m	        this.states = {};[31m
>> [39m	        this.pathSeparator = ".";[31m
>> [39m	        this.parentPathDirective = "^";[31m
>> [39m	        this.rootStateName = "$";[31m
>> [39m	        this.validPathRegExp = /^[a-zA-Z]([\w-_]*$)/;[31m
>> [39m	        this.viewTransitionsSubject = new Rx.Subject();[31m
>> [39m	        this.domManager = domManager;[31m
>> [39m	        this.app = app;[31m
>> [39m	        this.viewTransitions = this.viewTransitionsSubject.asObservable();[31m
>> [39m	        this.reset(false);[31m
>> [39m	        // monitor navigation history[31m
>> [39m	        app.history.onPopState.subscribe(function (e) {[31m
>> [39m	            try {[31m
>> [39m	                // certain versions of WebKit raise an empty popstate event on page-load[31m
>> [39m	                if (e && e.state) {[31m
>> [39m	                    var state = e.state;[31m
>> [39m	                    var stateName = state.stateName;[31m
>> [39m	                    if (stateName != null) {[31m
>> [39m	                        // enter state using extracted params[31m
>> [39m	                        _this.go(stateName, state.params, { location: false });[31m
>> [39m	                        // update title[31m
>> [39m	                        app.title(state.title);[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            catch (e) {[31m
>> [39m	                app.defaultExceptionHandler.onNext(e);[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	        // monitor title changes[31m
>> [39m	        app.title.changed.subscribe(function (x) {[31m
>> [39m	            document.title = x;[31m
>> [39m	            if (_this.current() != null)[31m
>> [39m	                _this.replaceHistoryState(_this.current(), x);[31m
>> [39m	        });[31m
>> [39m	    }[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // IRouter[31m
>> [39m	    Router.prototype.state = function (config) {[31m
>> [39m	        this.registerStateInternal(config);[31m
>> [39m	        return this;[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.updateCurrentStateParams = function (withParamsAction) {[31m
>> [39m	        var _current = this.current();[31m
>> [39m	        withParamsAction(_current.params);[31m
>> [39m	        this.replaceHistoryState(_current, this.app.title());[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.go = function (to, params, options) {[31m
>> [39m	        to = this.mapPath(to);[31m
>> [39m	        if (this.states[to] == null)[31m
>> [39m	            Utils_1.throwError("state '{0}' is not registered", to);[31m
>> [39m	        this.activateState(to, params, options);[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.get = function (state) {[31m
>> [39m	        return this.states[state];[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.is = function (state, params, options) {[31m
>> [39m	        var _current = this.current();[31m
>> [39m	        var isActive = _current.name === state;[31m
>> [39m	        params = params || {};[31m
>> [39m	        if (isActive) {[31m
>> [39m	            var currentParamsKeys = Object.keys(_current.params);[31m
>> [39m	            var paramsKeys = Object.keys(params);[31m
>> [39m	            if (currentParamsKeys.length === paramsKeys.length) {[31m
>> [39m	                for (var i = 0; i < paramsKeys.length; i++) {[31m
>> [39m	                    if (_current.params[paramsKeys[i]] != params[paramsKeys[i]]) {[31m
>> [39m	                        isActive = false;[31m
>> [39m	                        break;[31m
>> [39m	                    }[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                isActive = false;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return isActive;[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.includes = function (state, params, options) {[31m
>> [39m	        var _current = this.current();[31m
>> [39m	        var isActive = _current.name.indexOf(state) === 0;[31m
>> [39m	        params = params || {};[31m
>> [39m	        if (isActive) {[31m
>> [39m	            var currentParamsKeys = Object.keys(_current.params);[31m
>> [39m	            var paramsKeys = Object.keys(params);[31m
>> [39m	            paramsKeys = paramsKeys.length <= currentParamsKeys.length ?[31m
>> [39m	                paramsKeys : currentParamsKeys;[31m
>> [39m	            for (var i = 0; i < paramsKeys.length; i++) {[31m
>> [39m	                if (_current.params[paramsKeys[i]] != params[paramsKeys[i]]) {[31m
>> [39m	                    isActive = false;[31m
>> [39m	                    break;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return isActive;[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.url = function (state, params) {[31m
>> [39m	        state = this.mapPath(state);[31m
>> [39m	        var route = this.getAbsoluteRouteForState(state);[31m
>> [39m	        if (route != null)[31m
>> [39m	            return route.stringify(params);[31m
>> [39m	        return null;[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.reset = function (enterRootState) {[31m
>> [39m	        if (enterRootState === void 0) { enterRootState = true; }[31m
>> [39m	        this.states = {};[31m
>> [39m	        // Implicit root state that is always present[31m
>> [39m	        this.root = this.registerStateInternal({[31m
>> [39m	            name: this.rootStateName,[31m
>> [39m	            url: RouteMatcher_1.route("/")[31m
>> [39m	        });[31m
>> [39m	        if (enterRootState)[31m
>> [39m	            this.go(this.rootStateName, {}, { location: 2 /[22m replace [1m/ });[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.sync = function (url) {[31m
>> [39m	        if (url == null)[31m
>> [39m	            url = this.app.history.location.pathname; // + app.history.location.search;[31m
>> [39m	        // iterate over registered states to find matching uri[31m
>> [39m	        var keys = Object.keys(this.states);[31m
>> [39m	        var length = keys.length;[31m
>> [39m	        var params;[31m
>> [39m	        for (var i = 0; i < length; i++) {[31m
>> [39m	            var state = this.states[keys[i]];[31m
>> [39m	            var route_1 = this.getAbsoluteRouteForState(state.name);[31m
>> [39m	            if ((params = route_1.parse(url)) != null) {[31m
>> [39m	                this.go(state.name, params, { location: 2 /[22m replace [1m/ });[31m
>> [39m	                return;[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        // not found, enter root state as fallback[31m
>> [39m	        if (this.current() == null)[31m
>> [39m	            this.reload();[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.reload = function () {[31m
>> [39m	        var state;[31m
>> [39m	        var params;[31m
>> [39m	        // reload current state or enter inital root state            [31m
>> [39m	        if (this.current() != null) {[31m
>> [39m	            state = this.current().name;[31m
>> [39m	            params = this.current().params;[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            state = this.rootStateName;[31m
>> [39m	            params = {};[31m
>> [39m	        }[31m
>> [39m	        this.go(state, params, { force: true, location: 2 /[22m replace [1m/ });[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.getViewComponent = function (viewName) {[31m
>> [39m	        var _current = this.current();[31m
>> [39m	        var result = undefined;[31m
>> [39m	        if (_current.views != null) {[31m
>> [39m	            var component = _current.views[viewName];[31m
>> [39m	            var stateParams = {};[31m
>> [39m	            if (component != null) {[31m
>> [39m	                result = {};[31m
>> [39m	                if (typeof component === "object") {[31m
>> [39m	                    result.component = component.component;[31m
>> [39m	                    result.params = component.params || {};[31m
>> [39m	                    result.animations = component.animations;[31m
>> [39m	                }[31m
>> [39m	                else {[31m
>> [39m	                    result.component = component;[31m
>> [39m	                    result.params = {};[31m
>> [39m	                    result.animations = undefined;[31m
>> [39m	                }[31m
>> [39m	                // ensure that only parameters configured at state level surface at view-level[31m
>> [39m	                var parameterNames = this.getViewParameterNamesFromStateConfig(viewName, result.component);[31m
>> [39m	                parameterNames.forEach(function (x) {[31m
>> [39m	                    if (_current.params.hasOwnProperty(x)) {[31m
>> [39m	                        stateParams[x] = _current.params[x];[31m
>> [39m	                    }[31m
>> [39m	                });[31m
>> [39m	                // merge state params into component params[31m
>> [39m	                result.params = Utils_1.extend(stateParams, result.params);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.registerStateInternal = function (state) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        var parts = state.name.split(this.pathSeparator);[31m
>> [39m	        if (state.name !== this.rootStateName) {[31m
>> [39m	            // validate name[31m
>> [39m	            if (parts.forEach(function (path) {[31m
>> [39m	                if (!_this.validPathRegExp.test(path)) {[31m
>> [39m	                    Utils_1.throwError("invalid state-path '{0}' (a state-path must start with a character, optionally followed by one or more alphanumeric characters, dashes or underscores)");[31m
>> [39m	                }[31m
>> [39m	            }))[31m
>> [39m	                ;[31m
>> [39m	        }[31m
>> [39m	        // wrap and store[31m
>> [39m	        state = Utils_1.extend(state, {});[31m
>> [39m	        this.states[state.name] = state;[31m
>> [39m	        if (state.url != null) {[31m
>> [39m	            // create route from string[31m
>> [39m	            if (typeof state.url === "string") {[31m
>> [39m	                state.url = RouteMatcher_1.route(state.url);[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // derive relative route from name[31m
>> [39m	            if (state.name !== this.rootStateName)[31m
>> [39m	                state.url = RouteMatcher_1.route(parts[parts.length - 1]);[31m
>> [39m	            else[31m
>> [39m	                state.url = RouteMatcher_1.route("/");[31m
>> [39m	        }[31m
>> [39m	        // detect root-state override[31m
>> [39m	        if (state.name === this.rootStateName)[31m
>> [39m	            this.root = state;[31m
>> [39m	        return state;[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.pushHistoryState = function (state, title) {[31m
>> [39m	        var hs = {[31m
>> [39m	            stateName: state.name,[31m
>> [39m	            params: state.params,[31m
>> [39m	            title: title != null ? title : document.title[31m
>> [39m	        };[31m
>> [39m	        this.app.history.pushState(hs, "", state.url);[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.replaceHistoryState = function (state, title) {[31m
>> [39m	        var hs = {[31m
>> [39m	            stateName: state.name,[31m
>> [39m	            params: state.params,[31m
>> [39m	            title: title != null ? title : document.title[31m
>> [39m	        };[31m
>> [39m	        this.app.history.replaceState(hs, "", state.url);[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.mapPath = function (path) {[31m
>> [39m	        // child-relative[31m
>> [39m	        if (path.indexOf(this.pathSeparator) === 0) {[31m
>> [39m	            return this.current().name + path;[31m
>> [39m	        }[31m
>> [39m	        else if (path.indexOf(this.parentPathDirective) === 0) {[31m
>> [39m	            // parent-relative                [31m
>> [39m	            var parent_1 = this.current().name;[31m
>> [39m	            // can't go further up than root[31m
>> [39m	            if (parent_1 === this.rootStateName)[31m
>> [39m	                return parent_1;[31m
>> [39m	            // test parents and siblings until one is found that is registered[31m
>> [39m	            var parts = parent_1.split(this.pathSeparator);[31m
>> [39m	            for (var i = parts.length - 1; i > 0; i--) {[31m
>> [39m	                var tmp = parts.slice(0, i).join(this.pathSeparator);[31m
>> [39m	                // check if parent or sibling relative to current parent exists [31m
>> [39m	                if (this.get(tmp) || this.get(tmp + path.substr(1))) {[31m
>> [39m	                    path = tmp + path.substr(1);[31m
>> [39m	                    return path;[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	            // make it root relative[31m
>> [39m	            path = this.rootStateName + path.substr(1);[31m
>> [39m	            return path;[31m
>> [39m	        }[31m
>> [39m	        return path;[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.getStateHierarchy = function (name) {[31m
>> [39m	        var parts = name.split(this.pathSeparator);[31m
>> [39m	        var stateName = "";[31m
>> [39m	        var result = [];[31m
>> [39m	        var state;[31m
>> [39m	        if (name !== this.rootStateName)[31m
>> [39m	            result.push(this.root);[31m
>> [39m	        for (var i = 0; i < parts.length; i++) {[31m
>> [39m	            if (i > 0)[31m
>> [39m	                stateName += this.pathSeparator + parts[i];[31m
>> [39m	            else[31m
>> [39m	                stateName = parts[i];[31m
>> [39m	            state = this.states[stateName];[31m
>> [39m	            // if not registered, introduce fake state to keep hierarchy intact[31m
>> [39m	            if (state == null) {[31m
>> [39m	                state = {[31m
>> [39m	                    name: stateName,[31m
>> [39m	                    url: RouteMatcher_1.route(stateName)[31m
>> [39m	                };[31m
>> [39m	            }[31m
>> [39m	            result.push(state);[31m
>> [39m	        }[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.getAbsoluteRouteForState = function (name, hierarchy) {[31m
>> [39m	        hierarchy = hierarchy != null ? hierarchy : this.getStateHierarchy(name);[31m
>> [39m	        var result = null;[31m
>> [39m	        hierarchy.forEach(function (state) {[31m
>> [39m	            // concat urls[31m
>> [39m	            if (result != null) {[31m
>> [39m	                var route_2 = state.url;[31m
>> [39m	                // individual states may use absolute urls as well[31m
>> [39m	                if (!route_2.isAbsolute)[31m
>> [39m	                    result = result.concat(state.url);[31m
>> [39m	                else[31m
>> [39m	                    result = route_2;[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                result = state.url;[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.activateState = function (to, params, options) {[31m
>> [39m	        var hierarchy = this.getStateHierarchy(to);[31m
>> [39m	        var stateViews = {};[31m
>> [39m	        var stateParams = {};[31m
>> [39m	        hierarchy.forEach(function (state) {[31m
>> [39m	            // merge views[31m
>> [39m	            if (state.views != null) {[31m
>> [39m	                Utils_1.extend(state.views, stateViews);[31m
>> [39m	            }[31m
>> [39m	            // merge params[31m
>> [39m	            if (state.params != null) {[31m
>> [39m	                Utils_1.extend(state.params, stateParams);[31m
>> [39m	            }[31m
>> [39m	        });[31m
>> [39m	        // merge param overrides[31m
>> [39m	        if (params) {[31m
>> [39m	            Utils_1.extend(params, stateParams);[31m
>> [39m	        }[31m
>> [39m	        // construct resulting state[31m
>> [39m	        var route = this.getAbsoluteRouteForState(to, hierarchy);[31m
>> [39m	        var state = Utils_1.extend(this.states[to], {});[31m
>> [39m	        state.url = route.stringify(params);[31m
>> [39m	        state.views = stateViews;[31m
>> [39m	        state.params = stateParams;[31m
>> [39m	        // perform deep equal against current state[31m
>> [39m	        var _current = this.current();[31m
>> [39m	        if ((options && options.force) || _current == null ||[31m
>> [39m	            _current.name !== to ||[31m
>> [39m	            !Utils_1.isEqual(_current.params, state.params)) {[31m
>> [39m	            // reset views used by previous state that are unused by new state[31m
>> [39m	            if (_current != null && _current.views != null && state.views != null) {[31m
>> [39m	                Object.keys(_current.views).forEach(function (x) {[31m
>> [39m	                    if (!state.views.hasOwnProperty(x)) {[31m
>> [39m	                        state.views[x] = null;[31m
>> [39m	                    }[31m
>> [39m	                });[31m
>> [39m	            }[31m
>> [39m	            // update history[31m
>> [39m	            if (options && options.location) {[31m
>> [39m	                if (options.location === 2 /[22m replace [1m/)[31m
>> [39m	                    this.replaceHistoryState(state, this.app.title());[31m
>> [39m	                else[31m
>> [39m	                    this.pushHistoryState(state, this.app.title());[31m
>> [39m	            }[31m
>> [39m	            if (_current != null) {[31m
>> [39m	                if (_current.onLeave)[31m
>> [39m	                    _current.onLeave(this.get(_current.name), _current.params);[31m
>> [39m	            }[31m
>> [39m	            // activate[31m
>> [39m	            this.current(state);[31m
>> [39m	            if (state.onEnter)[31m
>> [39m	                state.onEnter(this.get(state.name), params);[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    Router.prototype.getViewParameterNamesFromStateConfig = function (view, component) {[31m
>> [39m	        var hierarchy = this.getStateHierarchy(this.current().name);[31m
>> [39m	        var stateParams = {};[31m
>> [39m	        var result = [];[31m
>> [39m	        var config;[31m
>> [39m	        var index = -1;[31m
>> [39m	        // walk the hierarchy backward to figure out when the component was introduced at the specified view-slot[31m
>> [39m	        for (var i = hierarchy.length; i--; i >= 0) {[31m
>> [39m	            config = hierarchy[i];[31m
>> [39m	            if (config.views && config.views[view]) {[31m
>> [39m	                var other = config.views[view];[31m
>> [39m	                if (typeof other === "object") {[31m
>> [39m	                    other = other.component;[31m
>> [39m	                }[31m
>> [39m	                if (other === component) {[31m
>> [39m	                    index = i; // found but keep looking[31m
>> [39m	                }[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        if (index !== -1) {[31m
>> [39m	            config = hierarchy[index];[31m
>> [39m	            // truncate hierarchy and merge params[31m
>> [39m	            hierarchy = hierarchy.slice(0, index + 1);[31m
>> [39m	            hierarchy.forEach(function (state) {[31m
>> [39m	                // merge params[31m
>> [39m	                if (state.params != null) {[31m
>> [39m	                    Utils_1.extend(state.params, stateParams);[31m
>> [39m	                }[31m
>> [39m	            });[31m
>> [39m	            // extract resulting property names[31m
>> [39m	            result = Object.keys(stateParams);[31m
>> [39m	            // append any route-params[31m
>> [39m	            result = result.concat(config.url.params);[31m
>> [39m	        }[31m
>> [39m	        return result;[31m
>> [39m	    };[31m
>> [39m	    return Router;[31m
>> [39m	})();[31m
>> [39m	exports.Router = Router;[31m
>> [39m	//# sourceMappingURL=Router.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 45 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	/[22m[31m
>> [39m	 * JavaScript Route Matcher[31m
>> [39m	 * http://benalman.com/[31m
>> [39m	 *[31m
>> [39m	 * Copyright (c) 2011 "Cowboy" Ben Alman[31m
>> [39m	 * Dual licensed under the MIT and GPL licenses.[31m
>> [39m	 * http://benalman.com/about/license/[31m
>> [39m	 [1m/[31m
>> [39m	"use strict";[31m
>> [39m	// Characters to be escaped with \. RegExp borrowed from the Backbone router[31m
>> [39m	// but escaped (note: unnecessarily) to keep JSHint from complaining.[31m
>> [39m	var reEscape = /[\-\[\]{}()+?.,\\\^$|#\s]/g;[31m
>> [39m	// Match named :param or *splat placeholders.[31m
>> [39m	var reParam = /([:*])(\w+)/g;[31m
>> [39m	var RouteMatcher = (function () {[31m
>> [39m	    // Pass in a route string (or RegExp) plus an optional map of rules, and get[31m
>> [39m	    // back an object with .parse and .stringify methods.[31m
>> [39m	    function RouteMatcher(route, rules) {[31m
>> [39m	        var _this = this;[31m
>> [39m	        // store[31m
>> [39m	        this.route = route;[31m
>> [39m	        this.rules = rules;[31m
>> [39m	        // Object to be returned. The public API.[31m
>> [39m	        // Matched param or splat names, in order[31m
>> [39m	        this.params = [];[31m
>> [39m	        // Route matching RegExp.[31m
>> [39m	        var re = route;[31m
>> [39m	        // Build route RegExp from passed string.[31m
>> [39m	        if (typeof route === "string") {[31m
>> [39m	            // Escape special chars.[31m
>> [39m	            re = re.replace(reEscape, "\\$&");[31m
>> [39m	            // Replace any :param or *splat with the appropriate capture group.[31m
>> [39m	            re = re.replace(reParam, function ([24m, mode, name) {[31m
>> [39m	                _this.params.push(name);[31m
>> [39m	                // :param should capture until the next / or EOL, while *splat should[31m
>> [39m	                // capture until the next :param, *splat, or EOL.[31m
>> [39m	                return mode === ":" ? "([^/]*)" : "(.*)";[31m
>> [39m	            });[31m
>> [39m	            // Add ^/$ anchors and create the actual RegExp.[31m
>> [39m	            re = new RegExp("^" + re + "$");[31m
>> [39m	            // Match the passed url against the route, returning an object of params[31m
>> [39m	            // and values.[31m
>> [39m	            this.parse = function (url) {[31m
>> [39m	                var i = 0;[31m
>> [39m	                var param, value;[31m
>> [39m	                var params = {};[31m
>> [39m	                var matches = url.match(re);[31m
>> [39m	                // If no matches, return null.[31m
>> [39m	                if (!matches) {[31m
>> [39m	                    return null;[31m
>> [39m	                }[31m
>> [39m	                // Add all matched :param / *splat values into the params object.[31m
>> [39m	                while (i < _this.params.length) {[31m
>> [39m	                    param = _this.params[i++];[31m
>> [39m	                    value = matches[i];[31m
>> [39m	                    // If a rule exists for this param and it doesn't validate, return null.[31m
>> [39m	                    if (rules && param in rules && !_this.validateRule(rules[param], value)) {[31m
>> [39m	                        return null;[31m
>> [39m	                    }[31m
>> [39m	                    params[param] = value;[31m
>> [39m	                }[31m
>> [39m	                return params;[31m
>> [39m	            };[31m
>> [39m	            // Build path by inserting the given params into the route.[31m
>> [39m	            this.stringify = function (params) {[31m
>> [39m	                params = params || {};[31m
>> [39m	                var param, re;[31m
>> [39m	                var result = route;[31m
>> [39m	                // Insert each passed param into the route string. Note that this loop[31m
>> [39m	                // doesn't check .hasOwnProperty because this script doesn't support[31m
>> [39m	                // modifications to Object.prototype.[31m
>> [39m	                for (param in params) {[31m
>> [39m	                    re = new RegExp("[:*]" + param + "\\b");[31m
>> [39m	                    result = result.replace(re, params[param]);[31m
>> [39m	                }[31m
>> [39m	                // Missing params should be replaced with empty string.[31m
>> [39m	                return result.replace(reParam, "");[31m
>> [39m	            };[31m
>> [39m	        }[31m
>> [39m	        else {[31m
>> [39m	            // RegExp route was passed. This is super-simple.[31m
>> [39m	            this.parse = function (url) {[31m
>> [39m	                var matches = url.match(re);[31m
>> [39m	                return matches && { captures: matches.slice(1) };[31m
>> [39m	            };[31m
>> [39m	            // There's no meaningful way to stringify based on a RegExp route, so[31m
>> [39m	            // return empty string.[31m
>> [39m	            this.stringify = function () { return ""; };[31m
>> [39m	        }[31m
>> [39m	    }[31m
>> [39m	    RouteMatcher.prototype.stripTrailingSlash = function (route) {[31m
>> [39m	        if (route.length === 0 || route === "/" || route.lastIndexOf("/") !== route.length - 1)[31m
>> [39m	            return route;[31m
>> [39m	        return route.substr(0, route.length - 1);[31m
>> [39m	    };[31m
>> [39m	    Object.defineProperty(RouteMatcher.prototype, "isAbsolute", {[31m
>> [39m	        get: function () {[31m
>> [39m	            return this.route.indexOf("/") === 0;[31m
>> [39m	        },[31m
>> [39m	        enumerable: true,[31m
>> [39m	        configurable: true[31m
>> [39m	    });[31m
>> [39m	    RouteMatcher.prototype.concat = function (route) {[31m
>> [39m	        var other = route;[31m
>> [39m	        var a = this.stripTrailingSlash(this.route);[31m
>> [39m	        var b = this.stripTrailingSlash(other.route);[31m
>> [39m	        var rules = null;[31m
>> [39m	        // check for conflicting rules[31m
>> [39m	        if (other.rules) {[31m
>> [39m	            if (this.rules) {[31m
>> [39m	                Object.keys(this.rules).forEach(function (rule) {[31m
>> [39m	                    if (other.rules.hasOwnProperty(rule)) {[31m
>> [39m	                        Utils_1.throwError("route '{0}' and '{1}' have conflicting rule '{2}", a, b, rule);[31m
>> [39m	                    }[31m
>> [39m	                });[31m
>> [39m	                rules = Utils_1.extend(this.rules, Utils_1.extend(other.rules, {}));[31m
>> [39m	            }[31m
>> [39m	            else {[31m
>> [39m	                rules = Utils_1.extend(other.rules, {});[31m
>> [39m	            }[31m
>> [39m	        }[31m
>> [39m	        else if (this.rules) {[31m
>> [39m	            rules = Utils_1.extend(this.rules, {});[31m
>> [39m	        }[31m
>> [39m	        if (a === "/")[31m
>> [39m	            a = "";[31m
>> [39m	        return new RouteMatcher(a + "/" + b, rules);[31m
>> [39m	    };[31m
>> [39m	    // Test to see if a value matches the corresponding rule.[31m
>> [39m	    RouteMatcher.prototype.validateRule = function (rule, value) {[31m
>> [39m	        // For a given rule, get the first letter of the string name of its[31m
>> [39m	        // constructor function. "R" -> RegExp, "F" -> Function (these shouldn't[31m
>> [39m	        // conflict with any other types one might specify). Note: instead of[31m
>> [39m	        // getting .toString from a new object {} or Object.prototype, I'm assuming[31m
>> [39m	        // that exports will always be an object, and using its .toString method.[31m
>> [39m	        // Bad idea? Let me know by filing an issue[31m
>> [39m	        var type = this.toString.call(rule).charAt(8);[31m
>> [39m	        // If regexp, match. If function, invoke. Otherwise, compare. Note that ==[31m
>> [39m	        // is used because type coercion is needed, as `value` will always be a[31m
>> [39m	        // string, but `rule` might not.[31m
>> [39m	        return type === "R" ? rule.test(value) : type === "F" ? rule(value) : rule == value;[31m
>> [39m	    };[31m
>> [39m	    return RouteMatcher;[31m
>> [39m	})();[31m
>> [39m	exports.RouteMatcher = RouteMatcher;[31m
>> [39m	function route(route, rules) {[31m
>> [39m	    return new RouteMatcher(route, rules);[31m
>> [39m	}[31m
>> [39m	exports.route = route;[31m
>> [39m	//# sourceMappingURL=RouteMatcher.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 46 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="../Interfaces.ts" />[31m
>> [39m	var ScheduledSubject_1 = __webpack_require__(29);[31m
>> [39m	// ReactiveUI's MessageBus[31m
>> [39m	"use strict";[31m
>> [39m	var MessageBus = (function () {[31m
>> [39m	    function MessageBus() {[31m
>> [39m	        //////////////////////////////////[31m
>> [39m	        // Implementation[31m
>> [39m	        this.messageBus = {};[31m
>> [39m	        this.schedulerMappings = {};[31m
>> [39m	    }[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // IMessageBus[31m
>> [39m	    MessageBus.prototype.listen = function (contract) {[31m
>> [39m	        return this.setupSubjectIfNecessary(contract).skip(1);[31m
>> [39m	    };[31m
>> [39m	    MessageBus.prototype.isRegistered = function (contract) {[31m
>> [39m	        return this.messageBus.hasOwnProperty(contract);[31m
>> [39m	    };[31m
>> [39m	    MessageBus.prototype.registerMessageSource = function (source, contract) {[31m
>> [39m	        return source.subscribe(this.setupSubjectIfNecessary(contract));[31m
>> [39m	    };[31m
>> [39m	    MessageBus.prototype.sendMessage = function (message, contract) {[31m
>> [39m	        this.setupSubjectIfNecessary(contract).onNext(message);[31m
>> [39m	    };[31m
>> [39m	    MessageBus.prototype.registerScheduler = function (scheduler, contract) {[31m
>> [39m	        this.schedulerMappings[contract] = scheduler;[31m
>> [39m	    };[31m
>> [39m	    MessageBus.prototype.setupSubjectIfNecessary = function (contract) {[31m
>> [39m	        var ret = this.messageBus[contract];[31m
>> [39m	        if (ret == null) {[31m
>> [39m	            ret = ScheduledSubject_1.createScheduledSubject(this.getScheduler(contract), null, new Rx.BehaviorSubject(undefined));[31m
>> [39m	            this.messageBus[contract] = ret;[31m
>> [39m	        }[31m
>> [39m	        return ret;[31m
>> [39m	    };[31m
>> [39m	    MessageBus.prototype.getScheduler = function (contract) {[31m
>> [39m	        var scheduler = this.schedulerMappings[contract];[31m
>> [39m	        return scheduler || Rx.Scheduler.currentThread;[31m
>> [39m	    };[31m
>> [39m	    return MessageBus;[31m
>> [39m	})();[31m
>> [39m	exports.default = MessageBus;[31m
>> [39m	//# sourceMappingURL=MessageBus.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 47 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	exports.version = '0.9.78';[31m
>> [39m	//# sourceMappingURL=Version.js.map[31m
>> [39m[31m
>> [39m/***/ },[31m
>> [39m/[22m 48 [1m/[31m
>> [39m/***/ function(module, exports, __webpack_require__) {[31m
>> [39m[31m
>> [39m	/// <reference path="./Interfaces.ts" />[31m
>> [39m	var Utils_1 = __webpack_require__(2);[31m
>> [39m	var IID_1 = __webpack_require__(9);[31m
>> [39m	var ScheduledSubject_1 = __webpack_require__(29);[31m
>> [39m	var Reflect_1 = __webpack_require__(3);[31m
>> [39m	var Injector_1 = __webpack_require__(1);[31m
>> [39m	var res = __webpack_require__(10);[31m
>> [39m	"use strict";[31m
>> [39m	var RxObsConstructor = Rx.Observable; // this hack is neccessary because the .d.ts for RxJs declares Observable as an interface)[31m
>> [39m	/*[22m[31m
>> [39m	* Creates an read-only observable property with an optional default value from the current (this) observable[31m
>> [39m	* (Note: This is the equivalent to Knockout's ko.computed)[31m
>> [39m	* @param {T} initialValue? Optional initial value, valid until the observable produces a value[31m
>> [39m	*/[31m
>> [39m	function toProperty(initialValue, scheduler) {[31m
>> [39m	    scheduler = scheduler || Rx.Scheduler.currentThread;[31m
>> [39m	    // initialize accessor function (read-only)[31m
>> [39m	    var accessor = function propertyAccessor(newVal) {[31m
>> [39m	        if (arguments.length > 0) {[31m
>> [39m	            Utils_1.throwError("attempt to write to a read-only observable property");[31m
>> [39m	        }[31m
>> [39m	        if (accessor.sub == null) {[31m
>> [39m	            accessor.sub = accessor._source.connect();[31m
>> [39m	        }[31m
>> [39m	        return accessor.value;[31m
>> [39m	    };[31m
>> [39m	    Reflect_1.Implements(IID_1.default.IObservableProperty)(accessor);[31m
>> [39m	    Reflect_1.Implements(IID_1.default.IDisposable)(accessor);[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // IDisposable implementation[31m
>> [39m	    accessor.dispose = function () {[31m
>> [39m	        if (accessor.sub) {[31m
>> [39m	            accessor.sub.dispose();[31m
>> [39m	            accessor.sub = null;[31m
>> [39m	        }[31m
>> [39m	    };[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // IObservableProperty<T> implementation[31m
>> [39m	    accessor.value = initialValue;[31m
>> [39m	    // setup observables[31m
>> [39m	    accessor.changedSubject = new Rx.Subject();[31m
>> [39m	    accessor.changed = accessor.changedSubject[31m
>> [39m	        .publish()[31m
>> [39m	        .refCount();[31m
>> [39m	    accessor.changingSubject = new Rx.Subject();[31m
>> [39m	    accessor.changing = accessor.changingSubject[31m
>> [39m	        .publish()[31m
>> [39m	        .refCount();[31m
>> [39m	    accessor.source = this;[31m
>> [39m	    accessor.thrownExceptions = ScheduledSubject_1.createScheduledSubject(scheduler, Injector_1.injector.get(res.app).defaultExceptionHandler);[31m
>> [39m	    //////////////////////////////////[31m
>> [39m	    // implementation[31m
>> [39m	    var firedInitial = false;[31m
>> [39m	    accessor.sub = this[31m
>> [39m	        .distinctUntilChanged()[31m
>> [39m	        .subscribe(function (x) {[31m
>> [39m	        // Suppress a non-change between initialValue and the first value[31m
>> [39m	        // from a Subscribe[31m
>> [39m	        if (firedInitial && x === accessor.value) {[31m
>> [39m	            return;[31m
>> [39m	        }[31m
>> [39m	        firedInitial = true;[31m
>> [39m	        accessor.changingSubject.onNext(x);[31m
>> [39m	        accessor.value = x;[31m
>> [39m	        accessor.changedSubject.onNext(x);[31m
>> [39m	    }, function (x) { return accessor.thrownExceptions.onNext(x); });[31m
>> [39m	    return accessor;[31m
>> [39m	}[31m
>> [39m	RxObsConstructor.prototype.toProperty = toProperty;[31m
>> [39m	RxObsConstructor.prototype.continueWith = function () {[31m
>> [39m	    var args = Utils_1.args2Array(arguments);[31m
>> [39m	    var val = args.shift();[31m
>> [39m	    var obs = undefined;[31m
>> [39m	    if (Utils_1.isRxObservable(val)) {[31m
>> [39m	        obs = val;[31m
>> [39m	    }[31m
>> [39m	    else if (Utils_1.isFunction(val)) {[31m
>> [39m	        var action = val;[31m
>> [39m	        obs = Rx.Observable.startDeferred(action);[31m
>> [39m	    }[31m
>> [39m	    return this.selectMany(function (_) { return obs; });[31m
>> [39m	};[31m
>> [39m	RxObsConstructor.startDeferred = function (action) {[31m
>> [39m	    return Rx.Observable.defer(function () {[31m
>> [39m	        return Rx.Observable.create(function (observer) {[31m
>> [39m	            var cancelled = false;[31m
>> [39m	            if (!cancelled)[31m
>> [39m	                action();[31m
>> [39m	            observer.onNext(undefined);[31m
>> [39m	            observer.onCompleted();[31m
>> [39m	            return Rx.Disposable.create(function () { return cancelled = true; });[31m
>> [39m	        });[31m
>> [39m	    });[31m
>> [39m	};[31m
>> [39m	function install() {[31m
>> [39m	    // deliberately left blank    [31m
>> [39m	}[31m
>> [39m	exports.install = install;[31m
>> [39m	//# sourceMappingURL=RxExtensions.js.map[31m
>> [39m[31m
>> [39m/***/ }[31m
>> [39m/******/ ]);[31m
>> [39m}[31m
>> [39mhttp://requirejs.org/docs/errors.html#mismatch at
[31m>> [39m..\..\..\..\C:\Users\oliver\Projects\WebRx\node_modules\requirejs\require.js:141 defaultOnError
[31m>> [39m..\..\..\..\C:\Users\oliver\Projects\WebRx\node_modules\requirejs\require.js:545 onError
[31m>> [39m..\..\..\..\C:\Users\oliver\Projects\WebRx\node_modules\requirejs\require.js:1240 intakeDefines
[31m>> [39m..\..\..\..\C:\Users\oliver\Projects\WebRx\node_modules\requirejs\require.js:1427
[31m>> [39mReferenceError: Can't find variable: wx at
[31m>> [39m..\..\..\..\C:\Users\oliver\Projects\WebRx\build\test\Core\Lazy.js:3
 Bindings
   Checked
     - Triggering a click should toggle a checkbox's checked state before the event handler fires......√
     - Should be able to control a checkbox's checked state......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CheckedSpecs.js (line 30) (1)
     - Should be able to control a radio's checked state......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CheckedSpecs.js (line 40) (1)
     - Should update observable properties on the model when the checkbox click event fires......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CheckedSpecs.js (line 50) (1)
     - Should update observable properties on the model when the radio's click event fires......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CheckedSpecs.js (line 59) (1)
     - Should only notify observable properties on the model once even if the checkbox change events fire multiple times......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CheckedSpecs.js (line 68) (1)
     - Should only notify observable properties on the model once even if the radio change events fire multiple times......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CheckedSpecs.js (line 86) (1)
 Bindings
   Command
     - reacts to changes when bound to observable properties holding command and parameter......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CommandSpecs.js (line 22) (1)
     - button smoke-test - bound to options......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CommandSpecs.js (line 7) (1)
     - hyperlink smoke-test - bound to options......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CommandSpecs.js (line 7) (1)
     - button smoke-test - bound to command......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CommandSpecs.js (line 7) (1)
     - hyperlink smoke-test - bound to command......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/CommandSpecs.js (line 7) (1)
 Bindings
   Component
     - Loads a component using simple string options......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 9) (1)
     - Loads a component using object-literal options......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 19) (1)
     - Loads a component using its name as tag......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 29) (1)
     - Loads a component through an AMD module loader......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 38) (1)
     - Loads a template from a string......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 57) (1)
     - Loads a template from a node-array......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 67) (1)
     - Loads a template from a selector......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 76) (1)
     - Loads a template from a node instance......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 85) (1)
     - Loads a template through injector......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 95) (1)
     - Loads a template through an AMD module loader......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 112) (1)
     - When the component isn't supplying a view-model, binding against parent-context works as expected......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 124) (1)
     - Loads a view-model from a factory method......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 134) (1)
     - Loads a view-model through injector......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 145) (1)
     - Loads a view-model through injector using inline-annotated-array......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 157) (1)
     - Loads a view-model from an instance......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 172) (1)
     - Loads a view-model through an AMD module loader - object with postBindingInit......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 183) (1)
     - Loads a view-model through an AMD module loader - constructor function......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 199) (1)
     - Params get passed to view-model constructor......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 221) (1)
     - invokes preBindingInit......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 246) (1)
     - invokes postBindingInit......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ComponentSpecs.js (line 271) (1)
 Bindings
   Event
     - binds a single event to a handler function......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected false to be truthy. (2)
       Expected undefined to equal 'click'. (3)
       Expected false to be truthy. (4)
       Expected false to be truthy. (5)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/EventSpecs.js (line 35) (6)
     - binds multiple events to handler functions......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected 0 to equal 1. (2)
       Expected 0 to equal 1. (3)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/EventSpecs.js (line 62) (4)
     - binds multiple events to observers......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected 0 to equal 1. (2)
       Expected 0 to equal 1. (3)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/EventSpecs.js (line 93) (4)
     - binds multiple events to commands......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/EventSpecs.js (line 111) (1)
     - binds multiple events to commands with params......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/EventSpecs.js (line 139) (1)
 Bindings
   ForEach
     - binding to a standard array......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected 1 to equal 3. (3)
       Expected [ NaN ] to equal [ 1, 5, 7 ]. (4)
     - binding to a standard array and template accessing index......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected 1 to equal 3. (3)
       Expected [ NaN ] to equal [ 0, 1, 2 ]. (4)
     - binding to a property yielding an array......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ForEachSpecs.js (line 41) (2)
     - binding to a standard array - inline......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected 1 to equal 3. (3)
       Expected [ NaN ] to equal [ 1, 5, 7 ]. (4)
     - binding to a observable list containing numbers......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ForEachSpecs.js (line 62) (2)
     - binding to a observable list containing numbers without initialContents......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ForEachSpecs.js (line 71) (2)
     - binding to a observable list containing model......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - binding to a observable list containing model and template accessing index......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - observable list manipulation smoke-test......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - $index calculation when bound to observable list smoke-test......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - observable list item property-changes propagate to DOM......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - observable list with animation-hooks......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
   ForEach-animated
     - binding to a standard array......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected 1 to equal 3. (3)
       Expected [ NaN ] to equal [ 1, 5, 7 ]. (4)
     - binding to a standard array and template accessing index......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected 1 to equal 3. (3)
       Expected [ NaN ] to equal [ 0, 1, 2 ]. (4)
     - binding to a property yielding an array......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ForEachSpecs.js (line 41) (2)
     - binding to a standard array - inline......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected 1 to equal 3. (3)
       Expected [ NaN ] to equal [ 1, 5, 7 ]. (4)
     - binding to a observable list containing numbers......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ForEachSpecs.js (line 62) (2)
     - binding to a observable list containing numbers without initialContents......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ForEachSpecs.js (line 71) (2)
     - binding to a observable list containing model......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - binding to a observable list containing model and template accessing index......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - observable list manipulation smoke-test......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - $index calculation when bound to observable list smoke-test......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - observable list item property-changes propagate to DOM......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
     - observable list with animation-hooks......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (2)
 Bindings
   HasFocus
     - Should respond to changes on an observable value by blurring or focusing the element......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/HasFocusSpecs.js (line 15) (1)
     - Should set an observable value to be true on focus and false on blur......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/HasFocusSpecs.js (line 30) (1)
     - Should not unnecessarily focus or blur an element that is already focused/blurred......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/HasFocusSpecs.js (line 53) (1)
 Bindings
   If
     - binding to a boolean constant (true) using static template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
     - binding to a boolean constant (false) using static template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected '<span>foo</span>' to equal ''. (3)
     - binding to a boolean observable property using static template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/IfSpecs.js (line 28) (2)
     - binding to a boolean observable using static template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected '<span>foo</span>' to equal ''. (3)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/IfSpecs.js (line 48) (4)
     - binding to a boolean observable property using dynamic template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/IfSpecs.js (line 55) (2)
     - binding to a boolean observable property using dynamic template with command......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/IfSpecs.js (line 67) (2)
   If-animated
     - binding to a boolean constant (true) using static template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
     - binding to a boolean constant (false) using static template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected '<span>foo</span>' to equal ''. (3)
     - binding to a boolean observable property using static template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/IfSpecs.js (line 28) (2)
     - binding to a boolean observable using static template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       Expected function not to throw an Error, but it threw ReferenceError. (2)
       Expected '<span>foo</span>' to equal ''. (3)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/IfSpecs.js (line 48) (4)
     - binding to a boolean observable property using dynamic template......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/IfSpecs.js (line 55) (2)
     - binding to a boolean observable property using dynamic template with command......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 252) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/IfSpecs.js (line 67) (2)
 Bindings
 Bindings
   Module
     - binds using module name......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ModuleSpecs.js (line 9) (1)
     - binds using multiple module names......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ModuleSpecs.js (line 18) (1)
     - nested module contexts inherit bindings of parent......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ModuleSpecs.js (line 29) (1)
     - nested modules work as expected......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ModuleSpecs.js (line 40) (1)
 Bindings
   Css
     - binding to a string constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) to have class 'foo'. (2)
     - binding to a non-observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding to a observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding to a observable model @propref......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding to a model observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding multiple css classes to multiple observable model properties......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding to a non-observable model property - dynamic......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding to a observable model property - dynamic......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding to a observable model @propref - dynamic......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding using dynamic value does not interfere with manually added classes......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
   Attr
     - binding to a string constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) to have attr 'data-foo', 'true'. (2)
     - binding to a non-observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding to a observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding to a observable model @propref......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding to a model observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
     - binding multiple attr classes to multiple observable model properties......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/MultiOneWaySpecs.js (line 9) (1)
 Bindings
   SelectedValue
     Radio (single-selection)
       - Should be able to control a radio's checked state......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SelectedValueSpecs.js (line 15) (1)
       - Clicking a radio should reflect back to model......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SelectedValueSpecs.js (line 40) (1)
       - If initial model value is undefined none of the radios should be checked......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SelectedValueSpecs.js (line 57) (1)
     Select (single-selection)
       - Should be able to control a Select's selectedIndex......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SelectedValueSpecs.js (line 72) (1)
       - Selecting an option should reflect selection back to model......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SelectedValueSpecs.js (line 89) (1)
       - If initial model value is undefined, selectedIndex should be undefined as well......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SelectedValueSpecs.js (line 107) (1)
 Bindings
   Text
     - binding to a string constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected 'invalid' to equal 'foo'. (2)
     - binding to a numeric constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected 'invalid' to equal '42'. (2)
     - binding to a falsy numeric model property......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected 'invalid' to equal '0'. (2)
     - binding to a boolean constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected 'invalid' to equal 'true'. (2)
     - binding to a non-observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model @propref......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a model observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
   Visible
     - binding to a numeric constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) to be visible. (2)
     - binding to a boolean constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) to be visible. (2)
     - binding to a non-observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model @propref......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a model observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to an observable model property (using css classes)......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
   Hidden
     - binding to a numeric constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) not to be visible. (2)
     - binding to a boolean constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) not to be visible. (2)
     - binding to a non-observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a model observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to an observable model property (using css classes)......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
   Enable
     - binding to a numeric constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) not to be disabled. (2)
     - binding to a boolean constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) not to be disabled. (2)
     - binding to a non-observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model @propref......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a model observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
   Disable
     - binding to a numeric constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) to be disabled. (2)
     - binding to a boolean constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected ({ 0: HTMLNode, context: HTMLNode, length: 1 }) to be disabled. (2)
     - binding to a non-observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a model observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
   HTML
     - binding to a string constant......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected 'invalid' to equal '<span>bla</span>'. (2)
     - binding to a non-observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a observable model propref......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
     - binding to a model observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/SimpleOneWaySpecs.js (line 9) (1)
 Bindings
   TextInput
     - attempting to bind to other elements than input and textarea throws......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/TextInputSpecs.js (line 10) (1)
     - Should treat null values as empty strings......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
       Expected '' to equal '0'. (2)
     - Should assign an empty string as value if the model value is null......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
     - Should assign an empty string as value if the model value is undefined......×
       Expected function not to throw an Error, but it threw ReferenceError. (1)
     - For observable values, should unwrap the value and update on change......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/TextInputSpecs.js (line 39) (1)
     - For observable values, should update on change if new value is 'strictly' different from previous value......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/TextInputSpecs.js (line 49) (1)
     - For writeable observable values, should catch the node's onchange and write values back to the observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/TextInputSpecs.js (line 59) (1)
     - Should ignore node changes when bound to a read-only observable......×
       TypeError: 'undefined' is not a function (evaluating 'Rx.Observable.return('zzz').toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/TextInputSpecs.js (line 69) (1)
     - Should update observable on input event (on supported browsers) or propertychange event (on old IE)......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/TextInputSpecs.js (line 83) (1)
     - Should write only changed values to observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/TextInputSpecs.js (line 96) (1)
 Bindings
   Value
     - Should treat null values as empty strings......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ValueSpecs.js (line 11) (1)
     - Should assign an empty string as value if the model value is undefined......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ValueSpecs.js (line 18) (1)
     - For observable values, should unwrap the value and update on change......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ValueSpecs.js (line 24) (1)
     - For observable values, should update on change if new value is 'strictly' different from previous value......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ValueSpecs.js (line 34) (1)
     - For writeable observable values, should catch the node's onchange and write values back to the observable......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ValueSpecs.js (line 44) (1)
     - Should ignore node changes when bound to a read-only observable......×
       TypeError: 'undefined' is not a function (evaluating 'Rx.Observable.return('zzz').toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ValueSpecs.js (line 54) (1)
     - Should be able to write to observable subproperties of an observable, even after the parent observable has changed......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ValueSpecs.js (line 69) (1)
     - Should only register one single onchange handler......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/ValueSpecs.js (line 87) (1)
 Bindings
   With
     - bound to a non-observable property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/WithSpecs.js (line 9) (1)
     - bound to an observable property......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Bindings/WithSpecs.js (line 27) (1)
 Observable List
   - is correctly initialized from default value......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 8) (1)
   - length property is not ambiguous......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 12) (1)
   - shouldn't be read-only......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 18) (1)
   - indexer is not ambiguous......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 22) (1)
   - items added and removed test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 26) (1)
   - length changed test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 52) (1)
   - length changed test 2......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 73) (1)
   - isEmpty test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 82) (1)
   - length changed fires when clearing......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 88) (1)
   - when adding range of null error is thrown......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 95) (1)
   - when removing all of null error is thrown......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 99) (1)
   - when inserting range of null error is thrown......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 103) (1)
   - when inserting range out of range error is thrown......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 107) (1)
   - change-tracking should fire notifications......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 111) (1)
   - change-tracking should work when adding the same thing more than once......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 142) (1)
   - change-tracking should stop when an object is replaced and change-notification is suppressed......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 173) (1)
   - change-tracking items should be tracked even when suppressed......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 56) (1)
   - change-tracking should apply on addRange'd items......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 227) (1)
   - sort should actually sort......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 255) (1)
   - collections shouldnt share subscriptions......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 260) (1)
   - get a reset when adding a lot of items......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 287) (1)
   - get a range when adding an array of items......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 297) (1)
 Derived Observable List
   - derived observable lists should follow base collection......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 325) (1)
   - derived observable lists should be filtered......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 349) (1)
   - derived observable lists should be sorted......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 385) (1)
   - derived observable lists move notification smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 404) (1)
   - derived observable lists should understand nested move signals......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 418) (1)
   - derived observable lists should understand move even when sorted......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 431) (1)
   - derived observable lists should understand dummy move signal......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 459) (1)
   - derived observable lists should not signal redundant move signals......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 471) (1)
   - derived observable lists should handle moves when only containing one item......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 483) (1)
   - derived observable lists removal regression-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 498) (1)
   - derived observable lists should handle items removed......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 516) (1)
   - addRange smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 538) (1)
   - insertRange smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 560) (1)
   - derived observable lists should order correctly......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 582) (1)
   - derived observable lists should stop following after disposal......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 591) (1)
   - derived observable lists filter-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/List.js (line 601) (1)
 ISet
   - emulated: creation......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/Set.js (line 44) (1)
   - emulated: crud smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/Set.js (line 6) (1)
 IWeakMap
   - emulated: creation......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/WeakMap.js (line 19) (1)
   - emulated: crud smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Collections/WeakMap.js (line 6) (1)
 Components
   - encountered a declaration exception......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Components/RadioGroupSpecs.js (line 5) (1)
 Components
   - encountered a declaration exception......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Components/SelectSpecs.js (line 5) (1)
 Command
   - implements ICommand......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 7) (1)
   - completely default reactive command should fire......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 12) (1)
   - register sync function smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 27) (1)
   - execute with sync function doesnt throw on error......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 37) (1)
   - observable canExecute should show up in command......×
     TypeError: 'undefined' is not an object (evaluating 'disp.dispose') in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 69) (1)
   - observable execute func should be observable and act......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 71) (1)
   - observable can execute is not null after canExecute called......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 83) (1)
   - multiple subscribes shouldn't result in multiple notifications......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 90) (1)
   - canExecute exception shouldnt perma-break commands......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 102) (1)
   - execute doesnt throw on error......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 120) (1)
   - register async function smoke-test......×
     TypeError: 'undefined' is not an object (evaluating 'disp.dispose') in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 69) (1)
   - multiple subscribers shouldnt decrement refCount below zero......×
     TypeError: 'undefined' is not an object (evaluating 'disp.dispose') in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 69) (1)
   - mulftiple results from observable shouldnt decrement refCount below zero......×
     TypeError: 'undefined' is not an object (evaluating 'disp.dispose') in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 69) (1)
   - canExecute should change on in-flight op......×
     TypeError: 'undefined' is not an object (evaluating 'disp.dispose') in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 69) (1)
   - disallow concurrent execution test......×
     TypeError: 'undefined' is not an object (evaluating 'disp.dispose') in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 69) (1)
   - combined commands should fire child commands......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 234) (1)
   - combined commands should reflect canExecute of children......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 248) (1)
   - combined commands should be inactive on async in-flight ops......×
     TypeError: 'undefined' is not an object (evaluating 'disp.dispose') in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 69) (1)
   - combined commands should reflect parent canExecute......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 317) (1)
   - command can execute on whenAny......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 354) (1)
   - command executes in context of thisArg......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Command.js (line 372) (1)
 DomManager
   - encountered a declaration exception......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/DomManager.js (line 8) (1)
 ExpressionCompiler
   - encountered a declaration exception......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/ExpressionCompiler.js (line 375) (1)
 HtmlTemplateEngine
   - encountered a declaration exception......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/HtmlTemplateEngine.js (line 8) (1)
 Injector
   - should support creating instances of itself......×
     Expected function not to throw an Error, but it threw ReferenceError. (1)
     Expected undefined to be defined. (2)
   - throws when attempting to get unregistered type......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Injector.js (line 4) (1)
   - get singleton......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Injector.js (line 4) (1)
   - get singleton primitive......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Injector.js (line 4) (1)
   - get using factory method......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Injector.js (line 4) (1)
   - get using inline array notation with additional args......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Injector.js (line 4) (1)
   - get inline using array notation......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Injector.js (line 4) (1)
   - resolve inline annotated array......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Injector.js (line 4) (1)
   - properly detects circular dependencies......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Injector.js (line 4) (1)
 MessageBus
   - Smoke-Test......×
     TypeError: 'undefined' is not an object (evaluating 'disp.dispose') in file:///C:/Users/oliver/Projects/WebRx/build/test/TestUtils.js (line 69) (1)
   - explicit send message should work even after registering source......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/MessageBus.js (line 19) (1)
   - listening before registering a source should work......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/MessageBus.js (line 27) (1)
   - registering second message source should merge both sources......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/MessageBus.js (line 35) (1)
 Observable Properties
   - can be created using factory method......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 5) (1)
   - can be created using factory method with initial value......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 9) (1)
   - falsy initial values are not coerced to undefined......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 13) (1)
   - implements IObservableProperty......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 21) (1)
   - observables are set up during creation......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 25) (1)
   - invoking it as a function with a parameter changes the property's value......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 29) (1)
   - setting value to undefined works......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 34) (1)
   - type transition......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 41) (1)
   - setting a value fires change notifications......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 50) (1)
   - multiple subscribers receive notifications......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 59) (1)
   - 'changing' notification with new value is fired before 'changed' notification......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 69) (1)
   - notifications for changes in absence of any subscribers do not get buffered......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 88) (1)
   - consecutively assigning the same value does not result in duplicate change notifications......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Property.js (line 97) (1)
   - computed property using whenAny always has correct value......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/TestModels.js (line 5) (1)
 Output Properties
   - can be created using factory method......×
     TypeError: 'undefined' is not a function (evaluating 'Rx.Observable.never().toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 5) (1)
   - implements IObservableProperty......×
     TypeError: 'undefined' is not a function (evaluating 'Rx.Observable.never().toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 9) (1)
   - observables are set up during creation......×
     TypeError: 'undefined' is not a function (evaluating 'Rx.Observable.never().toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 13) (1)
   - can be created using factory method with initial value......×
     TypeError: 'undefined' is not a function (evaluating 'obs.toProperty(10)') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 18) (1)
   - source observable prefixed with startWith overrides initialValue......×
     TypeError: 'undefined' is not a function (evaluating 'obs.toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 23) (1)
   - invoking it as a function with a parameter to change it's value, throws an error......×
     TypeError: 'undefined' is not a function (evaluating 'Rx.Observable.never().toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 27) (1)
   - returns the last value of the underlying observable upon creation......×
     TypeError: 'undefined' is not a function (evaluating 'obs.toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 32) (1)
   - returns the last value of the underlying observable......×
     TypeError: 'undefined' is not a function (evaluating 'subject.toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 37) (1)
   - adding data to the underlying observable results in change notifications on the property......×
     TypeError: 'undefined' is not a function (evaluating 'subject.toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 43) (1)
   - multiple subscribers receive notifications......×
     TypeError: 'undefined' is not a function (evaluating 'subject.toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 53) (1)
   - 'changing' notification with new value is fired before 'changed' notification......×
     TypeError: 'undefined' is not a function (evaluating 'subject.toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 64) (1)
   - notifications for changes in absence of any subscribers do not get buffered......×
     TypeError: 'undefined' is not a function (evaluating 'subject.toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 84) (1)
   - consecutively assigning the same value does not result in duplicate change notifications......×
     TypeError: 'undefined' is not a function (evaluating 'subject.toProperty()') in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/PropertyComputed.js (line 94) (1)
 Utils
   - isStrictMode should be off for this file......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Utils.js (line 5) (1)
   - isInUnitTest smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Utils.js (line 8) (1)
   - getOid smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Utils.js (line 13) (1)
   - isProperty smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Utils.js (line 36) (1)
   - isCommand smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Utils.js (line 45) (1)
   - isRxScheduler smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Utils.js (line 53) (1)
   - isRxObservable smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Utils.js (line 64) (1)
   - toggleCssClass smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Utils.js (line 81) (1)
   - whenAny smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/Utils.js (line 98) (1)
 VirtualChildNodes
   - smoke-test......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/VirtualChildNodes.js (line 14) (1)
   - smoke-test - with aliens......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Core/VirtualChildNodes.js (line 42) (1)
 Routing
   - encountered a declaration exception......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Bindings/StateActive.js (line 6) (1)
 Routing
   - encountered a declaration exception......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Bindings/StateRef.js (line 7) (1)
 Routing
   - encountered a declaration exception......×
     ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Bindings/View.js (line 6) (1)
 Routing
   RouteMatcher
     parse
       - regex route......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 11) (1)
       - string route, basic......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 19) (1)
       - string route, one variable......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 26) (1)
       - string route, multiple variables......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 33) (1)
       - string route, one splat......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 39) (1)
       - string route, multiple splats......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 46) (1)
       - string route, variables and splats......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 57) (1)
       - a few backbone.js test routes......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 64) (1)
       - specific matching rules......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 76) (1)
     stringify
       - regex route......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 101) (1)
       - one variable......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 105) (1)
       - multiple variables......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 112) (1)
       - one splat......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 123) (1)
       - multiple splats......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 131) (1)
       - possibly conflicting param names......×
         ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/RouteMatcher.js (line 140) (1)
 Routing
   Router
     - throws on attempt to register invalid state-path......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       Expected function to throw an exception with a message matching /invalid state-path/, but it threw an exception with message 'Can't find variable: wx'. (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - infers route from state-name if not specified......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 22) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - preserves properties which have been manually added to current state params......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 41) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - child states inherit views of parent......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 65) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - child states inherit params of parent......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 82) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - child states can override views of parent......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 99) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - child states can override current.url......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 117) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - current.url reflects state-hierarchy......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 134) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - go() with history = true pushes a history record......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 169) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - transitions to the the correct state on history.popstate event......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 180) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - monitors wx.app.title and reflects current value in document.title......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 204) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - includes() correctly tests child and parent states including params......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 226) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - is() correctly tests state including missing-, too many-, too few-params or different param values......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 249) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - correctly maps parent path if parent is registered......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 271) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - correctly maps parent path to root if parent is [4mnot[24m registered......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 290) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - correctly maps sibling-path if both sibling and parent are registered......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 303) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - correctly maps sibling-path if sibling is registered and parent is not......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 328) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - correctly maps child-path if child is registered......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 347) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - invokes enter- and leave-callbacks......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 368) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - sync() correctly inferes the state from the browsers current location......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 389) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
     - getViewComponent() only returns params present at the state that introduced the view into the hierarchy......×
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 9) (1)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 428) (2)
       ReferenceError: Can't find variable: wx in file:///C:/Users/oliver/Projects/WebRx/build/test/Routing/Router.js (line 13) (3)
 TestUtils
   - trackSubscriptions smoke-test......√

318 specs in 2.718s.
[31m>> [39m316 failures
[33mWarning: Task "jasmine:default" failed. Use --force to continue.[39m

[31mAborted due to warnings.[39m
